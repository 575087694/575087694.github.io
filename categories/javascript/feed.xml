<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on JavaScript入门</title>
    <link>http://575087694.github.io/categories/javascript/</link>
    <description>Recent content in Javascript on JavaScript入门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 31 Jan 2014 05:04:40 +0000</lastBuildDate>
    <atom:link href="http://575087694.github.io/categories/javascript/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>1、导论</title>
      <link>http://575087694.github.io/post/index1/</link>
      <pubDate>Fri, 31 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index1/</guid>
      <description>

&lt;h2 id=&#34;内容简介:5fa5b894c99827b58a1ff5820173afba&#34;&gt;内容简介&lt;/h2&gt;

&lt;p&gt;本教程全面介绍JavaScript核心语法（ECMAScript 5.1版本），从最简单的开始讲起，循序渐进、由浅入深，力求清晰易懂。所有章节都带有大量的代码实例，便于理解和模仿，可以用到实际项目中，即学即用。&lt;/p&gt;

&lt;p&gt;更新的ES6 / ES7语法请参考我写的&lt;a href=&#34;http://es6.ruanyifeng.com/&#34;&gt;《ECMAScript 6入门》&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;javascript是什么:5fa5b894c99827b58a1ff5820173afba&#34;&gt;JavaScript是什么？&lt;/h2&gt;

&lt;p&gt;JavaScript是一种轻量级的脚本语言，可以部署在多种环境，最常见的部署环境就是浏览器。所谓“脚本语言”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。&lt;/p&gt;

&lt;p&gt;本质上，JavaScript语言是一种“对象模型”。各种部署环境通过这个模型，描述自己的功能和操作接口，从而通过JavaScript控制这些功能。&lt;/p&gt;

&lt;p&gt;JavaScript的核心部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Date&lt;/code&gt;、&lt;code&gt;Math&lt;/code&gt;等）。&lt;/p&gt;

&lt;p&gt;除此之外，各种部署环境提供额外的API（即只能在某个环境使用的接口），以便JavaScript调用。如果部署环境是浏览器，提供的额外API可以分成三大类：浏览器控制类、DOM类、Web类。浏览器控制类的接口用来操作浏览器，DOM类的接口用来操作网页的各种元素，Web类的接口用来实现互联网的各种功能。如果部署环境是服务器，则会提供各种操作系统的API，比如文件操作API、网络通信API等等，现在最流行的JavaScript服务器环境是Node。&lt;/p&gt;

&lt;p&gt;本教程主要介绍JavaScript语言和网页开发的基本知识，可以分成以下五大部分。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基本语法&lt;/li&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;浏览器API&lt;/li&gt;
&lt;li&gt;DOM&lt;/li&gt;
&lt;li&gt;Web API&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;服务器环境的编程，将有单独的Node教程。&lt;/p&gt;

&lt;h2 id=&#34;为什么学习javascript:5fa5b894c99827b58a1ff5820173afba&#34;&gt;为什么学习JavaScript？&lt;/h2&gt;

&lt;p&gt;JavaScript语言有一些显著特点，使得它非常值得学习。它既适合当作学习编程的入门语言，也适合当作日常开发的工作语言。它是目前最有希望、前途最光明的计算机语言之一。&lt;/p&gt;

&lt;h3 id=&#34;操控浏览器的能力:5fa5b894c99827b58a1ff5820173afba&#34;&gt;操控浏览器的能力&lt;/h3&gt;

&lt;p&gt;JavaScript的发明目的，就是作为浏览器的内置脚本语言，为网页开发者提供操控浏览器的能力。它是目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。&lt;/p&gt;

&lt;p&gt;目前，全世界几乎所有网页都使用JavaScript。如果不用，网站的易用性和使用效率将大打折扣，无法成为操作便利、对用户友好的网站。&lt;/p&gt;

&lt;p&gt;对于一个互联网开发者来说，如果你想提供漂亮的网页、令用户满意的上网体验、各种基于浏览器的便捷功能、前后端之间紧密高效的联系，JavaScript是必不可少的工具。&lt;/p&gt;

&lt;h3 id=&#34;广泛的使用领域:5fa5b894c99827b58a1ff5820173afba&#34;&gt;广泛的使用领域&lt;/h3&gt;

&lt;p&gt;近年来，JavaScript的使用范围，慢慢超越了浏览器，正在向通用的系统语言发展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）浏览器的平台化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;随着HTML 5的出现，浏览器本身的功能越来越强，不再仅仅能浏览网页，而是越来越像一个平台，JavaScript因此得以调用许多系统功能，比如操作本地文件、操作图片、调用摄像头和麦克风等等。这使得JavaScript可以完成许多以前无法想象的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）Node.js&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Node.js项目使得JavaScript可以用于开发服务器端的大型项目，网站的前后端都用JavaScript开发已经成为了现实。有些嵌入式平台（Raspberry Pi）能够安装Node.js，于是JavaScript就能为这些平台开发应用程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）数据库操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript甚至也可以用来操作数据库。NoSQL数据库这个概念，本身就是在JSON（JavaScript Object Notation，JavaScript对象表示法）格式的基础上诞生的，大部分NoSQL数据库允许JavaScript直接操作。基于SQL语言的开源数据库PostgreSQL支持JavaScript作为操作语言，可以部分取代SQL查询语言。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）跨移动平台&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript也正在成为手机应用的开发语言。一般来说，安卓平台使用Java语言开发，iOS平台使用Objective-C或Swift语言开发。许多人正在努力，让JavaScript成为各个平台的通用开发语言。&lt;/p&gt;

&lt;p&gt;PhoneGap项目就是将JavaScript和HTML5打包在一个容器之中，使得它能同时在iOS和安卓上运行。Facebook的React Native项目则是将JavaScript写的组件，编译成原生组件，从而使它们具备优秀的性能。&lt;/p&gt;

&lt;p&gt;Mozilla基金会的手机操作系统Firefox OS，更是直接将JavaScript作为操作系统的平台语言。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）内嵌脚本语言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;越来越多的应用程序，将JavaScript作为内嵌的脚本语言，比如Adobe公司的著名PDF阅读器Acrobat、Linux桌面环境GNOME 3。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）跨平台的桌面应用程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Chromium OS、Windows 8等操作系统直接支持JavaScript编写应用程序。Mozilla的Open Web Apps项目、Google的&lt;a href=&#34;http://developer.chrome.com/apps/about_apps&#34;&gt;Chrome App项目&lt;/a&gt;、Github的&lt;a href=&#34;http://electron.atom.io/&#34;&gt;Electron项目&lt;/a&gt;、以及&lt;a href=&#34;http://www.tidesdk.org/&#34;&gt;TideSDK项目&lt;/a&gt;，都可以用来编写运行于Windows、Mac OS和Android等多个桌面平台的程序，不依赖浏览器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（7）小结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以预期，JavaScript最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序。根据2013年9月的&lt;a href=&#34;http://adambard.com/blog/top-github-languages-for-2013-so-far/&#34;&gt;统计&lt;/a&gt;，JavaScript是本年度代码托管网站Github上使用量排名第一的语言。&lt;/p&gt;

&lt;p&gt;著名程序员Jeff Atwood甚至提出了一条&lt;a href=&#34;http://www.codinghorror.com/blog/2007/07/the-principle-of-least-power.html&#34;&gt;“Atwood定律”&lt;/a&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“所有可以用JavaScript编写的程序，最终都会出现JavaScript的版本。”(Any application that can be written in JavaScript will eventually be written in JavaScript.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;易学性:5fa5b894c99827b58a1ff5820173afba&#34;&gt;易学性&lt;/h3&gt;

&lt;p&gt;相比学习其他语言，学习JavaScript有一些有利条件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）学习环境无处不在&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只要有浏览器，就能运行JavaScript程序；只要有文本编辑器，就能编写JavaScript程序。这意味着，几乎所有电脑都原生提供JavaScript学习环境，不用另行安装复杂的IDE（集成开发环境）和编译器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）简单性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相比其他脚本语言（比如Python或Ruby），JavaScript的语法相对简单一些，本身的语法特性并不是特别多。而且，那些语法中的复杂部分，也不是必需要学会。你完全可以只用简单命令，完成大部分的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）与主流语言的相似性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript的语法很类似C/C++和Java，如果学过这些语言（事实上大多数学校都教），JavaScript的入门会非常容易。&lt;/p&gt;

&lt;p&gt;必须说明的是，虽然核心语法不难，但是JavaScript的复杂性体现在另外两个方面。&lt;/p&gt;

&lt;p&gt;首先，它涉及大量的外部API。JavaScript要发挥作用，必须与其他组件配合，这些外部组件五花八门，数量极其庞大，几乎涉及网络应用的各个方面，掌握它们绝非易事。&lt;/p&gt;

&lt;p&gt;其次，JavaScript语言有一些设计缺陷。某些地方相当不合理，另一些地方则会出现怪异的运行结果。学习JavaScript，很大一部分时间是用来搞清楚哪些地方有陷阱。Douglas Crockford写过一本有名的书，名字就叫&lt;a href=&#34;http://javascript.crockford.com/&#34;&gt;《JavaScript: The Good Parts》&lt;/a&gt;，言下之意就是这门语言不好的地方很多，必须写一本书才能讲清楚。另外一些程序员则感到，为了更合理地编写JavaScript程序，就不能用JavaScript来写，而必须发明新的语言，比如CoffeeScript、TypeScript、Dart这些新语言的发明目的，多多少少都有这个因素。&lt;/p&gt;

&lt;p&gt;尽管如此，目前看来，JavaScript的地位还是无法动摇。加之，语言标准的快速进化，使得JavaScript功能日益增强，而语法缺陷和怪异之处得到了弥补。所以，JavaScript还是值得学习，况且它的入门真的不难。&lt;/p&gt;

&lt;h3 id=&#34;强大的性能:5fa5b894c99827b58a1ff5820173afba&#34;&gt;强大的性能&lt;/h3&gt;

&lt;p&gt;JavaScript的性能优势体现在以下方面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）灵活的语法，表达力强。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript既支持类似C语言清晰的过程式编程，也支持灵活的函数式编程。可以用来写并发处理（concurrent）。这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用非同步编程。&lt;/p&gt;

&lt;p&gt;JavaScript的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义。&lt;/p&gt;

&lt;p&gt;JavaScript的标准还在快速进化中，并不断合理化，并添加更适用的语法特性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）支持编译运行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript语言本身，虽然是一种解释型语言，但是在现代浏览器中，JavaScript都是编译后运行。程序会被高度优化，运行效率接近二进制程序。而且，JavaScript引擎正在快速发展，性能将越来越好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）事件驱动和非阻塞式设计。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量。&lt;/p&gt;

&lt;h3 id=&#34;开放性:5fa5b894c99827b58a1ff5820173afba&#34;&gt;开放性&lt;/h3&gt;

&lt;p&gt;JavaScript是一种开放的语言。它的标准是国际标准，写得非常详尽明确；主要的设计和实现都是开放的，而且质量很高；不属于任何公司或个人，不存在版权和专利的问题。&lt;/p&gt;

&lt;p&gt;行业内的主要公司都支持它，单单是解释器就有好几个品种，兼容性很好，不做调整或只做很小的调整，它编写的程序就能在所有浏览器上运行。&lt;/p&gt;

&lt;h3 id=&#34;社区支持和就业机会:5fa5b894c99827b58a1ff5820173afba&#34;&gt;社区支持和就业机会&lt;/h3&gt;

&lt;p&gt;全世界程序员都在使用JavaScript，它有着极大的社区、广泛的文献和图书、丰富的代码资源。绝大部分你需要用到的功能，都有多个开源函数库可供选用。&lt;/p&gt;

&lt;p&gt;作为项目负责人，你不难招聘到数量众多的JavaScript程序员；作为开发者，你也不难找到一份JavaScript的工作。&lt;/p&gt;

&lt;h2 id=&#34;实验环境:5fa5b894c99827b58a1ff5820173afba&#34;&gt;实验环境&lt;/h2&gt;

&lt;p&gt;JavaScript的上手非常方便，只要电脑安装了浏览器，就可以用来实验了。只要打开Chrome浏览器的“开发者工具”（Developer Tools），就可以在它的“控制台”（console）运行JavaScript代码。&lt;/p&gt;

&lt;p&gt;进入“控制台”，有两种方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快捷键。在Chrome浏览器中，直接按&lt;code&gt;Option + Command + J&lt;/code&gt;（Mac）或者&lt;code&gt;Ctrl + Shift + J&lt;/code&gt;（Windows/Linux）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;菜单。从“工具”（Tools）菜单中打开“开发者工具”，然后点击Console选项卡。“开发者工具”的快捷键是F12，或者&lt;code&gt;Option + Command + I&lt;/code&gt;（Mac）以及&lt;code&gt;Ctrl + Shift + I&lt;/code&gt;（Windows/Linux）。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;进入控制台以后，就可以在提示符后输入代码，然后按&lt;code&gt;Enter&lt;/code&gt;键，代码就会执行。如果按&lt;code&gt;Shift + Enter&lt;/code&gt;键，就是代码换行，不会触发执行。建议阅读本教程时，将代码复制到控制台进行实验。&lt;/p&gt;

&lt;p&gt;将下面的程序复制到“控制台”，按下回车后，就可以看到运行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function greetMe(yourName) {
  console.log(&#39;Hello &#39; + yourName);
}

greetMe(&#39;World&#39;)
// Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自序:5fa5b894c99827b58a1ff5820173afba&#34;&gt;自序&lt;/h2&gt;

&lt;p&gt;我想写这本教程，主要原因是自己需要。&lt;/p&gt;

&lt;p&gt;编程时，往往需要查阅资料，确定准确用法。理想的JavaScript参考书，应该简明易懂，一目了然，告诉我有哪些注意点，提供代码范例。涉及重要概念，还应该适当讲解。可是大多数时候，现实都不是如此。找到的资料冗长难懂，抓不住重点，有时还很陈旧，跟不上语言标准和浏览器的快速发展，且大多数是英文资料。&lt;/p&gt;

&lt;p&gt;学习过程中，我做了很多JavaScript笔记。多年累积，数量相当庞大。遇到问题，我首先查自己的笔记，如果笔记里没有，再到网上查，最后回过头把笔记补全。终于有一天，我意识到可以把笔记做成书，这就是这本教程的由来。&lt;/p&gt;

&lt;p&gt;我是为自己写这本书的，我想用自己的语言叙述JavaScript，按照自己的方式编排章节，便于将来的查阅。当然，另一个写作动力是觉得这些内容对他人有用，毕竟我花了那么多时间，整理成书可以节省其他人的时间。&lt;/p&gt;

&lt;p&gt;正因为脱胎于笔记，这本教程跟其他JavaScript书籍有所不同。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;它有点像教程，包含重要概念的简洁讲解，努力把复杂的问题讲得简单，希望一两分钟内就能抓住重点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它又有点像参考手册，罗列主要用法和各种API接口，并给出可以立即运行的代码。所有章节按主题编排，不完全按照由浅入深的学习顺序编排，这是为了方便查阅。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;它主要关注编程实战遇到的问题，从语言本身到浏览器接口都涉及，容易出错的一些细节尤其讲得多。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;许可证:5fa5b894c99827b58a1ff5820173afba&#34;&gt;许可证&lt;/h2&gt;

&lt;p&gt;本教程采用创意共享&lt;a href=&#34;http://javascript.ruanyifeng.com/introduction/license.html&#34;&gt;“署名—非商业性使用”&lt;/a&gt;许可证（Creative Commons Attribution-NonCommercial license）。所有内容不仅可以免费阅读，还可以自由使用（比如转载），只需遵守两个条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;署名&lt;/strong&gt;：必须保留原作者的署名。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;非商业性使用&lt;/strong&gt;：除非得到正式许可，否则不得用于商业目的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;事实上，你还可以得到这本教程的源码。它就放在&lt;a href=&#34;https://github.com/ruanyf/jstutorial&#34;&gt;Github&lt;/a&gt;上，欢迎克隆和提交Pull Request。&lt;/p&gt;

&lt;h2 id=&#34;参考书目:5fa5b894c99827b58a1ff5820173afba&#34;&gt;参考书目&lt;/h2&gt;

&lt;p&gt;写作过程中，我参考了以下书籍（排名不分先后）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nicholas C. Zakas, &lt;a href=&#34;http://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/dp/1118026691&#34;&gt;Professional JavaScript for Web Developers&lt;/a&gt;, 3 edition, Wrox, 2012&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://oreilly.com/javascript/radarreports/past-present-future-javascript.html&#34;&gt;The Past, Present, and Future of JavaScript&lt;/a&gt;, O&amp;rsquo;Reilly, 2012&lt;/li&gt;
&lt;li&gt;Cody Lindley, &lt;a href=&#34;http://www.javascriptenlightenment.com/&#34;&gt;JavaScript Enlightenment&lt;/a&gt;, O&amp;rsquo;Reilly, 2012&lt;/li&gt;
&lt;li&gt;Cody Lindley, &lt;a href=&#34;http://domenlightenment.com/&#34;&gt;DOM Enlightenment&lt;/a&gt;, O&amp;rsquo;Reilly, 2013&lt;/li&gt;
&lt;li&gt;Rebecca Murphey, &lt;a href=&#34;http://github.com/rmurphey/jqfundamentals&#34;&gt;jQuery Fundamentals&lt;/a&gt;, 2011&lt;/li&gt;
&lt;li&gt;Aaron Frost, &lt;a href=&#34;http://chimera.labs.oreilly.com/books/1234000001623&#34;&gt;JS.next: A Manager’s Guide&lt;/a&gt;, O&amp;rsquo;Reilly, 2013&lt;/li&gt;

&lt;li&gt;&lt;p&gt;John Resig, Bear Bibeault, &lt;a href=&#34;http://www.manning.com/resig/&#34;&gt;Secrets of the JavaScript Ninja&lt;/a&gt;, Manning, 2012&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Eric Elliott, &lt;a href=&#34;http://chimera.labs.oreilly.com/books/1234000000262&#34;&gt;Programming JavaScript Applications&lt;/a&gt;, O&amp;rsquo;Reilly, 2013&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;邱俊涛, &lt;a href=&#34;http://icodeit.org/jsccp/&#34;&gt;JavaScript核心概念及实践&lt;/a&gt;，人民邮电出版社，2013&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2、基本语法</title>
      <link>http://575087694.github.io/post/index2/</link>
      <pubDate>Thu, 30 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index2/</guid>
      <description>

&lt;h2 id=&#34;基本句法和变量:626f7feab1401c700a6b07a1e657ae13&#34;&gt;基本句法和变量&lt;/h2&gt;

&lt;h3 id=&#34;语句:626f7feab1401c700a6b07a1e657ae13&#34;&gt;语句&lt;/h3&gt;

&lt;p&gt;JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/p&gt;

&lt;p&gt;语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 1 + 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条语句先用var命令，声明了变量&lt;code&gt;a&lt;/code&gt;，然后将&lt;code&gt;1 + 3&lt;/code&gt;的运算结果赋值给变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt;叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。&lt;/p&gt;

&lt;p&gt;凡是JavaScript语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。一条语句可以包含多个表达式。&lt;/p&gt;

&lt;p&gt;语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 1 + 3 ; var b = &#39;abc&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分号前面可以没有任何内容，JavaScript引擎将其视为空语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;;;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码就表示3个空语句。（关于分号的更多介绍，请看后文《结尾的分号》一节。）&lt;/p&gt;

&lt;p&gt;表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1 + 3;
&#39;abc&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两行语句有返回值，但是没有任何意义，因为只是返回一个单纯的值，没有任何其他操作。&lt;/p&gt;

&lt;h3 id=&#34;变量:626f7feab1401c700a6b07a1e657ae13&#34;&gt;变量&lt;/h3&gt;

&lt;p&gt;变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码先声明变量&lt;code&gt;a&lt;/code&gt;，然后在变量&lt;code&gt;a&lt;/code&gt;与数值1之间建立引用关系，也称为将数值1“赋值”给变量&lt;code&gt;a&lt;/code&gt;。以后，引用变量&lt;code&gt;a&lt;/code&gt;就会得到数值1。最前面的&lt;code&gt;var&lt;/code&gt;，是变量声明命令。它表示通知解释引擎，要创建一个变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;变量的声明和赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a;
a = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只是声明变量而没有赋值，则该变量的值是不存在的，JavaScript使用&lt;code&gt;undefined&lt;/code&gt;表示这种情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a;
a // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript允许在变量赋值的同时，省略&lt;code&gt;var&lt;/code&gt;命令声明变量。也就是说，&lt;code&gt;var a = 1&lt;/code&gt;与&lt;code&gt;a = 1&lt;/code&gt;，这两条语句的效果相同。但是由于这样的做法很容易不知不觉地创建全局变量（尤其是在函数内部），所以建议总是使用&lt;code&gt;var&lt;/code&gt;命令声明变量。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;严格地说，&lt;code&gt;var a = 1&lt;/code&gt; 与 &lt;code&gt;a = 1&lt;/code&gt;，这两条语句的效果不完全一样，主要体现在&lt;code&gt;delete&lt;/code&gt;命令无法删除前者。不过，绝大多数情况下，这种差异是可以忽略的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果一个变量没有声明就直接使用，JavaScript会报错，告诉你变量未定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;x
// ReferenceError: x is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码直接使用变量&lt;code&gt;x&lt;/code&gt;，系统就报错，告诉你变量&lt;code&gt;x&lt;/code&gt;没有声明。&lt;/p&gt;

&lt;p&gt;可以在同一条&lt;code&gt;var&lt;/code&gt;命令中声明多个变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a, b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScirpt是一种动态类型语言，也就是说，变量的类型没有限制，可以赋予各种类型的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = 1;
a = &#39;hello&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，变量&lt;code&gt;a&lt;/code&gt;起先被赋值为一个数值，后来又被重新赋值为一个字符串。第二次赋值的时候，因为变量&lt;code&gt;a&lt;/code&gt;已经存在，所以不需要使用&lt;code&gt;var&lt;/code&gt;命令。&lt;/p&gt;

&lt;p&gt;如果使用&lt;code&gt;var&lt;/code&gt;重新声明一个已经存在的变量，是无效的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;
var x;
x // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，变量&lt;code&gt;x&lt;/code&gt;声明了两次，第二次声明是无效的。&lt;/p&gt;

&lt;p&gt;但是，如果第二次声明的同时还赋值了，则会覆盖掉前面的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;
var x = 2;

// 等同于

var x = 1;
var x;
x = 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;变量提升:626f7feab1401c700a6b07a1e657ae13&#34;&gt;变量提升&lt;/h3&gt;

&lt;p&gt;JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(a);
var a = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码首先使用&lt;code&gt;console.log&lt;/code&gt;方法，在控制台（console）显示变量a的值。这时变量&lt;code&gt;a&lt;/code&gt;还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a;
console.log(a);
a = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的结果是显示&lt;code&gt;undefined&lt;/code&gt;，表示变量&lt;code&gt;a&lt;/code&gt;已声明，但还未赋值。&lt;/p&gt;

&lt;p&gt;请注意，变量提升只对&lt;code&gt;var&lt;/code&gt;命令声明的变量有效，如果一个变量不是用&lt;code&gt;var&lt;/code&gt;命令声明的，就不会发生变量提升。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(b);
b = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的语句将会报错，提示“ReferenceError: b is not defined”，即变量&lt;code&gt;b&lt;/code&gt;未声明，这是因为&lt;code&gt;b&lt;/code&gt;不是用&lt;code&gt;var&lt;/code&gt;命令声明的，JavaScript引擎不会将其提升，而只是视为对顶层对象的&lt;code&gt;b&lt;/code&gt;属性的赋值。&lt;/p&gt;

&lt;h3 id=&#34;标识符:626f7feab1401c700a6b07a1e657ae13&#34;&gt;标识符&lt;/h3&gt;

&lt;p&gt;标识符（identifier）是用来识别具体对象的一个名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript语言的标识符对大小写敏感，所以&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;A&lt;/code&gt;是两个不同的标识符。&lt;/p&gt;

&lt;p&gt;标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript引擎遇到非法标识符，就会报错。&lt;/p&gt;

&lt;p&gt;简单说，标识符命名规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个字符，可以是任意Unicode字母，以及美元符号（&lt;code&gt;$&lt;/code&gt;）和下划线（&lt;code&gt;_&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字&lt;code&gt;0-9&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这些都是合法的标识符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;arg0
_tmp
$elem
π
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这些则是不合法的标识符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;1a  // 第一个字符不能是数字
23  // 同上
***  // 标识符不能包含星号
a+b  // 标识符不能包含加号
-d  // 标识符不能包含减号或连词线
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中文是合法的标识符，可以用作变量名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var 临时变量 = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;JavaScript有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外，还有三个词虽然不是保留字，但是因为具有特别含义，也不应该用作标识符：&lt;code&gt;Infinity&lt;/code&gt;、&lt;code&gt;NaN&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;注释:626f7feab1401c700a6b07a1e657ae13&#34;&gt;注释&lt;/h3&gt;

&lt;p&gt;源码中被JavaScript引擎忽略的部分就叫做注释，它的作用是对代码进行解释。Javascript提供两种注释：一种是单行注释，用//起头；另一种是多行注释，放在/* 和 */之间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这是单行注释

/*
 这是
 多行
 注释
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此外，由于历史上JavaScript兼容HTML代码的注释，所以&amp;lt;!&amp;ndash;和&amp;ndash;&amp;gt;也被视为单行注释。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;x = 1; &amp;lt;!-- x = 2;
--&amp;gt; x = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，只有&lt;code&gt;x = 1&lt;/code&gt;会执行，其他的部分都被注释掉了。&lt;/p&gt;

&lt;p&gt;需要注意的是，&amp;ndash;&amp;gt;只有在行首，才会被当成单行注释，否则就是一个运算符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function countdown(n) {
  while (n --&amp;gt; 0) console.log(n);
}
countdown(3)
// 2
// 1
// 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;n --&amp;gt; 0&lt;/code&gt;实际上会当作&lt;code&gt;n-- &amp;gt; 0&lt;/code&gt;，因此输出2、1、0。&lt;/p&gt;

&lt;h3 id=&#34;区块:626f7feab1401c700a6b07a1e657ae13&#34;&gt;区块&lt;/h3&gt;

&lt;p&gt;JavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。&lt;/p&gt;

&lt;p&gt;与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。也就是说，区块中的变量与区块外的变量，属于同一个作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  var a = 1;
}

a // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在区块内部，声明并赋值了变量&lt;code&gt;a&lt;/code&gt;，然后在区块外部，变量&lt;code&gt;a&lt;/code&gt;依然有效，这说明区块不构成单独的作用域，与不使用区块的情况没有任何区别。所以，单独使用的区块在JavaScript中意义不大，很少出现。区块往往用来构成其他更复杂的语法结构，比如&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;等。&lt;/p&gt;

&lt;h2 id=&#34;条件语句:626f7feab1401c700a6b07a1e657ae13&#34;&gt;条件语句&lt;/h2&gt;

&lt;p&gt;条件语句提供一种语法构造，只有满足某个条件，才会执行相应的语句。JavaScript提供&lt;code&gt;if&lt;/code&gt;结构和&lt;code&gt;switch&lt;/code&gt;结构，完成条件判断。&lt;/p&gt;

&lt;h3 id=&#34;if-结构:626f7feab1401c700a6b07a1e657ae13&#34;&gt;if 结构&lt;/h3&gt;

&lt;p&gt;if结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (expression)
  statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是if结构的基本形式。需要注意的是，expression（表达式）必须放在圆括号中，表示对表达式求值。如果结果为&lt;code&gt;true&lt;/code&gt;，就执行紧跟在后面的语句（statement）；如果结果为&lt;code&gt;false&lt;/code&gt;，则跳过statement的部分。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3)
  m += 1;   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，只有在&lt;code&gt;m&lt;/code&gt;等于3时，才会将其值加上1。&lt;/p&gt;

&lt;p&gt;这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在&lt;code&gt;if&lt;/code&gt;的条件判断之后，加上大括号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  m += 1;   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议总是在&lt;code&gt;if&lt;/code&gt;语句中使用大括号，因为这样方便插入语句。&lt;/p&gt;

&lt;p&gt;注意，&lt;code&gt;if&lt;/code&gt;后面的表达式，不要混淆“赋值表达式”（&lt;code&gt;=&lt;/code&gt;）与“严格相等运算符”（&lt;code&gt;===&lt;/code&gt;）或“相等运算符”（&lt;code&gt;==&lt;/code&gt;）。因为，“赋值表达式”不具有比较作用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;
var y = 2;
if (x = y) {
  console.log(x);
}
// &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的原意是，当&lt;code&gt;x&lt;/code&gt;等于&lt;code&gt;y&lt;/code&gt;的时候，才执行相关语句。但是，不小心将“严格相等运算符”写成“赋值表达式”，结果变成了将&lt;code&gt;y&lt;/code&gt;赋值给&lt;code&gt;x&lt;/code&gt;，然后条件就变成了，判断变量&lt;code&gt;x&lt;/code&gt;的值（等于2）是否为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;至于为什么优先采用“严格相等运算符”，而不是“相等运算符”（&lt;code&gt;==&lt;/code&gt;），请参考《运算符》一节。&lt;/p&gt;

&lt;h3 id=&#34;if-else结构:626f7feab1401c700a6b07a1e657ae13&#34;&gt;if&amp;hellip;else结构&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;if&lt;/code&gt;代码块后面，还可以跟一个&lt;code&gt;else&lt;/code&gt;代码块，表示不满足条件时，所要执行的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 3) {
  // then
} else {
  // else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码判断变量&lt;code&gt;m&lt;/code&gt;是否等于3，如果等于就执行&lt;code&gt;if&lt;/code&gt;代码块，否则执行&lt;code&gt;else&lt;/code&gt;代码块。&lt;/p&gt;

&lt;p&gt;对同一个变量进行多次判断时，多个&lt;code&gt;if...else&lt;/code&gt;语句可以连写在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m === 0) {
  // ...
} else if (m === 1) {
  // ...
} else if (m === 2) {
  // ...
} else {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;else&lt;/code&gt;代码块总是跟随离自己最近的那个&lt;code&gt;if&lt;/code&gt;语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var m = 1;
var n = 2;

if (m !== 1)
if (n === 2) console.log(&#39;hello&#39;);
else console.log(&#39;world&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码不会有任何输出，&lt;code&gt;else&lt;/code&gt;代码块不会得到执行，因为它跟着的是最近的那个&lt;code&gt;if&lt;/code&gt;语句，相当于下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);   
  } else {
    console.log(&#39;world&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想让&lt;code&gt;else&lt;/code&gt;代码块跟随最上面的那个&lt;code&gt;if&lt;/code&gt;语句，就要改变大括号的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (m !== 1) {
  if (n === 2) {
    console.log(&#39;hello&#39;);   
  }
} else {
  console.log(&#39;world&#39;);
}
// world
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;switch结构:626f7feab1401c700a6b07a1e657ae13&#34;&gt;switch结构&lt;/h3&gt;

&lt;p&gt;多个&lt;code&gt;if...else&lt;/code&gt;连在一起使用的时候，可以转为使用更方便的&lt;code&gt;switch&lt;/code&gt;结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;switch (fruit) {
  case &amp;quot;banana&amp;quot;:
    // ...
    break;
  case &amp;quot;apple&amp;quot;:
    // ...
    break;
  default:
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码根据变量&lt;code&gt;fruit&lt;/code&gt;的值，选择执行相应的&lt;code&gt;case&lt;/code&gt;。如果所有&lt;code&gt;case&lt;/code&gt;都不符合，则执行最后的&lt;code&gt;default&lt;/code&gt;部分。需要注意的是，每个&lt;code&gt;case&lt;/code&gt;代码块内部的&lt;code&gt;break&lt;/code&gt;语句不能少，否则会接下去执行下一个&lt;code&gt;case&lt;/code&gt;代码块，而不是跳出&lt;code&gt;switch&lt;/code&gt;结构。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;

switch (x) {
  case 1:
    console.log(&#39;x等于1&#39;);
  case 2:
    console.log(&#39;x等于2&#39;);
  default:
    console.log(&#39;x等于其他值&#39;);
}
// x等于1
// x等于2
// x等于其他值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;case&lt;/code&gt;代码块之中没有&lt;code&gt;break&lt;/code&gt;语句，导致不会跳出&lt;code&gt;switch&lt;/code&gt;结构，而会一直执行下去。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句部分和&lt;code&gt;case&lt;/code&gt;语句部分，都可以使用表达式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;switch(1 + 3) {
  case 2 + 2:
    f();
    break;
  default:
    neverhappens();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的&lt;code&gt;default&lt;/code&gt;部分，是永远不会执行到的。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;switch&lt;/code&gt;语句后面的表达式与&lt;code&gt;case&lt;/code&gt;语句后面的表示式，在比较运行结果时，采用的是严格相等运算符（&lt;code&gt;===&lt;/code&gt;），而不是相等运算符（&lt;code&gt;==&lt;/code&gt;），这意味着比较时不会发生类型转换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 1;

switch (x) {
  case true:
    console.log(&#39;x发生类型转换&#39;);
  default:
    console.log(&#39;x没有发生类型转换&#39;);
}
// x没有发生类型转换
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，由于变量&lt;code&gt;x&lt;/code&gt;没有发生类型转换，所以不会执行&lt;code&gt;case true&lt;/code&gt;的情况。这表明，&lt;code&gt;switch&lt;/code&gt;语句内部采用的是“严格相等运算符”，详细解释请参考《运算符》一节。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;结构不利于代码重用，往往可以用对象形式重写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function getItemPricing(customer, item) {
  switch(customer.type) {
    case &#39;VIP&#39;:
      return item.price * item.quantity * 0.50;
    case &#39;Preferred&#39;:
      return item.price * item.quantity * 0.75;
    case &#39;Regular&#39;:
    case default:
      return item.price * item.quantity;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码根据不同用户，返回不同的价格。你可以发现，&lt;code&gt;switch&lt;/code&gt;语句包含的三种情况，内部逻辑都是相同的，不同只是折扣率。这启发我们可以用对象属性，重写这个判断。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var pricing = {
  &#39;VIP&#39;: 0.50,
  &#39;Preferred&#39;: 0.75,
  &#39;Regular&#39;: 1.0
};

function getItemPricing(customer, item) {
  if (pricing[customer.type])
    return item.price * item.quantity * pricing[customer.type];
  else
    return item.price * item.quantity * pricing.Regular;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果价格档次再多一些，对象属性写法的简洁优势就更明显了。&lt;/p&gt;

&lt;h2 id=&#34;循环语句:626f7feab1401c700a6b07a1e657ae13&#34;&gt;循环语句&lt;/h2&gt;

&lt;p&gt;循环语句用于重复执行某个操作，它有多种形式。&lt;/p&gt;

&lt;h3 id=&#34;while循环:626f7feab1401c700a6b07a1e657ae13&#34;&gt;while循环&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;While&lt;/code&gt;语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (expression)
  statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;while&lt;/code&gt;语句的循环条件是一个表达式（express），必须放在圆括号中。代码块部分，如果只有一条语句（statement），可以省略大括号，否则就必须加上大括号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (expression) {
  statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是&lt;code&gt;while&lt;/code&gt;语句的一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100) {
  console.log(&#39;i当前为：&#39; + i);
  i++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码将循环100次，直到&lt;code&gt;i&lt;/code&gt;等于100为止。&lt;/p&gt;

&lt;p&gt;下面的例子是一个无限循环，因为条件总是为真。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;while (true) {
  console.log(&amp;quot;Hello, world&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;for循环:626f7feab1401c700a6b07a1e657ae13&#34;&gt;for循环&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;语句是循环命令的另一种形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for(initialize; test; increment)
  statement

// 或者

for(initialize; test; increment) {
  statement
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;语句后面的括号里面，有三个表达式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。&lt;/li&gt;
&lt;li&gt;测试表达式（test）：检查循环条件，只要为真就进行后续操作。&lt;/li&gt;
&lt;li&gt;递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
for (var i = 0; i &amp;lt; x; i++) {
  console.log(i);
}
// 0
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，初始化表达式是&lt;code&gt;var i = 0&lt;/code&gt;，即初始化一个变量&lt;code&gt;i&lt;/code&gt;；测试表达式是&lt;code&gt;i &amp;lt; x&lt;/code&gt;，即只要&lt;code&gt;i&lt;/code&gt;小于&lt;code&gt;x&lt;/code&gt;，就会执行循环；递增表达式是&lt;code&gt;i++&lt;/code&gt;，即每次循环结束后，&lt;code&gt;i&lt;/code&gt;增大1。&lt;/p&gt;

&lt;p&gt;所有&lt;code&gt;for&lt;/code&gt;循环，都可以改写成&lt;code&gt;while&lt;/code&gt;循环。上面的例子改为&lt;code&gt;while&lt;/code&gt;循环，代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
var i = 0;

while (i &amp;lt; x) {
  console.log(i);
  i++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;for&lt;/code&gt;语句的三个部分（initialize，test，increment），可以省略任何一个，也可以全部省略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for ( ; ; ){
  console.log(&#39;Hello World&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码省略了&lt;code&gt;for&lt;/code&gt;语句表达式的三个部分，结果就导致了一个无限循环。&lt;/p&gt;

&lt;h3 id=&#34;do-while循环:626f7feab1401c700a6b07a1e657ae13&#34;&gt;do&amp;hellip;while循环&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;do...while&lt;/code&gt;循环与&lt;code&gt;while&lt;/code&gt;循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;do
  statement
while(expression);

// 或者

do {
  statement
} while(expression);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不管条件是否为真，&lt;code&gt;do..while&lt;/code&gt;循环至少运行一次，这是这种结构最大的特点。另外，&lt;code&gt;while&lt;/code&gt;语句后面的分号不能省略。&lt;/p&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 3;
var i = 0;

do {
  console.log(i);
  i++;
} while(i &amp;lt; x);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;break语句和continue语句:626f7feab1401c700a6b07a1e657ae13&#34;&gt;break语句和continue语句&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句用于跳出代码块或循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while(i &amp;lt; 100) {
  console.log(&#39;i当前为：&#39; + i);
  i++;
  if (i === 10) break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只会执行10次循环，一旦&lt;code&gt;i&lt;/code&gt;等于10，就会跳出循环。&lt;/p&gt;

&lt;p&gt;continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i = 0;

while (i &amp;lt; 100){
  i++;
  if (i%2 === 0) continue;
  console.log(&#39;i当前为：&#39; + i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只有在&lt;code&gt;i&lt;/code&gt;为奇数时，才会输出&lt;code&gt;i&lt;/code&gt;的值。如果&lt;code&gt;i&lt;/code&gt;为偶数，则直接进入下一轮循环。&lt;/p&gt;

&lt;p&gt;如果存在多重循环，不带参数的&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句都只针对最内层循环。&lt;/p&gt;

&lt;h3 id=&#34;标签-label:626f7feab1401c700a6b07a1e657ae13&#34;&gt;标签（label）&lt;/h3&gt;

&lt;p&gt;JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;label:
  statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句。&lt;/p&gt;

&lt;p&gt;标签通常与&lt;code&gt;break&lt;/code&gt;语句和&lt;code&gt;continue&lt;/code&gt;语句配合使用，跳出特定的循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为一个双重循环区块，&lt;code&gt;break&lt;/code&gt;命令后面加上了&lt;code&gt;top&lt;/code&gt;标签（注意，&lt;code&gt;top&lt;/code&gt;不用加引号），满足条件时，直接跳出双层循环。如果&lt;code&gt;break&lt;/code&gt;语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句也可以与标签配合使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
// i=2, j=0
// i=2, j=1
// i=2, j=2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;continue&lt;/code&gt;命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果&lt;code&gt;continue&lt;/code&gt;语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p&gt;

&lt;h2 id=&#34;数据类型:626f7feab1401c700a6b07a1e657ae13&#34;&gt;数据类型&lt;/h2&gt;

&lt;h3 id=&#34;概述:626f7feab1401c700a6b07a1e657ae13&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;JavaScript语言的每一个值，都属于某一种数据类型。JavaScript的数据类型，共有六种。（ES6又新增了第七种Symbol类型的值，本教程不涉及。）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数值（number）：整数和小数（比如1和3.14）&lt;/li&gt;
&lt;li&gt;字符串（string）：字符组成的文本（比如&amp;rdquo;Hello World&amp;rdquo;）&lt;/li&gt;
&lt;li&gt;布尔值（boolean）：&lt;code&gt;true&lt;/code&gt;（真）和&lt;code&gt;false&lt;/code&gt;（假）两个特定值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;：表示“未定义”或不存在，即此处目前没有任何值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;：表示空缺，即此处应该有一个值，但目前为空&lt;/li&gt;
&lt;li&gt;对象（object）：各种值组成的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;，一般将它们看成两个特殊值。&lt;/p&gt;

&lt;p&gt;对象又可以分成三个子类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;狭义的对象（object）&lt;/li&gt;
&lt;li&gt;数组（array）&lt;/li&gt;
&lt;li&gt;函数（function）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。JavaScript把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了JavaScript作为“函数式语言”的本质。&lt;/p&gt;

&lt;p&gt;这里需要明确的是，JavaScript的所有数据，都可以视为广义的对象。不仅数组和函数属于对象，就连原始类型的数据（数值、字符串、布尔值）也可以用对象方式调用。为了避免混淆，此后除非特别声明，本教程的”对象“都特指狭义的对象。&lt;/p&gt;

&lt;p&gt;本教程将详细介绍所有的数据类型。&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;两个特殊值和布尔类型Boolean比较简单，将在本节介绍，其他类型将各自有单独的一节。&lt;/p&gt;

&lt;h3 id=&#34;typeof运算符:626f7feab1401c700a6b07a1e657ae13&#34;&gt;typeof运算符&lt;/h3&gt;

&lt;p&gt;JavaScript有三种方法，可以确定一个值到底是什么类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typeof&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;运算符和&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法，将在后文相关章节介绍。这里着重介绍&lt;code&gt;typeof&lt;/code&gt;运算符。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;运算符可以返回一个值的数据类型，可能有以下结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）原始类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数值、字符串、布尔值分别返回&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof 123 // &amp;quot;number&amp;quot;
typeof &#39;123&#39; // &amp;quot;string&amp;quot;
typeof false // &amp;quot;boolean&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（2）函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数返回&lt;code&gt;function&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f() {}
typeof f
// &amp;quot;function&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（3）undefined&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;返回&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof undefined
// &amp;quot;undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用这一点，typeof可以用来检查一个没有声明的变量，而不报错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;v
// ReferenceError: v is not defined

typeof v
// &amp;quot;undefined&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际编程中，这个特点通常用在判断语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 错误的写法
if (v) {
  // ...
}
// ReferenceError: v is not defined

// 正确的写法
if (typeof v === &amp;quot;undefined&amp;quot;) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（4）其他&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除此以外，其他情况都返回&lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof window // &amp;quot;object&amp;quot;
typeof {} // &amp;quot;object&amp;quot;
typeof [] // &amp;quot;object&amp;quot;
typeof null // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面代码可以看到，空数组（&lt;code&gt;[]&lt;/code&gt;）的类型也是&lt;code&gt;object&lt;/code&gt;，这表示在JavaScript内部，数组本质上只是一种特殊的对象。&lt;/p&gt;

&lt;p&gt;另外，&lt;code&gt;null&lt;/code&gt;的类型也是&lt;code&gt;object&lt;/code&gt;，这是由于历史原因造成的。1995年JavaScript语言的第一版，所有值都设计成32位，其中最低的3位用来表述数据类型，&lt;code&gt;object&lt;/code&gt;对应的值是&lt;code&gt;000&lt;/code&gt;。当时，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），完全没考虑&lt;code&gt;null&lt;/code&gt;，只把它当作&lt;code&gt;object&lt;/code&gt;的一种特殊值，32位全部为0。这是&lt;code&gt;typeof null&lt;/code&gt;返回&lt;code&gt;object&lt;/code&gt;的根本原因。&lt;/p&gt;

&lt;p&gt;为了兼容以前的代码，后来就没法修改了。这并不是说&lt;code&gt;null&lt;/code&gt;就属于对象，本质上&lt;code&gt;null&lt;/code&gt;是一个类似于&lt;code&gt;undefined&lt;/code&gt;的特殊值。&lt;/p&gt;

&lt;p&gt;既然&lt;code&gt;typeof&lt;/code&gt;对数组（array）和对象（object）的显示结果都是&lt;code&gt;object&lt;/code&gt;，那么怎么区分它们呢？instanceof运算符可以做到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};
var a = [];

o instanceof Array // false
a instanceof Array // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;运算符的详细解释，请见《面向对象编程》一章。&lt;/p&gt;

&lt;h2 id=&#34;null和undefined:626f7feab1401c700a6b07a1e657ae13&#34;&gt;null和undefined&lt;/h2&gt;

&lt;h3 id=&#34;概述-1:626f7feab1401c700a6b07a1e657ae13&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;与&lt;code&gt;undefined&lt;/code&gt;都可以表示“没有”，含义非常相似。将一个变量赋值为&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;，老实说，语法效果几乎没区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = undefined;
// 或者
var a = null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;a&lt;/code&gt;变量分别被赋值为&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;，这两种写法的效果几乎等价。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;if&lt;/code&gt;语句中，它们都会被自动转为&lt;code&gt;false&lt;/code&gt;，相等运算符（&lt;code&gt;==&lt;/code&gt;）甚至直接报告两者相等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (!undefined) {
  console.log(&#39;undefined is false&#39;);
}
// undefined is false

if (!null) {
  console.log(&#39;null is false&#39;);
}
// null is false

undefined == null
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码说明，两者的行为是何等相似！Google公司开发的JavaScript语言的替代品Dart语言，就明确规定只有&lt;code&gt;null&lt;/code&gt;，没有&lt;code&gt;undefined&lt;/code&gt;！&lt;/p&gt;

&lt;p&gt;既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关。&lt;/p&gt;

&lt;p&gt;1995年JavaScript诞生时，最初像Java一样，只设置了&lt;code&gt;null&lt;/code&gt;作为表示&amp;rdquo;无&amp;rdquo;的值。根据C语言的传统，&lt;code&gt;null&lt;/code&gt;被设计成可以自动转为0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Number(null) // 0
5 + null // 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。&lt;/p&gt;

&lt;p&gt;首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型和合成类型两大类，Brendan Eich觉得表示&amp;rdquo;无&amp;rdquo;的值最好不是对象。&lt;/p&gt;

&lt;p&gt;其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果&lt;code&gt;null&lt;/code&gt;自动转为0，很不容易发现错误。&lt;/p&gt;

&lt;p&gt;因此，Brendan Eich又设计了一个&lt;code&gt;undefined&lt;/code&gt;。他是这样区分的：&lt;code&gt;null&lt;/code&gt;是一个表示&amp;rdquo;无&amp;rdquo;的对象，转为数值时为0；&lt;code&gt;undefined&lt;/code&gt;是一个表示&amp;rdquo;无&amp;rdquo;的原始值，转为数值时为&lt;code&gt;NaN&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Number(undefined) // NaN
5 + undefined // NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这样的区分在实践中很快就被证明不可行。目前&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;基本是同义的，只有一些细微的差别。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;的特殊之处在于，JavaScript把它包含在对象类型（object）之中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;typeof null // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，查询&lt;code&gt;null&lt;/code&gt;的类型，JavaScript返回&lt;code&gt;object&lt;/code&gt;（对象）。&lt;/p&gt;

&lt;p&gt;这并不是说null的数据类型就是对象，而是JavaScript早期部署中的一个约定俗成，其实不完全正确，后来再想改已经太晚了，会破坏现存代码，所以一直保留至今。&lt;/p&gt;

&lt;p&gt;注意，JavaScript的标识名区分大小写，所以&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;不同于&lt;code&gt;Undefined&lt;/code&gt;和&lt;code&gt;Null&lt;/code&gt;（或者其他仅仅大小写不同的词形），后者只是普通的变量名。&lt;/p&gt;

&lt;h3 id=&#34;用法和含义:626f7feab1401c700a6b07a1e657ae13&#34;&gt;用法和含义&lt;/h3&gt;

&lt;p&gt;对于&lt;code&gt;null&lt;/code&gt;和&lt;code&gt;undefined&lt;/code&gt;，可以大致可以像下面这样理解。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;表示空值，即该处的值现在为空。典型用法是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为函数的参数，表示该函数的参数是一个没有任何内容的对象。&lt;/li&gt;
&lt;li&gt;作为对象原型链的终点。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;表示不存在值，就是此处目前不存在任何值。典型用法是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量被声明了，但没有赋值时，就等于undefined。&lt;/li&gt;
&lt;li&gt;调用函数时，应该提供的参数没有提供，该参数等于undefined。&lt;/li&gt;
&lt;li&gt;对象没有赋值的属性，该属性的值为undefined。&lt;/li&gt;
&lt;li&gt;函数没有返回值时，默认返回undefined。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var i;
i // undefined

function f(x){console.log(x)}
f() // undefined

var  o = new Object();
o.p // undefined

var x = f();
x // undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;布尔值:626f7feab1401c700a6b07a1e657ae13&#34;&gt;布尔值&lt;/h2&gt;

&lt;p&gt;布尔值代表“真”和“假”两个状态。“真”用关键字&lt;code&gt;true&lt;/code&gt;表示，“假”用关键字&lt;code&gt;false&lt;/code&gt;表示。布尔值只有这两个值。&lt;/p&gt;

&lt;p&gt;下列运算符会返回布尔值：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两元逻辑运算符： &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (And)，&lt;code&gt;||&lt;/code&gt; (Or)&lt;/li&gt;
&lt;li&gt;前置逻辑运算符： &lt;code&gt;!&lt;/code&gt; (Not)&lt;/li&gt;
&lt;li&gt;相等运算符：&lt;code&gt;===&lt;/code&gt;，&lt;code&gt;!==&lt;/code&gt;，&lt;code&gt;==&lt;/code&gt;，&lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较运算符：&lt;code&gt;&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;gt;=&lt;/code&gt;，&lt;code&gt;&amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为&lt;code&gt;false&lt;/code&gt;，其他值都视为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;（空字符串）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;布尔值往往用于程序流程的控制，请看一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (&#39;&#39;) {
  console.log(true);
}
// 没有任何输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的&lt;code&gt;if&lt;/code&gt;命令后面的判断条件，预期应该是一个布尔值，所以JavaScript自动将空字符串，转为布尔值&lt;code&gt;false&lt;/code&gt;，导致程序不会进入代码块，所以没有任何输出。&lt;/p&gt;

&lt;p&gt;需要特别注意的是，空数组（&lt;code&gt;[]&lt;/code&gt;）和空对象（&lt;code&gt;{}&lt;/code&gt;）对应的布尔值，都是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if ([]) {
  console.log(true);
}
// true

if ({}) {
  console.log(true);
}
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多关于数据类型转换的介绍，参见《数据类型转换》一节。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:626f7feab1401c700a6b07a1e657ae13&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2011/10/javascript-overview.html&#34;&gt;A quick overview of JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2011/11/improving-typeof.html&#34;&gt;Improving the JavaScript typeof operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2011/05/semicolon-insertion.html&#34;&gt;Automatic semicolon insertion in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2013/01/categorizing-values.html&#34;&gt;Categorizing values in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rod Vagg, &lt;a href=&#34;http://dailyjs.com/2012/04/19/semicolons/&#34;&gt;JavaScript and Semicolons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3、标准库</title>
      <link>http://575087694.github.io/post/index3/</link>
      <pubDate>Wed, 29 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index3/</guid>
      <description>

&lt;h2 id=&#34;概述:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;JavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o1 = {a:1};
var o2 = new Object(o1);
o1 === o2 // true

new Object(123) instanceof Number
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，通过new Object() 的写法生成新对象，与字面量的写法 o = {} 是等价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与其他构造函数一样，如果要在Object对象上面部署一个方法，有两种做法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）部署在Object对象本身&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，在Object对象上面定义一个print方法，显示其他对象的内容。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.print = function(o){ console.log(o) };&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.print(o)
// Object&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）部署在Object.prototype对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所有构造函数都有一个prototype属性，指向一个原型对象。凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享。（关于prototype属性的详细解释，参见《面向对象编程》一章。）&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.prototype.print = function(){ console.log(this)};&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;o.print() // Object&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码在Object.prototype定义了一个print方法，然后生成一个Object的实例o。o直接继承了Object.prototype的属性和方法，可以在自身调用它们，也就是说，o对象的print方法实质上是调用Object.prototype.print方法。。&lt;/p&gt;

&lt;p&gt;可以看到，尽管上面两种写法的print方法功能相同，但是用法是不一样的，因此必须区分“构造函数的方法”和“实例对象的方法”。&lt;/p&gt;

&lt;h2 id=&#34;object对象的方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object对象的方法&lt;/h2&gt;

&lt;h3 id=&#34;object:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object()&lt;/h3&gt;

&lt;p&gt;Object本身当作工具方法使用时，可以将任意值转为对象。其中，原始类型的值转为对应的包装对象（参见《原始类型的包装对象》一节）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object() // 返回一个空对象
Object(undefined) // 返回一个空对象
Object(null) // 返回一个空对象

Object(1) // 等同于 new Number(1)
Object(&#39;foo&#39;) // 等同于 new String(&#39;foo&#39;)
Object(true) // 等同于 new Boolean(true)

Object([]) // 返回原数组
Object({}) // 返回原对象
Object(function(){}) // 返回原函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示Object函数将各种值，转为对应的对象。&lt;/p&gt;

&lt;p&gt;如果Object函数的参数是一个对象，它总是返回原对象。利用这一点，可以写一个判断变量是否为对象的函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;function isObject(value) {
    return value === Object(value);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-keys-object-getownpropertynames:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.keys()，Object.getOwnPropertyNames()&lt;/h3&gt;

&lt;p&gt;Object.keys方法和Object.getOwnPropertyNames方法很相似，一般用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，Object.keys方法只返回可枚举的属性（关于可枚举性的详细解释见后文），Object.getOwnPropertyNames方法还返回不可枚举的属性名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
    p1: 123,
    p2: 456
};

Object.keys(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]

Object.getOwnPropertyNames(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码表示，对于一般的对象来说，这两个方法返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;];

Object.keys(a)
// [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;]

Object.getOwnPropertyNames(a)
// [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;length&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。&lt;/p&gt;

&lt;p&gt;由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.keys(o).length
Object.getOwnPropertyNames(o).length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，几乎总是使用Object.keys方法，遍历数组的属性。&lt;/p&gt;

&lt;h3 id=&#34;object-observe:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.observe()&lt;/h3&gt;

&lt;p&gt;Object.observe方法用于观察对象属性的变化。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};&lt;/p&gt;

&lt;p&gt;Object.observe(o, function(changes) {
  changes.forEach(function(change) {
    console.log(change.type, change.name, change.oldValue);
  });
});&lt;/p&gt;

&lt;p&gt;o.foo = 1; // add, &amp;lsquo;foo&amp;rsquo;, undefined
o.foo = 2; // update, &amp;lsquo;foo&amp;rsquo;, 1
delete o.foo; // delete, &amp;lsquo;foo&amp;rsquo;, 2&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，通过Object.observe函数，对o对象指定回调函数。一旦o对象的属性出现任何变化，就会调用回调函数，回调函数通过一个参数对象读取o的属性变化的信息。&lt;/p&gt;

&lt;p&gt;该方法非常新，只有Chrome浏览器的最新版本才部署。&lt;/p&gt;

&lt;h3 id=&#34;其他方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;其他方法&lt;/h3&gt;

&lt;p&gt;除了上面提到的方法，Object还有不少其他方法，将在后文逐一详细介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）对象属性模型的相关方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.getOwnPropertyDescriptor()：获取某个属性的attributes对象。&lt;/li&gt;
&lt;li&gt;Object.defineProperty()：通过attributes对象，定义某个属性。&lt;/li&gt;
&lt;li&gt;Object.defineProperties()：通过attributes对象，定义多个属性。&lt;/li&gt;
&lt;li&gt;Object.getOwnPropertyNames()：返回直接定义在某个对象上面的全部属性的名称。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（2）控制对象状态的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.preventExtensions()：防止对象扩展。&lt;/li&gt;
&lt;li&gt;Object.isExtensible()：判断对象是否可扩展。&lt;/li&gt;
&lt;li&gt;Object.seal()：禁止对象配置。&lt;/li&gt;
&lt;li&gt;Object.isSealed()：判断一个对象是否可配置。&lt;/li&gt;
&lt;li&gt;Object.freeze()：冻结一个对象。&lt;/li&gt;
&lt;li&gt;Object.isFrozen()：判断一个对象是否被冻结。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（3）原型链相关方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.create()：生成一个新对象，并该对象的原型。&lt;/li&gt;
&lt;li&gt;Object.getPrototypeOf()：获取对象的Prototype对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;object实例对象的方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object实例对象的方法&lt;/h2&gt;

&lt;p&gt;除了Object对象本身的方法，还有不少方法是部署在Object.prototype对象上的，所有Object的实例对象都继承了这些方法。&lt;/p&gt;

&lt;p&gt;Object实例对象的方法，主要有以下六个。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;valueOf()：返回当前对象对应的值。&lt;/li&gt;
&lt;li&gt;toString()：返回当前对象对应的字符串形式。&lt;/li&gt;
&lt;li&gt;toLocalString()：返回当前对象对应的本地字符串形式。&lt;/li&gt;
&lt;li&gt;hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。&lt;/li&gt;
&lt;li&gt;isPrototypeOf()：判断当前对象是否为另一个对象的原型。&lt;/li&gt;
&lt;li&gt;propertyIsEnumerable()：判断某个属性是否可枚举。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本节介绍前两个方法，其他方法将在后文相关章节介绍。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-valueof:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.prototype.valueOf()&lt;/h3&gt;

&lt;p&gt;valueOf方法的作用是返回一个对象的值，默认情况下返回对象本身。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;o.valueOf() === o // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码比较o的valueOf方法返回值与o本身，两者是一样的。&lt;/p&gt;

&lt;p&gt;valueOf方法的主要用途是，JavaScript自动类型转换时会默认调用这个方法（详见上一章《数据类型转换》一节）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();

1 + o // &amp;quot;1[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码将对象o与数字1相加，这时JavaScript就会默认调用valueOf()方法。所以，如果自定义valueOf方法，就可以得到想要的结果。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();
o.valueOf = function (){return 2;};&lt;/p&gt;

&lt;p&gt;1 + o // 3&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码自定义了o对象的valueOf方法，于是1 + o就得到了3。这种方法就相当于用o.valueOf覆盖Object.prototype.valueOf。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-tostring:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.prototype.toString()&lt;/h3&gt;

&lt;p&gt;toString方法的作用是返回一个对象的字符串形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o1 = new Object();
o1.toString() // &amp;quot;[object Object]&amp;quot;

var o2 = {a:1};
o2.toString() // &amp;quot;[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，对于一个对象调用toString方法，会返回字符串&lt;code&gt;[object Object]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;字符串&lt;code&gt;[object Object]&lt;/code&gt;本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();

o.toString = function (){ return &#39;hello&#39; };

o + &#39; &#39; + &#39;world&#39; // &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，当对象用于字符串加法时，会自动调用toString方法。由于自定义了toString方法，所以返回字符串hello world。&lt;/p&gt;

&lt;p&gt;数组、字符串和函数都分别部署了自己版本的toString方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1,2,3].toString() // &amp;quot;1,2,3&amp;quot;

&#39;123&#39;.toString() // &amp;quot;123&amp;quot;

(function (){return 123}).toString() // &amp;quot;function (){return 123}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tostring-的应用-判断数据类型:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;toString()的应用：判断数据类型&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法的主要用途是返回对象的字符串形式，除此之外，还有一个重要的作用，就是判断一个值的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};
o.toString() // &amp;quot;[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码调用空对象的&lt;code&gt;toString&lt;/code&gt;方法，结果返回一个字符串&lt;code&gt;object Object&lt;/code&gt;，其中第二个&lt;code&gt;Object&lt;/code&gt;表示该值的准确类型。这是一个十分有用的判断数据类型的方法。&lt;/p&gt;

&lt;p&gt;实例对象的&lt;code&gt;toString&lt;/code&gt;方法，实际上是调用&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法。使用&lt;code&gt;call&lt;/code&gt;方法，可以在任意值上调用&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法，从而帮助我们判断这个值的类型。不同数据类型的&lt;code&gt;toString&lt;/code&gt;方法返回值如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数值：返回&lt;code&gt;[object Number]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;字符串：返回&lt;code&gt;[object String]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;布尔值：返回&lt;code&gt;[object Boolean]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;undefined：返回&lt;code&gt;[object Undefined]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;null：返回&lt;code&gt;[object Null]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;数组：返回&lt;code&gt;[object Array]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;arguments对象：返回&lt;code&gt;[object Arguments]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;函数：返回&lt;code&gt;[object Function]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Error对象：返回&lt;code&gt;[object Error]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Date对象：返回&lt;code&gt;[object Date]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;RegExp对象：返回&lt;code&gt;[object RegExp]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;其他对象：返回&lt;code&gt;[object &amp;quot; + 构造函数的名称 + &amp;quot;]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.prototype.toString.call(2) // &amp;quot;[object Number]&amp;quot;
Object.prototype.toString.call(&#39;&#39;) // &amp;quot;[object String]&amp;quot;
Object.prototype.toString.call(true) // &amp;quot;[object Boolean]&amp;quot;
Object.prototype.toString.call(undefined) // &amp;quot;[object Undefined]&amp;quot;
Object.prototype.toString.call(null) // &amp;quot;[object Null]&amp;quot;
Object.prototype.toString.call(Math) // &amp;quot;[object Math]&amp;quot;
Object.prototype.toString.call({}) // &amp;quot;[object Object]&amp;quot;
Object.prototype.toString.call([]) // &amp;quot;[object Array]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以利用这个特性，写出一个比&lt;code&gt;typeof&lt;/code&gt;运算符更准确的类型判断函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};

type({}); // &amp;quot;object&amp;quot;
type([]); // &amp;quot;array&amp;quot;
type(5); // &amp;quot;number&amp;quot;
type(null); // &amp;quot;null&amp;quot;
type(); // &amp;quot;undefined&amp;quot;
type(/abcd/); // &amp;quot;regex&amp;quot;
type(new Date()); // &amp;quot;date&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面这个&lt;code&gt;type&lt;/code&gt;函数的基础上，还可以加上专门判断某种类型数据的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;Null&#39;,
 &#39;Undefined&#39;,
 &#39;Object&#39;,
 &#39;Array&#39;,
 &#39;String&#39;,
 &#39;Number&#39;,
 &#39;Boolean&#39;,
 &#39;Function&#39;,
 &#39;RegExp&#39;,
 &#39;NaN&#39;,
 &#39;Infinite&#39;
].forEach(function (t) {
    type[&#39;is&#39; + t] = function (o) {
        return type(o) === t.toLowerCase();
    };
});

type.isObject({}) // true
type.isNumber(NaN) // true
type.isRegExp(/abc/) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象的属性模型:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;对象的属性模型&lt;/h2&gt;

&lt;p&gt;ECMAScript 5对于对象的属性，提出了一个精确的描述模型。&lt;/p&gt;

&lt;h3 id=&#34;属性的attributes对象-object-getownpropertydescriptor:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;属性的attributes对象，Object.getOwnPropertyDescriptor()&lt;/h3&gt;

&lt;p&gt;在JavaScript内部，每个属性都有一个对应的attributes对象，保存该属性的一些元信息。使用&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;方法，可以读取attributes对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { p: &#39;a&#39; };

Object.getOwnPropertyDescriptor(o, &#39;p&#39;)
// Object { value: &amp;quot;a&amp;quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，使用&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;方法，读取&lt;code&gt;o&lt;/code&gt;对象的&lt;code&gt;p&lt;/code&gt;属性的attributes对象。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;attributes&lt;/code&gt;对象包含如下元信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;：表示该属性的值，默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writable&lt;/code&gt;：表示该属性的值（value）是否可以改变，默认为&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enumerable&lt;/code&gt;： 表示该属性是否可枚举，默认为&lt;code&gt;true&lt;/code&gt;。如果设为&lt;code&gt;false&lt;/code&gt;，会使得某些操作（比如&lt;code&gt;for...in&lt;/code&gt;循环、&lt;code&gt;Object.keys()&lt;/code&gt;）跳过该属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configurable&lt;/code&gt;：表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的attributes对象（value属性除外），也就是说，configurable属性控制了attributes对象的可写性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt;：表示该属性的取值函数（getter），默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;：表示该属性的存值函数（setter），默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;object-defineproperty-object-defineproperties:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.defineProperty()，Object.defineProperties()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法允许通过定义&lt;code&gt;attributes&lt;/code&gt;对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(object, propertyName, attributesObject)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如，新建一个&lt;code&gt;o&lt;/code&gt;对象，并定义它的&lt;code&gt;p&lt;/code&gt;属性，写法如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperty({}, &#39;p&#39;, {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});

o.p
// 123

o.p = 246;
o.p
// 123
// 因为writable为false，所以无法改变该属性的值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;Object.defineProperty&lt;/code&gt;方法和后面的&lt;code&gt;Object.defineProperties&lt;/code&gt;方法，都有性能损耗，会拖慢执行速度，不宜大量使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;的一个用途，是设置动态属性名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(obj, someFunction(), {value: true});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一次性定义或修改多个属性，可以使用&lt;code&gt;Object.defineProperties&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: &#39;abc&#39;, enumerable: true },
  p3: { get: function() { return this.p1+this.p2 },
    enumerable:true,
    configurable:true
  }
});

o.p1 // 123
o.p2 // &amp;quot;abc&amp;quot;
o.p3 // &amp;quot;123abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中的&lt;code&gt;p3&lt;/code&gt;属性，定义了取值函数&lt;code&gt;get&lt;/code&gt;。这时需要注意的是，一旦定义了取值函数&lt;code&gt;get&lt;/code&gt;（或存值函数&lt;code&gt;set&lt;/code&gt;），就不能将&lt;code&gt;writable&lt;/code&gt;设为&lt;code&gt;true&lt;/code&gt;，或者同时定义&lt;code&gt;value&lt;/code&gt;属性，否则会报错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: 123,
  get: function() { return 456; }
});
// TypeError: Invalid property.
// A property cannot both have accessors and be writable or have a value,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码同时定义了&lt;code&gt;get&lt;/code&gt;属性和&lt;code&gt;value&lt;/code&gt;属性，结果就报错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;和&lt;code&gt;Object.defineProperties()&lt;/code&gt;的第三个参数，是一个属性对象。它的&lt;code&gt;writable&lt;/code&gt;、&lt;code&gt;configurable&lt;/code&gt;、&lt;code&gt;enumerable&lt;/code&gt;这三个属性的默认值都为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;writable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，表示对应的属性的值将不得改写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: &amp;quot;bar&amp;quot;
});

o.p // bar

o.p = &#39;foobar&#39;;
o.p // bar

Object.defineProperty(o, &#39;p&#39;, {
  value: &#39;foobar&#39;,
});
// TypeError: Cannot redefine property: p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码由于&lt;code&gt;writable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，导致无法对&lt;code&gt;p&lt;/code&gt;属性重新赋值，但是不会报错（严格模式下会报错）。不过，如果再一次使用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法对&lt;code&gt;value&lt;/code&gt;属性赋值，就会报错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;configurable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，将无法删除该属性，也无法修改&lt;code&gt;attributes&lt;/code&gt;对象（&lt;code&gt;value&lt;/code&gt;属性除外）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: &#39;bar&#39;,
});

delete o.p
o.p // &amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，由于&lt;code&gt;configurable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，导致无法删除某个属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enumerable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，表示对应的属性不会出现在&lt;code&gt;for...in&lt;/code&gt;循环和&lt;code&gt;Object.keys&lt;/code&gt;方法中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  p1: 10,
  p2: 13,
};

Object.defineProperty(o, &#39;p3&#39;, {
  value: 3,
});

for (var i in o) {
  console.log(i, o[i]);
}
// p1 10
// p2 13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;p3&lt;/code&gt;属性是用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法定义的，由于&lt;code&gt;enumerable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，所以不出现在&lt;code&gt;for...in&lt;/code&gt;循环中。&lt;/p&gt;

&lt;h3 id=&#34;可枚举性-enumerable:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;可枚举性（enumerable）&lt;/h3&gt;

&lt;p&gt;可枚举性（enumerable）用来控制所描述的属性，是否将被包括在&lt;code&gt;for...in&lt;/code&gt;循环之中。具体来说，如果一个属性的&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，下面三个操作不会取到该属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for..in&lt;/code&gt;循环&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JSON.stringify&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，&lt;code&gt;enumerable&lt;/code&gt;可以用来设置“秘密”属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {a: 1, b: 2};

o.c = 3;
Object.defineProperty(o, &#39;d&#39;, {
  value: 4,
  enumerable: false
});

o.d
// 4

for( var key in o ) console.log( o[key] );
// 1
// 2
// 3

Object.keys(o)  // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]

JSON.stringify(o // =&amp;gt; &amp;quot;{a:1,b:2,c:3}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;d&lt;/code&gt;属性的&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但还是可以直接获取它的值。&lt;/p&gt;

&lt;p&gt;至于&lt;code&gt;for...in&lt;/code&gt;循环和&lt;code&gt;Object.keys&lt;/code&gt;方法的区别，在于前者包括对象继承自原型对象的属性，而后者只包括对象本身的属性。如果需要获取对象自身的所有属性，不管enumerable的值，可以使用&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;方法，详见下文。&lt;/p&gt;

&lt;p&gt;考虑到&lt;code&gt;JSON.stringify&lt;/code&gt;方法会排除&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;的值，有时可以利用这一点，为对象添加注释信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var car = {
  id: 123,
  color: &#39;red&#39;,
  ownerId: 12
};

var owner = {
  id: 12,
  name: &#39;Jack&#39;
};

Object.defineProperty(car, &#39;ownerInfo&#39;, {value: owner, enumerable: false});
car.ownerInfo // {id: 12, name: &amp;quot;Jack&amp;quot;}

JSON.stringify(car) //  &amp;quot;{&amp;quot;id&amp;quot;: 123,&amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,&amp;quot;ownerId&amp;quot;: 12}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;owner&lt;/code&gt;对象作为注释，加入&lt;code&gt;car&lt;/code&gt;对象。由于&lt;code&gt;ownerInfo&lt;/code&gt;属性不可枚举，所以&lt;code&gt;JSON.stringify&lt;/code&gt;方法最后输出&lt;code&gt;car&lt;/code&gt;对象时，会忽略&lt;code&gt;ownerInfo&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;这提示我们，如果你不愿意某些属性出现在JSON输出之中，可以把它的&lt;code&gt;enumerable&lt;/code&gt;属性设为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;object-getownpropertynames:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.getOwnPropertyNames()&lt;/h3&gt;

&lt;p&gt;Object.getOwnPropertyNames方法返回直接定义在某个对象上面的全部属性的名称，而不管该属性是否可枚举。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperties({}, {
        p1: { value: 1, enumerable: true },
        p2: { value: 2, enumerable: false }
});

Object.getOwnPropertyNames(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说，系统原生的属性（即非用户自定义的属性）都是不可枚举的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 比如，数组实例自带length属性是不可枚举的
Object.keys([]) // []
Object.getOwnPropertyNames([]) // [ &#39;length&#39; ]

// Object.prototype对象的自带属性也都是不可枚举的
Object.keys(Object.prototype) // []
Object.getOwnPropertyNames(Object.prototype)
// [&#39;hasOwnProperty&#39;,
//  &#39;valueOf&#39;,
//  &#39;constructor&#39;,
//  &#39;toLocaleString&#39;,
//  &#39;isPrototypeOf&#39;,
//  &#39;propertyIsEnumerable&#39;,
//  &#39;toString&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码可以看到，数组的实例对象（&lt;code&gt;[]&lt;/code&gt;）没有可枚举属性，不可枚举属性有length；Object.prototype对象也没有可枚举属性，但是有不少不可枚举属性。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-propertyisenumerable:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.prototype.propertyIsEnumerable()&lt;/h3&gt;

&lt;p&gt;对象实例的propertyIsEnumerable方法用来判断一个属性是否可枚举。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};
o.p = 123;&lt;/p&gt;

&lt;p&gt;o.propertyIsEnumerable(&amp;ldquo;p&amp;rdquo;) // true
o.propertyIsEnumerable(&amp;ldquo;toString&amp;rdquo;) // false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，用户自定义的p属性是可枚举的，而继承自原型对象的toString属性是不可枚举的。&lt;/p&gt;

&lt;h3 id=&#34;可配置性-configurable:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;可配置性（configurable）&lt;/h3&gt;

&lt;p&gt;可配置性（configurable）决定了是否可以修改属性的描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: false, 
        enumerable: false, 
        configurable: false
});

Object.defineProperty(o,&#39;p&#39;, {value: 2})
// TypeError: Cannot redefine property: p

Object.defineProperty(o,&#39;p&#39;, {writable: true})
// TypeError: Cannot redefine property: p

Object.defineProperty(o,&#39;p&#39;, {enumerable: true})
// TypeError: Cannot redefine property: p

Object.defineProperties(o,&#39;p&#39;,{configurable: true})
// TypeError: Cannot redefine property: p

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码首先生成对象o，并且定义属性p的configurable为false。然后，逐一改动value、writable、enumerable、configurable，结果都报错。&lt;/p&gt;

&lt;p&gt;需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = Object.defineProperty({}, &#39;p&#39;, {
        writable: true
});

Object.defineProperty(o,&#39;p&#39;, {writable: false})
// 修改成功

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于value，只要writable和configurable有一个为true，就可以改动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o1 = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: true,
        configurable: false
});

Object.defineProperty(o1,&#39;p&#39;, {value: 2})
// 修改成功

var o2 = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: false,
        configurable: true
});

Object.defineProperty(o2,&#39;p&#39;, {value: 2}) 
// 修改成功

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可配置性决定了一个变量是否可以被删除（delete）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = Object.defineProperties({}, {
        p1: { value: 1, configurable: true },
        p2: { value: 2, configurable: false }
});&lt;/p&gt;

&lt;p&gt;delete o.p1 // true
delete o.p2 // false&lt;/p&gt;

&lt;p&gt;o.p1 // undefined
o.p2 // 2&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中的对象o有两个属性，p1是可配置的，p2是不可配置的。结果，p2就无法删除。&lt;/p&gt;

&lt;p&gt;需要注意的是，当使用var命令声明变量时，变量的configurable为false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var a1 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a1&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: false
// }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;而不使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性为true。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;a2 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a2&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: true
// }&lt;/p&gt;

&lt;p&gt;// 或者写成&lt;/p&gt;

&lt;p&gt;this.a3 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a3&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: true
// }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中的&lt;code&gt;this.a3 = 1&lt;/code&gt;与&lt;code&gt;a3 = 1&lt;/code&gt;是等价的写法。this指的是当前的作用域，更多关于this的解释，参见《面向对象编程》一章。&lt;/p&gt;

&lt;p&gt;这种差异意味着，如果一个变量是使用var命令生成的，就无法用delete命令删除。也就是说，delete只能删除对象的属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var a1 = 1;
a2 = 1;&lt;/p&gt;

&lt;p&gt;delete a1 // false
delete a2 // true&lt;/p&gt;

&lt;p&gt;a1 // 1
a2 // ReferenceError: a2 is not defined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;可写性-writable:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;可写性（writable）&lt;/h3&gt;

&lt;p&gt;可写性（writable）决定了属性的值（value）是否可以被改变。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;ldquo;a&amp;rdquo;, { value : 37, writable : false });&lt;/p&gt;

&lt;p&gt;o.a // 37
o.a = 25;
o.a // 37&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码将o对象的a属性可写性设为false，然后改变这个属性的值，就不会有任何效果。&lt;/p&gt;

&lt;p&gt;这实际上将某个属性的值变成了常量。在ES6中，constant命令可以起到这个作用，但在ES5中，只有通过writable达到同样目的。&lt;/p&gt;

&lt;p&gt;这里需要注意的是，当对a属性重新赋值的时候，并不会抛出错误，只是静静地失败。但是，如果在严格模式下，这里就会抛出一个错误，即使是对a属性重新赋予一个同样的值。&lt;/p&gt;

&lt;p&gt;关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var proto = Object.defineProperty({}, &amp;lsquo;foo&amp;rsquo;, {
    value: &amp;lsquo;a&amp;rsquo;,
    writable: false
});&lt;/p&gt;

&lt;p&gt;var o = Object.create(proto);&lt;/p&gt;

&lt;p&gt;o.foo = &amp;lsquo;b&amp;rsquo;;
o.foo // &amp;lsquo;a&amp;rsquo;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，对象proto的foo属性不可写，结果proto的派生对象o，也不可以再自定义这个属性了。在严格模式下，这样做还会抛出一个错误。但是，有一个规避方法，就是通过覆盖attributes对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;lsquo;foo&amp;rsquo;, { value: &amp;lsquo;b&amp;rsquo; });&lt;/p&gt;

&lt;p&gt;o.foo // &amp;lsquo;b&amp;rsquo;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;存取器-accessor:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;存取器（accessor）&lt;/h3&gt;

&lt;p&gt;除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  get p() {
    return &amp;quot;getter&amp;quot;;
  },
  set p(value) {
    console.log(&amp;quot;setter: &amp;quot;+value);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;o.p // &amp;quot;getter&amp;quot;
o.p = 123 // &amp;quot;setter: 123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存取器往往用于，某个属性的值需要依赖对象内部数据的场合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o ={
  $n : 5,
  get next(){return this.$n++ },
  set next(n) {
    if (n &amp;gt;= this.$n) this.$n = n;
    else throw &amp;quot;新的值必须大于当前值&amp;quot;;
  }
};

o.next // 5

o.next = 10;
o.next // 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，next属性的存值函数和取值函数，都依赖于对内部属性$n的操作。&lt;/p&gt;

&lt;p&gt;下面是另一个存取器的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var d = new Date();

Object.defineProperty(d, &#39;month&#39;, {
  get: function() {
    return d.getMonth();
  },
  set: function(v) {
    d.setMonth(v);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为Date的实例对象d，定义了一个可读写的month属性。&lt;/p&gt;

&lt;p&gt;存取器也可以使用Object.create方法定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create(Object.prototype, {
  foo: {
    get: function () {
      return &#39;getter&#39;;
    },
    set: function (value) {
      console.log(&#39;setter: &#39;+value);
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用上面这种写法，属性foo必须定义一个属性描述对象。该对象的get和set属性，分别是foo的取值函数和存值函数。&lt;/p&gt;

&lt;p&gt;利用存取器，可以实现数据对象与DOM对象的双向绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(user, &#39;name&#39;, {
  get: function() {
    return document.getElementById(&amp;quot;foo&amp;quot;).value;
  },
  set: function(newValue) {
    document.getElementById(&amp;quot;foo&amp;quot;).value = newValue;
  },
  configurable: true
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用存取函数，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。&lt;/p&gt;

&lt;h3 id=&#34;对象的拷贝:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;对象的拷贝&lt;/h3&gt;

&lt;p&gt;有时，我们需要将一个对象的所有属性，拷贝到另一个对象。ES5没有提供这个方法，必须自己实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {a: 1})
// {a: 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;extend({}, { get a(){ return 1 } })
// {a: 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了解决这个问题，我们可以通过&lt;code&gt;Object.defineProperty&lt;/code&gt;方法来拷贝属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {
    Object.defineProperty(to, property, Object.getOwnPropertyDescriptor(from, property));
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码还是有问题，拷贝某些属性时会失效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;extend(document.body.style, {
  backgroundColor: &amp;quot;red&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的目的是，设置&lt;code&gt;document.body.style.backgroundColor&lt;/code&gt;属性为&lt;code&gt;red&lt;/code&gt;，但是实际上网页的背景色并不会变红。但是，如果用第一种简单拷贝的方法，反而能够达到目的。这提示我们，可以把两种方法结合起来，对于简单属性，就直接拷贝，对于那些通过描述对象设置的属性，则使用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法拷贝。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {  
    var descriptor = Object.getOwnPropertyDescriptor(from, property);
  
    if (descriptor &amp;amp;&amp;amp; ( !descriptor.writable
      || !descriptor.configurable
      || !descriptor.enumerable
      || descriptor.get
      || descriptor.set)) {
      Object.defineProperty(to, property, descriptor);
    } else {
      to[property] = from[property];
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这段代码，可以很好地拷贝任意属性。&lt;/p&gt;

&lt;h2 id=&#34;控制对象状态:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;控制对象状态&lt;/h2&gt;

&lt;p&gt;JavaScript提供了三种方法，精确控制一个对象的读写状态，防止对象被改变。最弱一层的保护是preventExtensions，其次是seal，最强的freeze。&lt;/p&gt;

&lt;h3 id=&#34;object-preventextensions方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.preventExtensions方法&lt;/h3&gt;

&lt;p&gt;Object.preventExtensions方法可以使得一个对象无法再添加新的属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;ldquo;p&amp;rdquo;, { value: &amp;ldquo;hello&amp;rdquo; });
// TypeError: Cannot define property:p, object is not extensible.&lt;/p&gt;

&lt;p&gt;o.p = 1;
o.p // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;如果是在严格模式下，则会抛出一个错误。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;(function () {
  &amp;lsquo;use strict&amp;rsquo;;
  o.p = &amp;lsquo;1&amp;rsquo;
}());
// TypeError: Can&amp;rsquo;t add property bar, object is not extensible&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;不过，对于使用了preventExtensions方法的对象，可以用delete命令删除它的现有属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();
o.p = 1;&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;delete o.p;
o.p // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-isextensible方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.isExtensible方法&lt;/h3&gt;

&lt;p&gt;Object.isExtensible方法用于检查一个对象是否使用了preventExtensions方法。也就是说，该方法可以用来检查是否可以为一个对象添加属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.isExtensible(o)
// true&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);
Object.isExtensible(o)
// false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码新生成了一个o对象，对该对象使用Object.isExtensible方法，返回true，表示可以添加新属性。对该对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。&lt;/p&gt;

&lt;h3 id=&#34;object-seal方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.seal方法&lt;/h3&gt;

&lt;p&gt;Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p:&amp;ldquo;hello&amp;rdquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);&lt;/p&gt;

&lt;p&gt;delete o.p;
o.p // &amp;ldquo;hello&amp;rdquo;&lt;/p&gt;

&lt;p&gt;o.x = &amp;lsquo;world&amp;rsquo;;
o.x // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Object.seal还把现有属性的attributes对象的configurable属性设为false，使得attributes对象不再能改变。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;// seal方法之前
Object.getOwnPropertyDescriptor(o, &amp;lsquo;p&amp;rsquo;)
// Object {value: &amp;ldquo;a&amp;rdquo;, writable: true, enumerable: true, configurable: true}&lt;/p&gt;

&lt;p&gt;Object.seal(o);&lt;/p&gt;

&lt;p&gt;// seal方法之后
Object.getOwnPropertyDescriptor(o, &amp;lsquo;p&amp;rsquo;)
// Object {value: &amp;ldquo;a&amp;rdquo;, writable: true, enumerable: true, configurable: false}&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;lsquo;p&amp;rsquo;, { enumerable: false })
// TypeError: Cannot redefine property: p&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;从上面代码可以看到，使用seal方法之后，attributes对象的configurable就变成了false，然后如果想改变enumerable就会报错。&lt;/p&gt;

&lt;p&gt;可写性（writable）有点特别。如果writable为false，使用Object.seal方法以后，将无法将其变成true；但是，如果writable为true，依然可以将其变成false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o1 = Object.defineProperty({}, &amp;lsquo;p&amp;rsquo;, {writable: false});
Object.seal(o1);
Object.defineProperty(o1,&amp;lsquo;p&amp;rsquo;,{writable:true})
// Uncaught TypeError: Cannot redefine property: p&lt;/p&gt;

&lt;p&gt;var o2 = Object.defineProperty({}, &amp;lsquo;p&amp;rsquo;, {writable: true});
Object.seal(o2);
Object.defineProperty(o2,&amp;lsquo;p&amp;rsquo;,{writable:false})&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(o2, &amp;lsquo;p&amp;rsquo;)
/* { value: &amp;ldquo;,
  writable: false,
  enumerable: true,
  configurable: false } */&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，同样是使用了Object.seal方法，如果writable原为false，改变这个设置将报错；如果原为true，则不会有问题。&lt;/p&gt;

&lt;p&gt;至于属性对象的value是否可改变，是由writable决定的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = { p: &#39;a&#39; };
Object.seal(o);
o.p = &#39;b&#39;;
o.p // &#39;b&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，Object.seal方法对p属性的value无效，是因为此时p属性的writable为true。&lt;/p&gt;

&lt;h3 id=&#34;object-issealed方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.isSealed方法&lt;/h3&gt;

&lt;p&gt;Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);
Object.isSealed(o) // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;另外，这时isExtensible方法也返回false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);
Object.isExtensible(o) // false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-freeze方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.freeze方法&lt;/h3&gt;

&lt;p&gt;Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);&lt;/p&gt;

&lt;p&gt;o.p = &amp;ldquo;world&amp;rdquo;;
o.p // hello&lt;/p&gt;

&lt;p&gt;o.t = &amp;ldquo;hello&amp;rdquo;;
o.t // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，对现有属性重新赋值（o.p = &amp;ldquo;world&amp;rdquo;）或者添加一个新属性，并不会报错，只是默默地失败。但是，如果是在严格模式下，就会报错。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);&lt;/p&gt;

&lt;p&gt;// 对现有属性重新赋值
(function () { &amp;lsquo;use strict&amp;rsquo;; o.p = &amp;ldquo;world&amp;rdquo;;}())
// TypeError: Cannot assign to read only property &amp;lsquo;p&amp;rsquo; of #&lt;Object&gt;&lt;/p&gt;

&lt;p&gt;// 添加不存在的属性
(function () { &amp;lsquo;use strict&amp;rsquo;; o.t = 123;}())
// TypeError: Can&amp;rsquo;t add property t, object is not extensible&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-isfrozen方法:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;Object.isFrozen方法&lt;/h3&gt;

&lt;p&gt;Object.isFrozen方法用于检查一个对象是否使用了Object.freeze()方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);
Object.isFrozen(o) // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;局限性:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;局限性&lt;/h3&gt;

&lt;p&gt;需要注意的是，使用上面这些方法锁定对象的可写性，但是依然可以通过改变该对象的原型对象，来为它增加属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;var proto = Object.getPrototypeOf(o);&lt;/p&gt;

&lt;p&gt;proto.t = &amp;ldquo;hello&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;o.t
// hello&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;一种解决方案是，把原型也冻结住。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = Object.seal(
  Object.create(Object.freeze({x:1}),
    {y: {value: 2, writable: true}})
);&lt;/p&gt;

&lt;p&gt;Object.getPrototypeOf(o).t = &amp;ldquo;hello&amp;rdquo;;
o.hello // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&#34;参考链接:f9c86b2df35d1125f3dd547b0a3cdbbb&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2013/08/protecting-objects.html&#34;&gt;Protecting objects in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;kangax, &lt;a href=&#34;http://perfectionkills.com/understanding-delete/&#34;&gt;Understanding delete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jon Bretman, &lt;a href=&#34;http://techblog.badoo.com/blog/2013/11/01/type-checking-in-javascript/&#34;&gt;Type Checking in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cody Lindley, &lt;a href=&#34;http://tech.pro/tutorial/1671/thinking-about-ecmascript-5-parts&#34;&gt;Thinking About ECMAScript 5 Parts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bjorn Tipling, &lt;a href=&#34;http://bjorn.tipling.com/advanced-objects-in-javascript&#34;&gt;Advanced objects in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Javier Márquez, &lt;a href=&#34;http://arqex.com/967/javascript-properties-enumerable-writable-configurable&#34;&gt;Javascript properties are enumerable, writable and configurable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sella Rafaeli, &lt;a href=&#34;http://www.sellarafaeli.com/blog/native_javascript_data_binding&#34;&gt;Native JavaScript Data-Binding&lt;/a&gt;: 使用存取函数实现model与view的双向绑定&lt;/li&gt;
&lt;li&gt;Lea Verou, &lt;a href=&#34;http://lea.verou.me/2015/08/copying-properties-the-robust-way/&#34;&gt;Copying object properties, the robust way&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4、面对对象编程</title>
      <link>http://575087694.github.io/post/index4/</link>
      <pubDate>Tue, 28 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index4/</guid>
      <description>

&lt;h2 id=&#34;概述:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;JavaScript原生提供一个Object对象（注意起首的O是大写），所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o1 = {a:1};
var o2 = new Object(o1);
o1 === o2 // true

new Object(123) instanceof Number
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，通过new Object() 的写法生成新对象，与字面量的写法 o = {} 是等价的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;与其他构造函数一样，如果要在Object对象上面部署一个方法，有两种做法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）部署在Object对象本身&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如，在Object对象上面定义一个print方法，显示其他对象的内容。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.print = function(o){ console.log(o) };&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.print(o)
// Object&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）部署在Object.prototype对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所有构造函数都有一个prototype属性，指向一个原型对象。凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享。（关于prototype属性的详细解释，参见《面向对象编程》一章。）&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.prototype.print = function(){ console.log(this)};&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;o.print() // Object&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码在Object.prototype定义了一个print方法，然后生成一个Object的实例o。o直接继承了Object.prototype的属性和方法，可以在自身调用它们，也就是说，o对象的print方法实质上是调用Object.prototype.print方法。。&lt;/p&gt;

&lt;p&gt;可以看到，尽管上面两种写法的print方法功能相同，但是用法是不一样的，因此必须区分“构造函数的方法”和“实例对象的方法”。&lt;/p&gt;

&lt;h2 id=&#34;object对象的方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object对象的方法&lt;/h2&gt;

&lt;h3 id=&#34;object:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object()&lt;/h3&gt;

&lt;p&gt;Object本身当作工具方法使用时，可以将任意值转为对象。其中，原始类型的值转为对应的包装对象（参见《原始类型的包装对象》一节）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object() // 返回一个空对象
Object(undefined) // 返回一个空对象
Object(null) // 返回一个空对象

Object(1) // 等同于 new Number(1)
Object(&#39;foo&#39;) // 等同于 new String(&#39;foo&#39;)
Object(true) // 等同于 new Boolean(true)

Object([]) // 返回原数组
Object({}) // 返回原对象
Object(function(){}) // 返回原函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示Object函数将各种值，转为对应的对象。&lt;/p&gt;

&lt;p&gt;如果Object函数的参数是一个对象，它总是返回原对象。利用这一点，可以写一个判断变量是否为对象的函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;function isObject(value) {
    return value === Object(value);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-keys-object-getownpropertynames:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.keys()，Object.getOwnPropertyNames()&lt;/h3&gt;

&lt;p&gt;Object.keys方法和Object.getOwnPropertyNames方法很相似，一般用来遍历对象的属性。它们的参数都是一个对象，都返回一个数组，该数组的成员都是对象自身的（而不是继承的）所有属性名。它们的区别在于，Object.keys方法只返回可枚举的属性（关于可枚举性的详细解释见后文），Object.getOwnPropertyNames方法还返回不可枚举的属性名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
    p1: 123,
    p2: 456
};

Object.keys(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]

Object.getOwnPropertyNames(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码表示，对于一般的对象来说，这两个方法返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;];

Object.keys(a)
// [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;]

Object.getOwnPropertyNames(a)
// [&amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;length&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，数组的length属性是不可枚举的属性，所以只出现在Object.getOwnPropertyNames方法的返回结果中。&lt;/p&gt;

&lt;p&gt;由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.keys(o).length
Object.getOwnPropertyNames(o).length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，几乎总是使用Object.keys方法，遍历数组的属性。&lt;/p&gt;

&lt;h3 id=&#34;object-observe:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.observe()&lt;/h3&gt;

&lt;p&gt;Object.observe方法用于观察对象属性的变化。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};&lt;/p&gt;

&lt;p&gt;Object.observe(o, function(changes) {
  changes.forEach(function(change) {
    console.log(change.type, change.name, change.oldValue);
  });
});&lt;/p&gt;

&lt;p&gt;o.foo = 1; // add, &amp;lsquo;foo&amp;rsquo;, undefined
o.foo = 2; // update, &amp;lsquo;foo&amp;rsquo;, 1
delete o.foo; // delete, &amp;lsquo;foo&amp;rsquo;, 2&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，通过Object.observe函数，对o对象指定回调函数。一旦o对象的属性出现任何变化，就会调用回调函数，回调函数通过一个参数对象读取o的属性变化的信息。&lt;/p&gt;

&lt;p&gt;该方法非常新，只有Chrome浏览器的最新版本才部署。&lt;/p&gt;

&lt;h3 id=&#34;其他方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;其他方法&lt;/h3&gt;

&lt;p&gt;除了上面提到的方法，Object还有不少其他方法，将在后文逐一详细介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）对象属性模型的相关方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.getOwnPropertyDescriptor()：获取某个属性的attributes对象。&lt;/li&gt;
&lt;li&gt;Object.defineProperty()：通过attributes对象，定义某个属性。&lt;/li&gt;
&lt;li&gt;Object.defineProperties()：通过attributes对象，定义多个属性。&lt;/li&gt;
&lt;li&gt;Object.getOwnPropertyNames()：返回直接定义在某个对象上面的全部属性的名称。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（2）控制对象状态的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.preventExtensions()：防止对象扩展。&lt;/li&gt;
&lt;li&gt;Object.isExtensible()：判断对象是否可扩展。&lt;/li&gt;
&lt;li&gt;Object.seal()：禁止对象配置。&lt;/li&gt;
&lt;li&gt;Object.isSealed()：判断一个对象是否可配置。&lt;/li&gt;
&lt;li&gt;Object.freeze()：冻结一个对象。&lt;/li&gt;
&lt;li&gt;Object.isFrozen()：判断一个对象是否被冻结。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（3）原型链相关方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object.create()：生成一个新对象，并该对象的原型。&lt;/li&gt;
&lt;li&gt;Object.getPrototypeOf()：获取对象的Prototype对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;object实例对象的方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object实例对象的方法&lt;/h2&gt;

&lt;p&gt;除了Object对象本身的方法，还有不少方法是部署在Object.prototype对象上的，所有Object的实例对象都继承了这些方法。&lt;/p&gt;

&lt;p&gt;Object实例对象的方法，主要有以下六个。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;valueOf()：返回当前对象对应的值。&lt;/li&gt;
&lt;li&gt;toString()：返回当前对象对应的字符串形式。&lt;/li&gt;
&lt;li&gt;toLocalString()：返回当前对象对应的本地字符串形式。&lt;/li&gt;
&lt;li&gt;hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。&lt;/li&gt;
&lt;li&gt;isPrototypeOf()：判断当前对象是否为另一个对象的原型。&lt;/li&gt;
&lt;li&gt;propertyIsEnumerable()：判断某个属性是否可枚举。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本节介绍前两个方法，其他方法将在后文相关章节介绍。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-valueof:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.prototype.valueOf()&lt;/h3&gt;

&lt;p&gt;valueOf方法的作用是返回一个对象的值，默认情况下返回对象本身。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;o.valueOf() === o // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码比较o的valueOf方法返回值与o本身，两者是一样的。&lt;/p&gt;

&lt;p&gt;valueOf方法的主要用途是，JavaScript自动类型转换时会默认调用这个方法（详见上一章《数据类型转换》一节）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();

1 + o // &amp;quot;1[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码将对象o与数字1相加，这时JavaScript就会默认调用valueOf()方法。所以，如果自定义valueOf方法，就可以得到想要的结果。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();
o.valueOf = function (){return 2;};&lt;/p&gt;

&lt;p&gt;1 + o // 3&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码自定义了o对象的valueOf方法，于是1 + o就得到了3。这种方法就相当于用o.valueOf覆盖Object.prototype.valueOf。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-tostring:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.prototype.toString()&lt;/h3&gt;

&lt;p&gt;toString方法的作用是返回一个对象的字符串形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o1 = new Object();
o1.toString() // &amp;quot;[object Object]&amp;quot;

var o2 = {a:1};
o2.toString() // &amp;quot;[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，对于一个对象调用toString方法，会返回字符串&lt;code&gt;[object Object]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;字符串&lt;code&gt;[object Object]&lt;/code&gt;本身没有太大的用处，但是通过自定义toString方法，可以让对象在自动类型转换时，得到想要的字符串形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = new Object();

o.toString = function (){ return &#39;hello&#39; };

o + &#39; &#39; + &#39;world&#39; // &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，当对象用于字符串加法时，会自动调用toString方法。由于自定义了toString方法，所以返回字符串hello world。&lt;/p&gt;

&lt;p&gt;数组、字符串和函数都分别部署了自己版本的toString方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1,2,3].toString() // &amp;quot;1,2,3&amp;quot;

&#39;123&#39;.toString() // &amp;quot;123&amp;quot;

(function (){return 123}).toString() // &amp;quot;function (){return 123}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tostring-的应用-判断数据类型:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;toString()的应用：判断数据类型&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;toString&lt;/code&gt;方法的主要用途是返回对象的字符串形式，除此之外，还有一个重要的作用，就是判断一个值的类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};
o.toString() // &amp;quot;[object Object]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码调用空对象的&lt;code&gt;toString&lt;/code&gt;方法，结果返回一个字符串&lt;code&gt;object Object&lt;/code&gt;，其中第二个&lt;code&gt;Object&lt;/code&gt;表示该值的准确类型。这是一个十分有用的判断数据类型的方法。&lt;/p&gt;

&lt;p&gt;实例对象的&lt;code&gt;toString&lt;/code&gt;方法，实际上是调用&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法。使用&lt;code&gt;call&lt;/code&gt;方法，可以在任意值上调用&lt;code&gt;Object.prototype.toString&lt;/code&gt;方法，从而帮助我们判断这个值的类型。不同数据类型的&lt;code&gt;toString&lt;/code&gt;方法返回值如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数值：返回&lt;code&gt;[object Number]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;字符串：返回&lt;code&gt;[object String]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;布尔值：返回&lt;code&gt;[object Boolean]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;undefined：返回&lt;code&gt;[object Undefined]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;null：返回&lt;code&gt;[object Null]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;数组：返回&lt;code&gt;[object Array]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;arguments对象：返回&lt;code&gt;[object Arguments]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;函数：返回&lt;code&gt;[object Function]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Error对象：返回&lt;code&gt;[object Error]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Date对象：返回&lt;code&gt;[object Date]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;RegExp对象：返回&lt;code&gt;[object RegExp]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;其他对象：返回&lt;code&gt;[object &amp;quot; + 构造函数的名称 + &amp;quot;]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.prototype.toString.call(2) // &amp;quot;[object Number]&amp;quot;
Object.prototype.toString.call(&#39;&#39;) // &amp;quot;[object String]&amp;quot;
Object.prototype.toString.call(true) // &amp;quot;[object Boolean]&amp;quot;
Object.prototype.toString.call(undefined) // &amp;quot;[object Undefined]&amp;quot;
Object.prototype.toString.call(null) // &amp;quot;[object Null]&amp;quot;
Object.prototype.toString.call(Math) // &amp;quot;[object Math]&amp;quot;
Object.prototype.toString.call({}) // &amp;quot;[object Object]&amp;quot;
Object.prototype.toString.call([]) // &amp;quot;[object Array]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以利用这个特性，写出一个比&lt;code&gt;typeof&lt;/code&gt;运算符更准确的类型判断函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};

type({}); // &amp;quot;object&amp;quot;
type([]); // &amp;quot;array&amp;quot;
type(5); // &amp;quot;number&amp;quot;
type(null); // &amp;quot;null&amp;quot;
type(); // &amp;quot;undefined&amp;quot;
type(/abcd/); // &amp;quot;regex&amp;quot;
type(new Date()); // &amp;quot;date&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面这个&lt;code&gt;type&lt;/code&gt;函数的基础上，还可以加上专门判断某种类型数据的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;Null&#39;,
 &#39;Undefined&#39;,
 &#39;Object&#39;,
 &#39;Array&#39;,
 &#39;String&#39;,
 &#39;Number&#39;,
 &#39;Boolean&#39;,
 &#39;Function&#39;,
 &#39;RegExp&#39;,
 &#39;NaN&#39;,
 &#39;Infinite&#39;
].forEach(function (t) {
    type[&#39;is&#39; + t] = function (o) {
        return type(o) === t.toLowerCase();
    };
});

type.isObject({}) // true
type.isNumber(NaN) // true
type.isRegExp(/abc/) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;对象的属性模型:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;对象的属性模型&lt;/h2&gt;

&lt;p&gt;ECMAScript 5对于对象的属性，提出了一个精确的描述模型。&lt;/p&gt;

&lt;h3 id=&#34;属性的attributes对象-object-getownpropertydescriptor:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;属性的attributes对象，Object.getOwnPropertyDescriptor()&lt;/h3&gt;

&lt;p&gt;在JavaScript内部，每个属性都有一个对应的attributes对象，保存该属性的一些元信息。使用&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;方法，可以读取attributes对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = { p: &#39;a&#39; };

Object.getOwnPropertyDescriptor(o, &#39;p&#39;)
// Object { value: &amp;quot;a&amp;quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，使用&lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt;方法，读取&lt;code&gt;o&lt;/code&gt;对象的&lt;code&gt;p&lt;/code&gt;属性的attributes对象。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;attributes&lt;/code&gt;对象包含如下元信息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;：表示该属性的值，默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writable&lt;/code&gt;：表示该属性的值（value）是否可以改变，默认为&lt;code&gt;true&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enumerable&lt;/code&gt;： 表示该属性是否可枚举，默认为&lt;code&gt;true&lt;/code&gt;。如果设为&lt;code&gt;false&lt;/code&gt;，会使得某些操作（比如&lt;code&gt;for...in&lt;/code&gt;循环、&lt;code&gt;Object.keys()&lt;/code&gt;）跳过该属性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;configurable&lt;/code&gt;：表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的attributes对象（value属性除外），也就是说，configurable属性控制了attributes对象的可写性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt;：表示该属性的取值函数（getter），默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;：表示该属性的存值函数（setter），默认为&lt;code&gt;undefined&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;object-defineproperty-object-defineproperties:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.defineProperty()，Object.defineProperties()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法允许通过定义&lt;code&gt;attributes&lt;/code&gt;对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(object, propertyName, attributesObject)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如，新建一个&lt;code&gt;o&lt;/code&gt;对象，并定义它的&lt;code&gt;p&lt;/code&gt;属性，写法如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperty({}, &#39;p&#39;, {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});

o.p
// 123

o.p = 246;
o.p
// 123
// 因为writable为false，所以无法改变该属性的值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;Object.defineProperty&lt;/code&gt;方法和后面的&lt;code&gt;Object.defineProperties&lt;/code&gt;方法，都有性能损耗，会拖慢执行速度，不宜大量使用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;的一个用途，是设置动态属性名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(obj, someFunction(), {value: true});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一次性定义或修改多个属性，可以使用&lt;code&gt;Object.defineProperties&lt;/code&gt;方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: &#39;abc&#39;, enumerable: true },
  p3: { get: function() { return this.p1+this.p2 },
    enumerable:true,
    configurable:true
  }
});

o.p1 // 123
o.p2 // &amp;quot;abc&amp;quot;
o.p3 // &amp;quot;123abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中的&lt;code&gt;p3&lt;/code&gt;属性，定义了取值函数&lt;code&gt;get&lt;/code&gt;。这时需要注意的是，一旦定义了取值函数&lt;code&gt;get&lt;/code&gt;（或存值函数&lt;code&gt;set&lt;/code&gt;），就不能将&lt;code&gt;writable&lt;/code&gt;设为&lt;code&gt;true&lt;/code&gt;，或者同时定义&lt;code&gt;value&lt;/code&gt;属性，否则会报错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: 123,
  get: function() { return 456; }
});
// TypeError: Invalid property.
// A property cannot both have accessors and be writable or have a value,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码同时定义了&lt;code&gt;get&lt;/code&gt;属性和&lt;code&gt;value&lt;/code&gt;属性，结果就报错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;和&lt;code&gt;Object.defineProperties()&lt;/code&gt;的第三个参数，是一个属性对象。它的&lt;code&gt;writable&lt;/code&gt;、&lt;code&gt;configurable&lt;/code&gt;、&lt;code&gt;enumerable&lt;/code&gt;这三个属性的默认值都为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;writable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，表示对应的属性的值将不得改写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: &amp;quot;bar&amp;quot;
});

o.p // bar

o.p = &#39;foobar&#39;;
o.p // bar

Object.defineProperty(o, &#39;p&#39;, {
  value: &#39;foobar&#39;,
});
// TypeError: Cannot redefine property: p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码由于&lt;code&gt;writable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，导致无法对&lt;code&gt;p&lt;/code&gt;属性重新赋值，但是不会报错（严格模式下会报错）。不过，如果再一次使用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法对&lt;code&gt;value&lt;/code&gt;属性赋值，就会报错。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;configurable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，将无法删除该属性，也无法修改&lt;code&gt;attributes&lt;/code&gt;对象（&lt;code&gt;value&lt;/code&gt;属性除外）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {};

Object.defineProperty(o, &#39;p&#39;, {
  value: &#39;bar&#39;,
});

delete o.p
o.p // &amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，由于&lt;code&gt;configurable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，导致无法删除某个属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enumerable&lt;/code&gt;属性为&lt;code&gt;false&lt;/code&gt;，表示对应的属性不会出现在&lt;code&gt;for...in&lt;/code&gt;循环和&lt;code&gt;Object.keys&lt;/code&gt;方法中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  p1: 10,
  p2: 13,
};

Object.defineProperty(o, &#39;p3&#39;, {
  value: 3,
});

for (var i in o) {
  console.log(i, o[i]);
}
// p1 10
// p2 13
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;p3&lt;/code&gt;属性是用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法定义的，由于&lt;code&gt;enumerable&lt;/code&gt;属性默认为&lt;code&gt;false&lt;/code&gt;，所以不出现在&lt;code&gt;for...in&lt;/code&gt;循环中。&lt;/p&gt;

&lt;h3 id=&#34;可枚举性-enumerable:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;可枚举性（enumerable）&lt;/h3&gt;

&lt;p&gt;可枚举性（enumerable）用来控制所描述的属性，是否将被包括在&lt;code&gt;for...in&lt;/code&gt;循环之中。具体来说，如果一个属性的&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，下面三个操作不会取到该属性。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for..in&lt;/code&gt;循环&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.keys&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JSON.stringify&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，&lt;code&gt;enumerable&lt;/code&gt;可以用来设置“秘密”属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {a: 1, b: 2};

o.c = 3;
Object.defineProperty(o, &#39;d&#39;, {
  value: 4,
  enumerable: false
});

o.d
// 4

for( var key in o ) console.log( o[key] );
// 1
// 2
// 3

Object.keys(o)  // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]

JSON.stringify(o // =&amp;gt; &amp;quot;{a:1,b:2,c:3}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;d&lt;/code&gt;属性的&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但还是可以直接获取它的值。&lt;/p&gt;

&lt;p&gt;至于&lt;code&gt;for...in&lt;/code&gt;循环和&lt;code&gt;Object.keys&lt;/code&gt;方法的区别，在于前者包括对象继承自原型对象的属性，而后者只包括对象本身的属性。如果需要获取对象自身的所有属性，不管enumerable的值，可以使用&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;方法，详见下文。&lt;/p&gt;

&lt;p&gt;考虑到&lt;code&gt;JSON.stringify&lt;/code&gt;方法会排除&lt;code&gt;enumerable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;的值，有时可以利用这一点，为对象添加注释信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var car = {
  id: 123,
  color: &#39;red&#39;,
  ownerId: 12
};

var owner = {
  id: 12,
  name: &#39;Jack&#39;
};

Object.defineProperty(car, &#39;ownerInfo&#39;, {value: owner, enumerable: false});
car.ownerInfo // {id: 12, name: &amp;quot;Jack&amp;quot;}

JSON.stringify(car) //  &amp;quot;{&amp;quot;id&amp;quot;: 123,&amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,&amp;quot;ownerId&amp;quot;: 12}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;owner&lt;/code&gt;对象作为注释，加入&lt;code&gt;car&lt;/code&gt;对象。由于&lt;code&gt;ownerInfo&lt;/code&gt;属性不可枚举，所以&lt;code&gt;JSON.stringify&lt;/code&gt;方法最后输出&lt;code&gt;car&lt;/code&gt;对象时，会忽略&lt;code&gt;ownerInfo&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;这提示我们，如果你不愿意某些属性出现在JSON输出之中，可以把它的&lt;code&gt;enumerable&lt;/code&gt;属性设为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;object-getownpropertynames:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.getOwnPropertyNames()&lt;/h3&gt;

&lt;p&gt;Object.getOwnPropertyNames方法返回直接定义在某个对象上面的全部属性的名称，而不管该属性是否可枚举。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.defineProperties({}, {
        p1: { value: 1, enumerable: true },
        p2: { value: 2, enumerable: false }
});

Object.getOwnPropertyNames(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般来说，系统原生的属性（即非用户自定义的属性）都是不可枚举的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 比如，数组实例自带length属性是不可枚举的
Object.keys([]) // []
Object.getOwnPropertyNames([]) // [ &#39;length&#39; ]

// Object.prototype对象的自带属性也都是不可枚举的
Object.keys(Object.prototype) // []
Object.getOwnPropertyNames(Object.prototype)
// [&#39;hasOwnProperty&#39;,
//  &#39;valueOf&#39;,
//  &#39;constructor&#39;,
//  &#39;toLocaleString&#39;,
//  &#39;isPrototypeOf&#39;,
//  &#39;propertyIsEnumerable&#39;,
//  &#39;toString&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码可以看到，数组的实例对象（&lt;code&gt;[]&lt;/code&gt;）没有可枚举属性，不可枚举属性有length；Object.prototype对象也没有可枚举属性，但是有不少不可枚举属性。&lt;/p&gt;

&lt;h3 id=&#34;object-prototype-propertyisenumerable:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.prototype.propertyIsEnumerable()&lt;/h3&gt;

&lt;p&gt;对象实例的propertyIsEnumerable方法用来判断一个属性是否可枚举。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};
o.p = 123;&lt;/p&gt;

&lt;p&gt;o.propertyIsEnumerable(&amp;ldquo;p&amp;rdquo;) // true
o.propertyIsEnumerable(&amp;ldquo;toString&amp;rdquo;) // false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，用户自定义的p属性是可枚举的，而继承自原型对象的toString属性是不可枚举的。&lt;/p&gt;

&lt;h3 id=&#34;可配置性-configurable:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;可配置性（configurable）&lt;/h3&gt;

&lt;p&gt;可配置性（configurable）决定了是否可以修改属性的描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: false, 
        enumerable: false, 
        configurable: false
});

Object.defineProperty(o,&#39;p&#39;, {value: 2})
// TypeError: Cannot redefine property: p

Object.defineProperty(o,&#39;p&#39;, {writable: true})
// TypeError: Cannot redefine property: p

Object.defineProperty(o,&#39;p&#39;, {enumerable: true})
// TypeError: Cannot redefine property: p

Object.defineProperties(o,&#39;p&#39;,{configurable: true})
// TypeError: Cannot redefine property: p

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码首先生成对象o，并且定义属性p的configurable为false。然后，逐一改动value、writable、enumerable、configurable，结果都报错。&lt;/p&gt;

&lt;p&gt;需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = Object.defineProperty({}, &#39;p&#39;, {
        writable: true
});

Object.defineProperty(o,&#39;p&#39;, {writable: false})
// 修改成功

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于value，只要writable和configurable有一个为true，就可以改动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o1 = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: true,
        configurable: false
});

Object.defineProperty(o1,&#39;p&#39;, {value: 2})
// 修改成功

var o2 = Object.defineProperty({}, &#39;p&#39;, {
        value: 1,
        writable: false,
        configurable: true
});

Object.defineProperty(o2,&#39;p&#39;, {value: 2}) 
// 修改成功

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可配置性决定了一个变量是否可以被删除（delete）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = Object.defineProperties({}, {
        p1: { value: 1, configurable: true },
        p2: { value: 2, configurable: false }
});&lt;/p&gt;

&lt;p&gt;delete o.p1 // true
delete o.p2 // false&lt;/p&gt;

&lt;p&gt;o.p1 // undefined
o.p2 // 2&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中的对象o有两个属性，p1是可配置的，p2是不可配置的。结果，p2就无法删除。&lt;/p&gt;

&lt;p&gt;需要注意的是，当使用var命令声明变量时，变量的configurable为false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var a1 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a1&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: false
// }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;而不使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性为true。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;a2 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a2&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: true
// }&lt;/p&gt;

&lt;p&gt;// 或者写成&lt;/p&gt;

&lt;p&gt;this.a3 = 1;&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(this,&amp;lsquo;a3&amp;rsquo;)
// Object {
//  value: 1,
//  writable: true,
//  enumerable: true,
//  configurable: true
// }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中的&lt;code&gt;this.a3 = 1&lt;/code&gt;与&lt;code&gt;a3 = 1&lt;/code&gt;是等价的写法。this指的是当前的作用域，更多关于this的解释，参见《面向对象编程》一章。&lt;/p&gt;

&lt;p&gt;这种差异意味着，如果一个变量是使用var命令生成的，就无法用delete命令删除。也就是说，delete只能删除对象的属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var a1 = 1;
a2 = 1;&lt;/p&gt;

&lt;p&gt;delete a1 // false
delete a2 // true&lt;/p&gt;

&lt;p&gt;a1 // 1
a2 // ReferenceError: a2 is not defined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;可写性-writable:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;可写性（writable）&lt;/h3&gt;

&lt;p&gt;可写性（writable）决定了属性的值（value）是否可以被改变。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {};&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;ldquo;a&amp;rdquo;, { value : 37, writable : false });&lt;/p&gt;

&lt;p&gt;o.a // 37
o.a = 25;
o.a // 37&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码将o对象的a属性可写性设为false，然后改变这个属性的值，就不会有任何效果。&lt;/p&gt;

&lt;p&gt;这实际上将某个属性的值变成了常量。在ES6中，constant命令可以起到这个作用，但在ES5中，只有通过writable达到同样目的。&lt;/p&gt;

&lt;p&gt;这里需要注意的是，当对a属性重新赋值的时候，并不会抛出错误，只是静静地失败。但是，如果在严格模式下，这里就会抛出一个错误，即使是对a属性重新赋予一个同样的值。&lt;/p&gt;

&lt;p&gt;关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var proto = Object.defineProperty({}, &amp;lsquo;foo&amp;rsquo;, {
    value: &amp;lsquo;a&amp;rsquo;,
    writable: false
});&lt;/p&gt;

&lt;p&gt;var o = Object.create(proto);&lt;/p&gt;

&lt;p&gt;o.foo = &amp;lsquo;b&amp;rsquo;;
o.foo // &amp;lsquo;a&amp;rsquo;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，对象proto的foo属性不可写，结果proto的派生对象o，也不可以再自定义这个属性了。在严格模式下，这样做还会抛出一个错误。但是，有一个规避方法，就是通过覆盖attributes对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;lsquo;foo&amp;rsquo;, { value: &amp;lsquo;b&amp;rsquo; });&lt;/p&gt;

&lt;p&gt;o.foo // &amp;lsquo;b&amp;rsquo;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;存取器-accessor:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;存取器（accessor）&lt;/h3&gt;

&lt;p&gt;除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {
  get p() {
    return &amp;quot;getter&amp;quot;;
  },
  set p(value) {
    console.log(&amp;quot;setter: &amp;quot;+value);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;o.p // &amp;quot;getter&amp;quot;
o.p = 123 // &amp;quot;setter: 123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存取器往往用于，某个属性的值需要依赖对象内部数据的场合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o ={
  $n : 5,
  get next(){return this.$n++ },
  set next(n) {
    if (n &amp;gt;= this.$n) this.$n = n;
    else throw &amp;quot;新的值必须大于当前值&amp;quot;;
  }
};

o.next // 5

o.next = 10;
o.next // 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，next属性的存值函数和取值函数，都依赖于对内部属性$n的操作。&lt;/p&gt;

&lt;p&gt;下面是另一个存取器的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var d = new Date();

Object.defineProperty(d, &#39;month&#39;, {
  get: function() {
    return d.getMonth();
  },
  set: function(v) {
    d.setMonth(v);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为Date的实例对象d，定义了一个可读写的month属性。&lt;/p&gt;

&lt;p&gt;存取器也可以使用Object.create方法定义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = Object.create(Object.prototype, {
  foo: {
    get: function () {
      return &#39;getter&#39;;
    },
    set: function (value) {
      console.log(&#39;setter: &#39;+value);
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用上面这种写法，属性foo必须定义一个属性描述对象。该对象的get和set属性，分别是foo的取值函数和存值函数。&lt;/p&gt;

&lt;p&gt;利用存取器，可以实现数据对象与DOM对象的双向绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(user, &#39;name&#39;, {
  get: function() {
    return document.getElementById(&amp;quot;foo&amp;quot;).value;
  },
  set: function(newValue) {
    document.getElementById(&amp;quot;foo&amp;quot;).value = newValue;
  },
  configurable: true
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用存取函数，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。&lt;/p&gt;

&lt;h3 id=&#34;对象的拷贝:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;对象的拷贝&lt;/h3&gt;

&lt;p&gt;有时，我们需要将一个对象的所有属性，拷贝到另一个对象。ES5没有提供这个方法，必须自己实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {a: 1})
// {a: 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;extend({}, { get a(){ return 1 } })
// {a: 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了解决这个问题，我们可以通过&lt;code&gt;Object.defineProperty&lt;/code&gt;方法来拷贝属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {
    Object.defineProperty(to, property, Object.getOwnPropertyDescriptor(from, property));
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码还是有问题，拷贝某些属性时会失效。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;extend(document.body.style, {
  backgroundColor: &amp;quot;red&amp;quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的目的是，设置&lt;code&gt;document.body.style.backgroundColor&lt;/code&gt;属性为&lt;code&gt;red&lt;/code&gt;，但是实际上网页的背景色并不会变红。但是，如果用第一种简单拷贝的方法，反而能够达到目的。这提示我们，可以把两种方法结合起来，对于简单属性，就直接拷贝，对于那些通过描述对象设置的属性，则使用&lt;code&gt;Object.defineProperty&lt;/code&gt;方法拷贝。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var extend = function (to, from) {
  for (var property in from) {  
    var descriptor = Object.getOwnPropertyDescriptor(from, property);
  
    if (descriptor &amp;amp;&amp;amp; ( !descriptor.writable
      || !descriptor.configurable
      || !descriptor.enumerable
      || descriptor.get
      || descriptor.set)) {
      Object.defineProperty(to, property, descriptor);
    } else {
      to[property] = from[property];
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的这段代码，可以很好地拷贝任意属性。&lt;/p&gt;

&lt;h2 id=&#34;控制对象状态:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;控制对象状态&lt;/h2&gt;

&lt;p&gt;JavaScript提供了三种方法，精确控制一个对象的读写状态，防止对象被改变。最弱一层的保护是preventExtensions，其次是seal，最强的freeze。&lt;/p&gt;

&lt;h3 id=&#34;object-preventextensions方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.preventExtensions方法&lt;/h3&gt;

&lt;p&gt;Object.preventExtensions方法可以使得一个对象无法再添加新的属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;ldquo;p&amp;rdquo;, { value: &amp;ldquo;hello&amp;rdquo; });
// TypeError: Cannot define property:p, object is not extensible.&lt;/p&gt;

&lt;p&gt;o.p = 1;
o.p // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;如果是在严格模式下，则会抛出一个错误。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;(function () {
  &amp;lsquo;use strict&amp;rsquo;;
  o.p = &amp;lsquo;1&amp;rsquo;
}());
// TypeError: Can&amp;rsquo;t add property bar, object is not extensible&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;不过，对于使用了preventExtensions方法的对象，可以用delete命令删除它的现有属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();
o.p = 1;&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;delete o.p;
o.p // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-isextensible方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.isExtensible方法&lt;/h3&gt;

&lt;p&gt;Object.isExtensible方法用于检查一个对象是否使用了preventExtensions方法。也就是说，该方法可以用来检查是否可以为一个对象添加属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.isExtensible(o)
// true&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);
Object.isExtensible(o)
// false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码新生成了一个o对象，对该对象使用Object.isExtensible方法，返回true，表示可以添加新属性。对该对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。&lt;/p&gt;

&lt;h3 id=&#34;object-seal方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.seal方法&lt;/h3&gt;

&lt;p&gt;Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p:&amp;ldquo;hello&amp;rdquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);&lt;/p&gt;

&lt;p&gt;delete o.p;
o.p // &amp;ldquo;hello&amp;rdquo;&lt;/p&gt;

&lt;p&gt;o.x = &amp;lsquo;world&amp;rsquo;;
o.x // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Object.seal还把现有属性的attributes对象的configurable属性设为false，使得attributes对象不再能改变。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;// seal方法之前
Object.getOwnPropertyDescriptor(o, &amp;lsquo;p&amp;rsquo;)
// Object {value: &amp;ldquo;a&amp;rdquo;, writable: true, enumerable: true, configurable: true}&lt;/p&gt;

&lt;p&gt;Object.seal(o);&lt;/p&gt;

&lt;p&gt;// seal方法之后
Object.getOwnPropertyDescriptor(o, &amp;lsquo;p&amp;rsquo;)
// Object {value: &amp;ldquo;a&amp;rdquo;, writable: true, enumerable: true, configurable: false}&lt;/p&gt;

&lt;p&gt;Object.defineProperty(o, &amp;lsquo;p&amp;rsquo;, { enumerable: false })
// TypeError: Cannot redefine property: p&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;从上面代码可以看到，使用seal方法之后，attributes对象的configurable就变成了false，然后如果想改变enumerable就会报错。&lt;/p&gt;

&lt;p&gt;可写性（writable）有点特别。如果writable为false，使用Object.seal方法以后，将无法将其变成true；但是，如果writable为true，依然可以将其变成false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o1 = Object.defineProperty({}, &amp;lsquo;p&amp;rsquo;, {writable: false});
Object.seal(o1);
Object.defineProperty(o1,&amp;lsquo;p&amp;rsquo;,{writable:true})
// Uncaught TypeError: Cannot redefine property: p&lt;/p&gt;

&lt;p&gt;var o2 = Object.defineProperty({}, &amp;lsquo;p&amp;rsquo;, {writable: true});
Object.seal(o2);
Object.defineProperty(o2,&amp;lsquo;p&amp;rsquo;,{writable:false})&lt;/p&gt;

&lt;p&gt;Object.getOwnPropertyDescriptor(o2, &amp;lsquo;p&amp;rsquo;)
/* { value: &amp;ldquo;,
  writable: false,
  enumerable: true,
  configurable: false } */&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，同样是使用了Object.seal方法，如果writable原为false，改变这个设置将报错；如果原为true，则不会有问题。&lt;/p&gt;

&lt;p&gt;至于属性对象的value是否可改变，是由writable决定的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var o = { p: &#39;a&#39; };
Object.seal(o);
o.p = &#39;b&#39;;
o.p // &#39;b&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，Object.seal方法对p属性的value无效，是因为此时p属性的writable为true。&lt;/p&gt;

&lt;h3 id=&#34;object-issealed方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.isSealed方法&lt;/h3&gt;

&lt;p&gt;Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);
Object.isSealed(o) // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;另外，这时isExtensible方法也返回false。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = { p: &amp;lsquo;a&amp;rsquo; };&lt;/p&gt;

&lt;p&gt;Object.seal(o);
Object.isExtensible(o) // false&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-freeze方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.freeze方法&lt;/h3&gt;

&lt;p&gt;Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);&lt;/p&gt;

&lt;p&gt;o.p = &amp;ldquo;world&amp;rdquo;;
o.p // hello&lt;/p&gt;

&lt;p&gt;o.t = &amp;ldquo;hello&amp;rdquo;;
o.t // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，对现有属性重新赋值（o.p = &amp;ldquo;world&amp;rdquo;）或者添加一个新属性，并不会报错，只是默默地失败。但是，如果是在严格模式下，就会报错。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);&lt;/p&gt;

&lt;p&gt;// 对现有属性重新赋值
(function () { &amp;lsquo;use strict&amp;rsquo;; o.p = &amp;ldquo;world&amp;rdquo;;}())
// TypeError: Cannot assign to read only property &amp;lsquo;p&amp;rsquo; of #&lt;Object&gt;&lt;/p&gt;

&lt;p&gt;// 添加不存在的属性
(function () { &amp;lsquo;use strict&amp;rsquo;; o.t = 123;}())
// TypeError: Can&amp;rsquo;t add property t, object is not extensible&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;object-isfrozen方法:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;Object.isFrozen方法&lt;/h3&gt;

&lt;p&gt;Object.isFrozen方法用于检查一个对象是否使用了Object.freeze()方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = {p:&amp;ldquo;hello&amp;rdquo;};&lt;/p&gt;

&lt;p&gt;Object.freeze(o);
Object.isFrozen(o) // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;局限性:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;局限性&lt;/h3&gt;

&lt;p&gt;需要注意的是，使用上面这些方法锁定对象的可写性，但是依然可以通过改变该对象的原型对象，来为它增加属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = new Object();&lt;/p&gt;

&lt;p&gt;Object.preventExtensions(o);&lt;/p&gt;

&lt;p&gt;var proto = Object.getPrototypeOf(o);&lt;/p&gt;

&lt;p&gt;proto.t = &amp;ldquo;hello&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;o.t
// hello&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;一种解决方案是，把原型也冻结住。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var o = Object.seal(
  Object.create(Object.freeze({x:1}),
    {y: {value: 2, writable: true}})
);&lt;/p&gt;

&lt;p&gt;Object.getPrototypeOf(o).t = &amp;ldquo;hello&amp;rdquo;;
o.hello // undefined&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&#34;参考链接:2d47a4f2e835eec0659f1c3f6d452640&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2013/08/protecting-objects.html&#34;&gt;Protecting objects in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;kangax, &lt;a href=&#34;http://perfectionkills.com/understanding-delete/&#34;&gt;Understanding delete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jon Bretman, &lt;a href=&#34;http://techblog.badoo.com/blog/2013/11/01/type-checking-in-javascript/&#34;&gt;Type Checking in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cody Lindley, &lt;a href=&#34;http://tech.pro/tutorial/1671/thinking-about-ecmascript-5-parts&#34;&gt;Thinking About ECMAScript 5 Parts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bjorn Tipling, &lt;a href=&#34;http://bjorn.tipling.com/advanced-objects-in-javascript&#34;&gt;Advanced objects in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Javier Márquez, &lt;a href=&#34;http://arqex.com/967/javascript-properties-enumerable-writable-configurable&#34;&gt;Javascript properties are enumerable, writable and configurable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Sella Rafaeli, &lt;a href=&#34;http://www.sellarafaeli.com/blog/native_javascript_data_binding&#34;&gt;Native JavaScript Data-Binding&lt;/a&gt;: 使用存取函数实现model与view的双向绑定&lt;/li&gt;
&lt;li&gt;Lea Verou, &lt;a href=&#34;http://lea.verou.me/2015/08/copying-properties-the-robust-way/&#34;&gt;Copying object properties, the robust way&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5、Doom</title>
      <link>http://575087694.github.io/post/index5/</link>
      <pubDate>Mon, 27 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index5/</guid>
      <description>

&lt;h2 id=&#34;dom的概念:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;DOM的概念&lt;/h2&gt;

&lt;p&gt;DOM是文档对象模型（Document Object Model）的简称，它的基本思想是把结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点组成一个树状结构（DOM Tree）。所有的节点和最终的树状结构，都有规范的对外接口，以达到使用编程语言操作文档的目的（比如增删内容）。所以，DOM可以理解成文档（HTML文档、XML文档和SVG文档）的编程接口。&lt;/p&gt;

&lt;p&gt;DOM有自己的国际标准，目前的通用版本是&lt;a href=&#34;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html&#34;&gt;DOM 3&lt;/a&gt;，下一代版本&lt;a href=&#34;http://www.w3.org/TR/dom/&#34;&gt;DOM 4&lt;/a&gt;正在拟定中。本章介绍的就是JavaScript对DOM标准的实现和用法。&lt;/p&gt;

&lt;p&gt;严格地说，DOM不属于JavaScript，但是操作DOM是JavaScript最常见的任务，而JavaScript也是最常用于DOM操作的语言。所以，DOM往往放在JavaScript里面介绍。&lt;/p&gt;

&lt;h2 id=&#34;节点的概念:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;节点的概念&lt;/h2&gt;

&lt;p&gt;DOM的最小组成单位叫做节点（node），一个文档的树形结构（DOM树），就是由各种不同类型的节点组成。&lt;/p&gt;

&lt;p&gt;对于HTML文档，节点主要有以下六种类型：Document节点、DocumentType节点、Element节点、Attribute节点、Text节点和DocumentFragment节点。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Document&lt;/td&gt;
&lt;td&gt;文档节点&lt;/td&gt;
&lt;td&gt;整个文档（window.document）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DocumentType&lt;/td&gt;
&lt;td&gt;文档类型节点&lt;/td&gt;
&lt;td&gt;文档的类型（比如&amp;lt;!DOCTYPE html&amp;gt;）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Element&lt;/td&gt;
&lt;td&gt;元素节点&lt;/td&gt;
&lt;td&gt;HTML元素（比如&amp;lt;body&amp;gt;、&amp;lt;a&amp;gt;等）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Attribute&lt;/td&gt;
&lt;td&gt;属性节点&lt;/td&gt;
&lt;td&gt;HTML元素的属性（比如class=&amp;ldquo;right&amp;rdquo;）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Text&lt;/td&gt;
&lt;td&gt;文本节点&lt;/td&gt;
&lt;td&gt;HTML文档中出现的文本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DocumentFragment&lt;/td&gt;
&lt;td&gt;文档碎片节点&lt;/td&gt;
&lt;td&gt;文档的片段&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;浏览器原生提供一个Node对象，上表所有类型的节点都是Node对象派生出来的。也就是说，它们都继承了Node的属性和方法。&lt;/p&gt;

&lt;h2 id=&#34;node节点的属性:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;Node节点的属性&lt;/h2&gt;

&lt;h3 id=&#34;nodename-nodetype:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;nodeName，nodeType&lt;/h3&gt;

&lt;p&gt;nodeName属性返回节点的名称，nodeType属性返回节点的常数值。具体的返回值，可查阅下方的表格。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;nodeName&lt;/th&gt;
&lt;th&gt;nodeType&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DOCUMENT_NODE&lt;/td&gt;
&lt;td&gt;#document&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ELEMENT_NODE&lt;/td&gt;
&lt;td&gt;大写的HTML元素名&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ATTRIBUTE_NODE&lt;/td&gt;
&lt;td&gt;等同于Attr.name&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TEXT_NODE&lt;/td&gt;
&lt;td&gt;#text&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DOCUMENT_FRAGMENT_NODE&lt;/td&gt;
&lt;td&gt;#document-fragment&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DOCUMENT_TYPE_NODE&lt;/td&gt;
&lt;td&gt;等同于DocumentType.name&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以&lt;code&gt;document&lt;/code&gt;节点为例，它的&lt;code&gt;nodeName&lt;/code&gt;属性等于&lt;code&gt;#document&lt;/code&gt;，&lt;code&gt;nodeType&lt;/code&gt;属性等于9。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.nodeName // &amp;quot;#document&amp;quot;
document.nodeType // 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常来说，使用&lt;code&gt;nodeType&lt;/code&gt;属性确定一个节点的类型，比较方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.querySelector(&#39;a&#39;).nodeType === 1
// true

document.querySelector(&#39;a&#39;).nodeType === Node.ELEMENT_NODE
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两种写法是等价的。&lt;/p&gt;

&lt;h3 id=&#34;ownerdocument-nextsibling-previoussibling-parentnode-parentelement:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;ownerDocument，nextSibling，previousSibling，parentNode，parentElement&lt;/h3&gt;

&lt;p&gt;以下属性返回当前节点的相关节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）ownerDocument&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var d = p.ownerDocument;
d === document // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;document对象本身的ownerDocument属性，返回null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）nextSibling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。注意，该属性还包括文本节点和评论节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var el = document.getElementById(&#39;div-01&#39;).firstChild;
var i = 1;

while (el) {
  console.log(i + &#39;. &#39; + el.nodeName);
  el = el.nextSibling;
  i++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码遍历&lt;code&gt;div-01&lt;/code&gt;节点的所有子节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）previousSibling&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// html代码如下
// &amp;lt;a&amp;gt;&amp;lt;b1 id=&amp;quot;b1&amp;quot;/&amp;gt;&amp;lt;b2 id=&amp;quot;b2&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;

document.getElementById(&amp;quot;b1&amp;quot;).previousSibling // null
document.getElementById(&amp;quot;b2&amp;quot;).previousSibling.id // &amp;quot;b1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于当前节点前面有空格，则previoussibling属性会返回一个内容为空格的文本节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）parentNode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：element节点、document节点和documentfragment节点。&lt;/p&gt;

&lt;p&gt;下面代码是如何从父节点移除指定节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (node.parentNode) {
  node.parentNode.removeChild(node);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于document节点和documentfragment节点，它们的父节点都是null。另外，对于那些生成后还没插入DOM树的节点，父节点也是null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）parentElement&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;parentElement属性返回当前节点的父Element节点。如果当前节点没有父节点，或者父节点类型不是Element节点，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (node.parentElement) {
  node.parentElement.style.color = &amp;quot;red&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码设置指定节点的父Element节点的CSS属性。&lt;/p&gt;

&lt;p&gt;在IE浏览器中，只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性。&lt;/p&gt;

&lt;h3 id=&#34;textcontent-nodevalue:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;textContent，nodeValue&lt;/h3&gt;

&lt;p&gt;以下属性返回当前节点的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）textContent&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;textContent属性返回当前节点和它的所有后代节点的文本内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// HTML代码为
// &amp;lt;div id=&amp;quot;divA&amp;quot;&amp;gt;This is &amp;lt;span&amp;gt;some&amp;lt;/span&amp;gt; text&amp;lt;/div&amp;gt;

document.getElementById(&amp;quot;divA&amp;quot;).textContent
// This is some text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的textContent属性，自动忽略当前节点内部的HTML标签，返回所有文本内容。&lt;/p&gt;

&lt;p&gt;该属性是可读写的，设置该属性的值，会用一个新的文本节点，替换所有它原来的子节点。它还有一个好处，就是自动对HTML标签转义。这很适合用于用户提供的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.getElementById(&#39;foo&#39;).textContent = &#39;&amp;lt;p&amp;gt;GoodBye!&amp;lt;/p&amp;gt;&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在插入文本时，会将p标签解释为文本，即&amp;amp;lt;p&amp;amp;gt;，而不会当作标签处理。&lt;/p&gt;

&lt;p&gt;对于Text节点和Comment节点，该属性的值与nodeValue属性相同。对于其他类型的节点，该属性会将每个子节点的内容连接在一起返回，但是不包括Comment节点。如果一个节点没有子节点，则返回空字符串。&lt;/p&gt;

&lt;p&gt;document节点和doctype节点的textContent属性为null。如果要读取整个文档的内容，可以使用&lt;code&gt;document.documentElement.textContent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在IE浏览器，所有Element节点都有一个innerText属性。它与textContent属性基本相同，但是有几点区别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;innerText受CSS影响，textContent不受。比如，如果CSS规则隐藏（hidden）了某段文本，innerText就不会返回这段文本，textContent则照样返回。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;innerText返回的文本，会过滤掉空格、换行和回车键，textContent则不会。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;innerText属性不是DOM标准的一部分，Firefox浏览器甚至没有部署这个属性，而textContent是DOM标准的一部分。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（2）nodeValue&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nodeValue属性返回或设置当前节点的值，格式为字符串。但是，该属性只对Text节点、Comment节点、XML文档的CDATA节点有效，其他类型的节点一律返回null。&lt;/p&gt;

&lt;p&gt;因此，nodeValue属性一般只用于Text节点。对于那些返回null的节点，设置nodeValue属性是无效的。&lt;/p&gt;

&lt;h3 id=&#34;childnodes-firstnode-lastchild:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;childNodes，firstNode，lastChild&lt;/h3&gt;

&lt;p&gt;以下属性返回当前节点的子节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）childNodes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;childNodes属性返回一个NodeList集合，成员包括当前节点的所有子节点。注意，除了HTML元素节点，该属性返回的还包括Text节点和Comment节点。如果当前节点不包括任何子节点，则返回一个空的NodeList集合。由于NodeList对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var ulElementChildNodes = document.querySelector(&amp;lsquo;ul&amp;rsquo;).childNodes;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）firstNode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;firstNode属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。注意，除了HTML元素子节点，该属性还包括文本节点和评论节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）lastChild&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。&lt;/p&gt;

&lt;h3 id=&#34;baseuri:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;baseURI&lt;/h3&gt;

&lt;p&gt;baseURI属性返回一个字符串，由当前网页的协议、域名和所在的目录组成，表示当前网页的绝对路径。如果无法取到这个值，则返回null。浏览器根据这个属性，计算网页上的相对路径的URL。该属性为只读。&lt;/p&gt;

&lt;p&gt;通常情况下，该属性由当前网址的URL（即window.location属性）决定，但是可以使用HTML的&amp;lt;base&amp;gt;标签，改变该属性的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;base href=&amp;quot;http://www.example.com/page.html&amp;quot;&amp;gt;
&amp;lt;base target=&amp;quot;_blank&amp;quot; href=&amp;quot;http://www.example.com/page.html&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该属性不仅document对象有（&lt;code&gt;document.baseURI&lt;/code&gt;），元素节点也有（&lt;code&gt;element.baseURI&lt;/code&gt;）。通常情况下，它们的值是相同的。&lt;/p&gt;

&lt;h2 id=&#34;node节点的方法:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;Node节点的方法&lt;/h2&gt;

&lt;h3 id=&#34;appendchild-haschildnodes:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;appendChild()，hasChildNodes()&lt;/h3&gt;

&lt;p&gt;以下方法与子节点相关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）appendChild()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;appendChild方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var p = document.createElement(&amp;ldquo;p&amp;rdquo;);
document.body.appendChild(p);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;如果参数节点是文档中现有的其他节点，appendChild方法会将其从原来的位置，移动到新位置。&lt;/p&gt;

&lt;p&gt;hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = document.getElementById(&amp;quot;foo&amp;quot;);

if ( foo.hasChildNodes() ) {
  foo.removeChild( foo.childNodes[0] );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，如果foo节点有子节点，就移除第一个子节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）hasChildNodes()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;hasChildNodes方法结合firstChild属性和nextSibling属性，可以遍历当前节点的所有后代节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function DOMComb (oParent, oCallback) {
  if (oParent.hasChildNodes()) {
    for (var oNode = oParent.firstChild; oNode; oNode = oNode.nextSibling) {
      DOMComb(oNode, oCallback);
    }
  }
  oCallback.call(oParent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的DOMComb函数的第一个参数是某个指定的节点，第二个参数是回调函数。这个回调函数会依次作用于指定节点，以及指定节点的所有后代节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function printContent () {
  if (this.nodeValue) {
    console.log(this.nodeValue);
  }
}

DOMComb(document.body, printContent);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;clonenode-insertbefore-removechild-replacechild:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;cloneNode()，insertBefore()，removeChild()，replaceChild()&lt;/h3&gt;

&lt;p&gt;下面方法与节点操作有关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）cloneNode()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是false，即不克隆子节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var cloneUL = document.querySelector(&amp;lsquo;ul&amp;rsquo;).cloneNode(true);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;需要注意的是，克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即&lt;code&gt;node.onclick = fn&lt;/code&gt;），添加在这个节点上的事件回调函数。&lt;/p&gt;

&lt;p&gt;克隆一个节点之后，DOM树有可能出现两个有相同ID属性（即&lt;code&gt;id=&amp;quot;xxx&amp;quot;&lt;/code&gt;）的HTML元素，这时应该修改其中一个HTML元素的ID属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）insertBefore()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;insertBefore方法用于将某个节点插入当前节点的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点的一个子节点，新的节点将插在这个节点的前面。该方法返回被插入的新节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var text1 = document.createTextNode(&amp;lsquo;1&amp;rsquo;);
var li = document.createElement(&amp;lsquo;li&amp;rsquo;);
li.appendChild(text1);&lt;/p&gt;

&lt;p&gt;var ul = document.querySelector(&amp;lsquo;ul&amp;rsquo;);
ul.insertBefore(li,ul.firstChild);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码在ul节点的最前面，插入一个新建的li节点。&lt;/p&gt;

&lt;p&gt;如果insertBefore方法的第二个参数为null，则新节点将插在当前节点的最后位置，即变成最后一个子节点。&lt;/p&gt;

&lt;p&gt;将新节点插在当前节点的最前面（即变成第一个子节点），可以使用当前节点的firstChild属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parentElement.insertBefore(newElement, parentElement.firstChild);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，如果当前节点没有任何子节点，&lt;code&gt;parentElement.firstChild&lt;/code&gt;会返回null，则新节点会插在当前节点的最后，等于是第一个子节点。&lt;/p&gt;

&lt;p&gt;由于不存在insertAfter方法，如果要插在当前节点的某个子节点后面，可以用insertBefore方法结合nextSibling属性模拟。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;parentDiv.insertBefore(s1, s2.nextSibling);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码可以将s1节点，插在s2节点的后面。如果s2是当前节点的最后一个子节点，则&lt;code&gt;s2.nextSibling&lt;/code&gt;返回null，这时s1节点会插在当前节点的最后，变成当前节点的最后一个子节点，等于紧跟在s2的后面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）removeChild()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;removeChild方法接受一个子节点作为参数，用于从当前节点移除该节点。它返回被移除的节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var divA = document.getElementById(&amp;lsquo;A&amp;rsquo;);
divA.parentNode.removeChild(divA);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码是如何移除一个指定节点。&lt;/p&gt;

&lt;p&gt;下面是如何移除当前节点的所有子节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var element = document.getElementById(&amp;quot;top&amp;quot;);
while (element.firstChild) {
  element.removeChild(element.firstChild);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;被移除的节点依然存在于内存之中，但是不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）replaceChild()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;replacedNode = parentNode.replaceChild(newChild, oldChild);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个例子。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var divA = document.getElementById(&amp;lsquo;A&amp;rsquo;);
var newSpan = document.createElement(&amp;lsquo;span&amp;rsquo;);
newSpan.textContent = &amp;lsquo;Hello World!&amp;rsquo;;
divA.parentNode.replaceChild(newSpan,divA);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码是如何替换指定节点。&lt;/p&gt;

&lt;h3 id=&#34;contains-comparedocumentposition-isequalnode:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;contains()，compareDocumentPosition()，isEqualNode()&lt;/h3&gt;

&lt;p&gt;下面方法用于节点的互相比较。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）contains()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;contains方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;document.body.contains(node)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码检查某个节点，是否包含在当前文档之中。&lt;/p&gt;

&lt;p&gt;注意，如果将当前节点传入contains方法，会返回true。虽然从意义上说，一个节点不应该包含自身。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;nodeA.contains(nodeA) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（2）compareDocumentPosition()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;compareDocumentPosition方法的用法，与contains方法完全一致，返回一个7个比特位的二进制值，表示参数节点与当前节点的关系。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;二进制值&lt;/th&gt;
&lt;th&gt;数值&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;000000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;两个节点相同&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;000001&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;两个节点不在同一个文档（即有一个节点不在当前文档）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;000010&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;参数节点在当前节点的前面&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;000100&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;参数节点在当前节点的后面&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;001000&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;参数节点包含当前节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;010000&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;当前节点包含参数节点&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;浏览器的私有用途&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// HTML代码为
// &amp;lt;div id=&amp;quot;writeroot&amp;quot;&amp;gt;
//   &amp;lt;form&amp;gt;
//     &amp;lt;input id=&amp;quot;test&amp;quot; /&amp;gt;
//   &amp;lt;/form&amp;gt;
// &amp;lt;/div&amp;gt;

var x = document.getElementById(&#39;writeroot&#39;);
var y = document.getElementById(&#39;test&#39;);

x.compareDocumentPosition(y) // 20
y.compareDocumentPosition(x) // 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，节点x包含节点y，而且节点y在节点x的后面，所以第一个compareDocumentPosition方法返回20（010100），第二个compareDocumentPosition方法返回10（0010010）。&lt;/p&gt;

&lt;p&gt;由于compareDocumentPosition返回值的含义，定义在每一个比特位上，所以如果要检查某一种特定的含义，就需要使用比特位运算符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var head = document.head;
var body = document.body;
if (head.compareDocumentPosition(body) &amp;amp; 4) {
  console.log(&amp;quot;文档结构正确&amp;quot;);
} else {
  console.log(&amp;quot;&amp;lt;head&amp;gt; 不能在 &amp;lt;body&amp;gt; 前面&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，compareDocumentPosition的返回值与4（又称掩码）进行与运算（&amp;amp;），得到一个布尔值，表示head是否在body前面。&lt;/p&gt;

&lt;p&gt;在这个方法的基础上，可以部署一些特定的函数，检查节点的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Node.prototype.before = function (arg) {
  return !!(this.compareDocumentPosition(arg) &amp;amp; 2)
}

nodeA.before(nodeB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在Node对象上部署了一个before方法，返回一个布尔值，表示参数节点是否在当前节点的前面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）isEqualNode()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var targetEl = document.getElementById(&amp;ldquo;targetEl&amp;rdquo;);
var firstDiv = document.getElementsByTagName(&amp;ldquo;div&amp;rdquo;)[0];&lt;/p&gt;

&lt;p&gt;targetEl.isEqualNode(firstDiv)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;normalize:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;normalize()&lt;/h3&gt;

&lt;p&gt;normailize方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var wrapper = document.createElement(&amp;quot;div&amp;quot;);

wrapper.appendChild(document.createTextNode(&amp;quot;Part 1 &amp;quot;));
wrapper.appendChild(document.createTextNode(&amp;quot;Part 2 &amp;quot;));

wrapper.childNodes.length // 2

wrapper.normalize();

wrapper.childNodes.length // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码使用normalize方法之前，wrapper节点有两个Text子节点。使用normalize方法之后，两个Text子节点被合并成一个。&lt;/p&gt;

&lt;p&gt;该方法是&lt;code&gt;Text.splitText&lt;/code&gt;的逆方法，可以查看《Text节点》章节，了解更多内容。&lt;/p&gt;

&lt;h2 id=&#34;nodelist接口-htmlcollection接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;NodeList接口，HTMLCollection接口&lt;/h2&gt;

&lt;p&gt;节点对象都是单个节点，但是有时会需要一种数据结构，能够容纳多个节点。DOM提供两种接口，用于部署这种节点的集合：NodeList接口和HTMLCollection接口。&lt;/p&gt;

&lt;h3 id=&#34;nodelist接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;NodeList接口&lt;/h3&gt;

&lt;p&gt;有些属性和方法返回的是一组节点，比如Node.childNodes、document.querySelectorAll()。它们返回的都是一个部署了NodeList接口的对象。&lt;/p&gt;

&lt;p&gt;NodeList接口有时返回一个动态集合，有时返回一个静态集合。所谓动态集合就是一个活的集合，DOM树删除或新增一个相关节点，都会立刻反映在NodeList接口之中。Node.childNodes返回的，就是一个动态集合。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var parent = document.getElementById(&#39;parent&#39;);
parent.childNodes.length // 2
parent.appendChild(document.createElement(&#39;div&#39;));
parent.childNodes.length // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;parent.childNodes&lt;/code&gt;返回的是一个部署了NodeList接口的对象。当parent节点新增一个子节点以后，该对象的成员个数就增加了1。&lt;/p&gt;

&lt;p&gt;document.querySelectorAll方法返回的是一个静态，DOM内部的变化，并不会实时反映在该方法的返回结果之中。&lt;/p&gt;

&lt;p&gt;NodeList接口提供length属性和数字索引，因此可以像数组那样，使用数字索引取出每个节点，但是它本身并不是数组，不能使用pop或push之类数组特有的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 数组的继承链
myArray --&amp;gt; Array.prototype --&amp;gt; Object.prototype --&amp;gt; null

// NodeList的继承链
myNodeList --&amp;gt; NodeList.prototype --&amp;gt; Object.prototype --&amp;gt; null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的继承链可以看到，NodeList接口对象并不继承Array.prototype，因此不具有数组接口提供的方法。如果要在NodeList接口使用数组方法，可以将NodeList接口对象转为真正的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var div_list = document.querySelectorAll(&#39;div&#39;);
var div_array = Array.prototype.slice.call(div_list);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过下面的方法调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var forEach = Array.prototype.forEach;

forEach.call(element.childNodes, function(child){
  child.parentNode.style.color = &#39;#0F0&#39;;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码让数组的forEach方法在NodeList接口对象上调用。&lt;/p&gt;

&lt;p&gt;不过，遍历NodeList接口对象的首选方法，还是使用for循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for (var i = 0; i &amp;lt; myNodeList.length; ++i) {
  var item = myNodeList[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要使用for&amp;hellip;in循环去遍历NodeList接口对象，因为for&amp;hellip;in循环会将非数字索引的length属性和下面要讲到的item方法，也遍历进去，而且不保证各个成员遍历的顺序。&lt;/p&gt;

&lt;p&gt;ES6新增的for&amp;hellip;of循环，也可以正确遍历NodeList接口对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var list = document.querySelectorAll( &#39;input[type=checkbox]&#39; );
for (var item of list) {
  item.checked = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NodeList接口提供item方法，接受一个数字索引作为参数，返回该索引对应的成员。如果取不到成员，或者索引不合法，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;nodeItem = nodeList.item(index)

// 实例
var divs = document.getElementsByTagName(&amp;quot;div&amp;quot;);
var secondDiv = divs.item(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，由于数字索引从零开始计数，所以取出第二个成员，要使用数字索引1。&lt;/p&gt;

&lt;p&gt;所有类似数组的对象，都可以使用方括号运算符取出成员，所以一般情况下，都是使用下面的写法，而不使用item方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;nodeItem = nodeList[index]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;htmlcollection接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;HTMLCollection接口&lt;/h3&gt;

&lt;p&gt;HTMLCollection接口与NodeList接口类似，也是节点的集合，但是集合成员都是Element节点。该接口都是动态集合，节点的变化会实时反映在集合中。document.links、docuement.forms、document.images等属性，返回的都是HTMLCollection接口对象。&lt;/p&gt;

&lt;p&gt;部署了该接口的对象，具有length属性和数字索引，因此是一个类似于数组的对象。&lt;/p&gt;

&lt;p&gt;item方法根据成员的位置参数（从0开始），返回该成员。如果取不到成员或数字索引不合法，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var c = document.images;
var img1 = c.item(10);

// 等价于下面的写法
var img1 = c[1];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;namedItem方法根据成员的ID属性或name属性，返回该成员。如果没有对应的成员，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// HTML代码为
// &amp;lt;form id=&amp;quot;myForm&amp;quot;&amp;gt;&amp;lt;/form&amp;gt;
var elem = document.forms.namedItem(&amp;quot;myForm&amp;quot;);
// 等价于下面的写法
var elem = document.forms[&amp;quot;myForm&amp;quot;];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于item方法和namedItem方法，都可以用方括号运算符代替，所以建议一律使用方括号运算符。&lt;/p&gt;

&lt;h2 id=&#34;parentnode接口-childnode接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;ParentNode接口，ChildNode接口&lt;/h2&gt;

&lt;p&gt;不同的节点除了继承Node接口以外，还会继承其他接口。ParentNode接口用于获取当前节点的Element子节点，ChildNode接口用于处理当前节点的子节点（包含但不限于Element子节点）。&lt;/p&gt;

&lt;h3 id=&#34;parentnode接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;ParentNode接口&lt;/h3&gt;

&lt;p&gt;ParentNode接口用于获取Element子节点。Element节点、Document节点和DocumentFragment节点，部署了ParentNode接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）children&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;children属性返回一个动态的HTMLCollection集合，由当前节点的所有Element子节点组成。&lt;/p&gt;

&lt;p&gt;下面代码遍历指定节点的所有Element子节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if (el.children.length) {
  for (var i = 0; i &amp;lt; el.children.length; i++) {
    // ...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（2）firstElementChild&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;firstElementChild属性返回当前节点的第一个Element子节点，如果不存在任何Element子节点，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.firstElementChild.nodeName
// &amp;quot;HTML&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，document节点的第一个Element子节点是&amp;lt;HTML&amp;gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）lastElementChild&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;lastElementChild属性返回当前节点的最后一个Element子节点，如果不存在任何Element子节点，则返回null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.lastElementChild.nodeName
// &amp;quot;HTML&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，document节点的最后一个Element子节点是&amp;lt;HTML&amp;gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）childElementCount&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;childElementCount属性返回当前节点的所有Element子节点的数目。&lt;/p&gt;

&lt;h3 id=&#34;childnode接口:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;ChildNode接口&lt;/h3&gt;

&lt;p&gt;ChildNode接口用于处理子节点（包含但不限于Element子节点）。Element节点、DocumentType节点和CharacterData接口，部署了ChildNode接口。凡是这三类节点（接口），都可以使用下面四个方法。但是现实的情况是，除了第一个remove方法，目前没有浏览器支持后面三个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）remove()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;remove方法用于移除当前节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;el.remove()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面方法在DOM中移除了el节点。注意，调用这个方法的节点，是被移除的节点本身，而不是它的父节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）before()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;before方法用于在当前节点的前面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）after()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;after方法用于在当前节点的后面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）replaceWith()&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;replaceWith方法使用参数指定的节点，替换当前节点。如果参数是节点对象，替换当前节点的就是该节点对象；如果参数是文本，替换当前节点的就是参数对应的文本节点。&lt;/p&gt;

&lt;h2 id=&#34;html元素:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;html元素&lt;/h2&gt;

&lt;p&gt;html元素是网页的根元素，document.documentElement就指向这个元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）clientWidth属性，clientHeight属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个属性返回视口（viewport）的大小，单位为像素。所谓“视口”，是指用户当前能够看见的那部分网页的大小&lt;/p&gt;

&lt;p&gt;document.documentElement.clientWidth和document.documentElement.clientHeight，基本上与window.innerWidth和window.innerHeight同义。只有一个区别，前者不将滚动条计算在内（很显然，滚动条和工具栏会减小视口大小），而后者包括了滚动条的高度和宽度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）offsetWidth属性，offsetHeight属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个属性返回html元素的宽度和高度，即网页的总宽度和总高度。&lt;/p&gt;

&lt;h3 id=&#34;dataset属性:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;dataset属性&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dataset&lt;/code&gt;属性用于操作HTML标签元素的&lt;code&gt;data-*&lt;/code&gt;属性。下面是一个有&lt;code&gt;data-*&lt;/code&gt;属性的&lt;code&gt;div&lt;/code&gt;节点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;myDiv&amp;quot; data-id=&amp;quot;myId&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要读取&lt;code&gt;data-id&lt;/code&gt;属性，可以从当前节点的&lt;code&gt;dataset.id&lt;/code&gt;属性读取。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var id = document.getElementById(&amp;quot;myDiv&amp;quot;).dataset.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要设置&lt;code&gt;data-id&lt;/code&gt;属性，可以直接对&lt;code&gt;dataset.id&lt;/code&gt;赋值。如果该属性不存在，将会被新建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;document.getElementById(&#39;myDiv&#39;).dataset.id = &#39;hello&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除一个&lt;code&gt;data-*&lt;/code&gt;属性，可以直接使用&lt;code&gt;delete&lt;/code&gt;命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;delete document.getElementById(&amp;quot;myDiv&amp;quot;).dataset.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了&lt;code&gt;dataset&lt;/code&gt;属性，也可以用&lt;code&gt;getAttribute(&#39;data-foo&#39;)&lt;/code&gt;、&lt;code&gt;removeAttribute(&#39;data-foo&#39;)&lt;/code&gt;、&lt;code&gt;setAttribute(&#39;data-foo&#39;)&lt;/code&gt;、&lt;code&gt;hasAttribute(&#39;data-foo&#39;)&lt;/code&gt;等方法操作&lt;code&gt;data-*&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;code&gt;dataset&lt;/code&gt;属性使用骆驼拼写法表示属性名，这意味着&lt;code&gt;data-hello-world&lt;/code&gt;会用&lt;code&gt;dataset.helloWorld&lt;/code&gt;表示。而如果此时存在一个&lt;code&gt;data-helloWorld&lt;/code&gt;属性，该属性将无法读取，也就是说，&lt;code&gt;data-*&lt;/code&gt;属性本身只能使用连词号，不能使用骆驼拼写法。&lt;/p&gt;

&lt;h3 id=&#34;tabindex属性:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;tabindex属性&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tabindex&lt;/code&gt;属性用来指定，当前HTML元素节点是否被tab键遍历，以及遍历的优先级。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var b1 = document.getElementById(&amp;quot;button1&amp;quot;);

b1.tabIndex = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 tabindex = -1 ，tab键跳过当前元素。&lt;/p&gt;

&lt;p&gt;如果 tabindex = 0 ，表示tab键将遍历当前元素。如果一个元素没有设置tabindex，默认值就是0。&lt;/p&gt;

&lt;p&gt;如果 tabindex 大于0，表示tab键优先遍历。值越大，就表示优先级越大。&lt;/p&gt;

&lt;h3 id=&#34;页面位置相关属性:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;页面位置相关属性&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;（1）offsetParent属性、offsetTop属性和offsetLeft属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这三个属性提供Element对象在页面上的位置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;offsetParent：当前HTML元素的最靠近的、并且CSS的position属性不等于static的父元素。&lt;/li&gt;
&lt;li&gt;offsetTop：当前HTML元素左上角相对于offsetParent的垂直位移。&lt;/li&gt;
&lt;li&gt;offsetLeft：当前HTML元素左上角相对于offsetParent的水平位移。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果Element对象的父对象都没有将position属性设置为非static的值（比如absolute或relative），则offsetParent属性指向body元素。另外，计算offsetTop和offsetLeft的时候，是从边框的左上角开始计算，即Element对象的border宽度不计入offsetTop和offsetLeft。&lt;/p&gt;

&lt;h3 id=&#34;style属性:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;style属性&lt;/h3&gt;

&lt;p&gt;style属性用来读写页面元素的行内CSS属性，详见本章《CSS操作》一节。&lt;/p&gt;

&lt;h3 id=&#34;element对象的方法:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;Element对象的方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;（1）选择子元素的方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Element对象也部署了document对象的4个选择子元素的方法，而且用法完全一样。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;querySelector方法&lt;/li&gt;
&lt;li&gt;querySelectorAll方法&lt;/li&gt;
&lt;li&gt;getElementsByTagName方法&lt;/li&gt;
&lt;li&gt;getElementsByClassName方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面四个方法只用于选择Element对象的子节点。因此，可以采用链式写法来选择子节点。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;document.getElementById(&amp;lsquo;header&amp;rsquo;).getElementsByClassName(&amp;lsquo;a&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;各大浏览器对这四个方法都支持良好，IE的情况如下：IE 6开始支持getElementsByTagName，IE 8开始支持querySelector和querySelectorAll，IE 9开始支持getElementsByClassName。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）elementFromPoint方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该方法用于选择在指定坐标的最上层的Element对象。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;document.elementFromPoint(50,50)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码了选中在(50,50)这个坐标的最上层的那个HTML元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）HTML元素的属性相关方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;hasAttribute()：返回一个布尔值，表示Element对象是否有该属性。&lt;/li&gt;
&lt;li&gt;getAttribute()&lt;/li&gt;
&lt;li&gt;setAttribute()&lt;/li&gt;
&lt;li&gt;removeAttribute()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（4）matchesSelector方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该方法返回一个布尔值，表示Element对象是否符合某个CSS选择器。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;document.querySelector(&amp;lsquo;li&amp;rsquo;).matchesSelector(&amp;lsquo;li:first-child&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;这个方法需要加上浏览器前缀，需要写成mozMatchesSelector()、webkitMatchesSelector()、oMatchesSelector()、msMatchesSelector()。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）focus方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;focus方法用于将当前页面的焦点，转移到指定元素上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
document.getElementById(&#39;my-span&#39;).focus();

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;table元素:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;table元素&lt;/h3&gt;

&lt;p&gt;表格有一些特殊的DOM操作方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;insertRow()&lt;/strong&gt;：在指定位置插入一个新行（tr）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteRow()&lt;/strong&gt;：在指定位置删除一行（tr）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;insertCell()&lt;/strong&gt;：在指定位置插入一个单元格（td）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteCell()&lt;/strong&gt;：在指定位置删除一个单元格（td）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;createCaption()&lt;/strong&gt;：插入标题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteCaption()&lt;/strong&gt;：删除标题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;createTHead()&lt;/strong&gt;：插入表头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deleteTHead()&lt;/strong&gt;：删除表头。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是使用JavaScript生成表格的一个例子。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var table = document.createElement(&amp;lsquo;table&amp;rsquo;);
var tbody = document.createElement(&amp;lsquo;tbody&amp;rsquo;);
table.appendChild(tbody);&lt;/p&gt;

&lt;p&gt;for (var i = 0; i &amp;lt;= 9; i++) {
  var rowcount = i + 1;
  tbody.insertRow(i);
  tbody.rows[i].insertCell(0);
  tbody.rows[i].insertCell(1);
  tbody.rows[i].insertCell(2);
  tbody.rows[i].cells[0].appendChild(document.createTextNode(&amp;lsquo;Row &amp;rsquo; + rowcount + &amp;lsquo;, Cell 1&amp;rsquo;));
  tbody.rows[i].cells[1].appendChild(document.createTextNode(&amp;lsquo;Row &amp;rsquo; + rowcount + &amp;lsquo;, Cell 2&amp;rsquo;));
  tbody.rows[i].cells[2].appendChild(document.createTextNode(&amp;lsquo;Row &amp;rsquo; + rowcount + &amp;lsquo;, Cell 3&amp;rsquo;));
}&lt;/p&gt;

&lt;p&gt;table.createCaption();
table.caption.appendChild(document.createTextNode(&amp;lsquo;A DOM-Generated Table&amp;rsquo;));&lt;/p&gt;

&lt;p&gt;document.body.appendChild(table);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;这些代码相当易读，其中需要注意的就是insertRow和insertCell方法，接受一个表示位置的参数（从0开始的整数）。&lt;/p&gt;

&lt;p&gt;table元素有以下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;caption&lt;/strong&gt;：标题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tHead&lt;/strong&gt;：表头。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tFoot&lt;/strong&gt;：表尾。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rows&lt;/strong&gt;：行元素对象，该属性只读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rows.cells&lt;/strong&gt;：每一行的单元格对象，该属性只读。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tBodies&lt;/strong&gt;：表体，该属性只读。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接:dd7fae954a9b447bf4fe5c78ba055278&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Louis Lazaris, &lt;a href=&#34;http://coding.smashingmagazine.com/2013/10/06/inside-the-box-with-vanilla-javascript/&#34;&gt;Thinking Inside The Box With Vanilla JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;David Walsh, &lt;a href=&#34;http://davidwalsh.name/classlist&#34;&gt;HTML5 classList API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Derek Johnson, &lt;a href=&#34;http://html5doctor.com/the-classlist-api/&#34;&gt;The classList API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mozilla Developer Network, &lt;a href=&#34;http://davidwalsh.name/element-dataset&#34;&gt;element.dataset API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;David Walsh, &lt;a href=&#34;http://davidwalsh.name/element-dataset&#34;&gt;The element.dataset API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6、浏览器对象</title>
      <link>http://575087694.github.io/post/index6/</link>
      <pubDate>Sun, 26 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index6/</guid>
      <description>

&lt;h2 id=&#34;浏览器的组成:38c4027fdf723250a63396550bf8d069&#34;&gt;浏览器的组成&lt;/h2&gt;

&lt;p&gt;浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。&lt;/p&gt;

&lt;p&gt;（1）渲染引擎&lt;/p&gt;

&lt;p&gt;渲染引擎的主要作用是，将网页从代码”渲染“为用户视觉上可以感知的平面文档。不同的浏览器有不同的渲染引擎。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Firefox：Gecko引擎&lt;/li&gt;
&lt;li&gt;Safari：WebKit引擎&lt;/li&gt;
&lt;li&gt;Chrome：Blink引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;渲染引擎处理网页，通常分成四个阶段。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）&lt;/li&gt;
&lt;li&gt;对象合成：将DOM和CSSOM合成一棵渲染树（render tree）&lt;/li&gt;
&lt;li&gt;布局：计算出渲染树的布局（layout）&lt;/li&gt;
&lt;li&gt;绘制：将渲染树绘制到屏幕&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的HTML代码还没下载完，但浏览器已经显示出内容了。&lt;/p&gt;

&lt;p&gt;（2）JavaScript引擎&lt;/p&gt;

&lt;p&gt;JavaScript引擎的主要作用是，读取网页中的JavaScript代码，对其处理后运行。&lt;/p&gt;

&lt;p&gt;本节主要介绍JavaScript引擎的工作方式。&lt;/p&gt;

&lt;h2 id=&#34;javascript代码嵌入网页的方法:38c4027fdf723250a63396550bf8d069&#34;&gt;JavaScript代码嵌入网页的方法&lt;/h2&gt;

&lt;p&gt;JavaScript代码只有嵌入网页，才能运行。网页中嵌入JavaScript代码有多种方法。&lt;/p&gt;

&lt;h3 id=&#34;直接添加代码块:38c4027fdf723250a63396550bf8d069&#34;&gt;直接添加代码块&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，可以直接将JavaScript代码嵌入网页。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script&amp;gt;
// some JavaScript code
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签有一个&lt;code&gt;type&lt;/code&gt;属性，用来指定脚本类型。不过，如果嵌入的是JavaScript脚本，HTML5推荐&lt;code&gt;type&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;对JavaScript脚本来说，&lt;code&gt;type&lt;/code&gt;属性可以设为两种值。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;text/javascript&lt;/code&gt;：这是默认值，也是历史上一贯设定的值。如果你省略&lt;code&gt;type&lt;/code&gt;属性，默认就是这个值。对于老式浏览器，设为这个值比较好。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;application/javascript&lt;/code&gt;：对于较新的浏览器，建议设为这个值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;加载外部脚本:38c4027fdf723250a63396550bf8d069&#34;&gt;加载外部脚本&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;script&lt;/code&gt;标签也可以指定加载外部的脚本文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果脚本文件使用了非英语字符，还应该注明编码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script charset=&amp;quot;utf-8&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的&lt;code&gt;console.log&lt;/code&gt;语句直接被忽略。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script charset=&amp;quot;utf-8&amp;quot; src=&amp;quot;example.js&amp;quot;&amp;gt;
  console.log(&#39;Hello World!&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;行内代码:38c4027fdf723250a63396550bf8d069&#34;&gt;行内代码&lt;/h3&gt;

&lt;p&gt;除了上面两种方法，HTML语言允许在某些元素的事件属性和&lt;code&gt;a&lt;/code&gt;元素的&lt;code&gt;href&lt;/code&gt;属性中，直接写入JavaScript。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div onclick=&amp;quot;alert(&#39;Hello&#39;)&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;a href=&amp;quot;javascript:alert(&#39;Hello&#39;)&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法将HTML代码与JavaScript代码混写在一起，非常不利于代码管理，不建议使用。&lt;/p&gt;

&lt;h2 id=&#34;script标签的工作原理:38c4027fdf723250a63396550bf8d069&#34;&gt;script标签的工作原理&lt;/h2&gt;

&lt;p&gt;正常的网页加载流程是这样的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器一边下载HTML网页，一边开始解析&lt;/li&gt;
&lt;li&gt;解析过程中，发现script标签&lt;/li&gt;
&lt;li&gt;暂停解析，网页渲染的控制权转交给JavaScript引擎&lt;/li&gt;
&lt;li&gt;如果script标签引用了外部脚本，就下载该脚本，否则就直接执行&lt;/li&gt;
&lt;li&gt;执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也就是说，加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是JavaScript可以修改DOM（比如使用&lt;code&gt;document.write&lt;/code&gt;方法），所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。&lt;/p&gt;

&lt;p&gt;如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。&lt;/p&gt;

&lt;p&gt;为了避免这种情况，较好的做法是将script标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。&lt;/p&gt;

&lt;p&gt;如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码嵌入页面，而不是连接外部脚本文件，这样能缩短加载时间。&lt;/p&gt;

&lt;p&gt;将脚本文件都放在网页尾部加载，还有一个好处。在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;head&amp;gt;
  &amp;lt;script&amp;gt;
    console.log(document.body.innerHTML);
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行时会报错，因为此时&lt;code&gt;body&lt;/code&gt;元素还未生成。&lt;/p&gt;

&lt;p&gt;一种解决方法是设定&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;head&amp;gt;
  &amp;lt;script&amp;gt;
    document.addEventListener(
      &#39;DOMContentLoaded&#39;,
      function(event) {
        console.log(document.body.innerHTML);
      }
    );
  &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种解决方法是，使用&lt;code&gt;script&lt;/code&gt;标签的&lt;code&gt;onload&lt;/code&gt;属性。当script标签指定的外部脚本文件下载和解析完成，会触发一个load事件，可以把所需执行的代码，放在这个事件的回调函数里面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;jquery.min.js&amp;quot; onload=&amp;quot;console.log(document.body.innerHTML)&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;body&amp;gt;
  &amp;lt;!-- 其他代码  --&amp;gt;
  &amp;lt;script&amp;gt;
    console.log(document.body.innerHTML);
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有多个script标签，比如下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器会同时平行下载&lt;code&gt;1.js&lt;/code&gt;和&lt;code&gt;2.js&lt;/code&gt;，但是，执行时会保证先执行&lt;code&gt;1.js&lt;/code&gt;，然后再执行&lt;code&gt;2.js&lt;/code&gt;，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。&lt;/p&gt;

&lt;p&gt;当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。&lt;/p&gt;

&lt;p&gt;Gecko和Webkit引擎在网页被阻塞后，会生成第二个线程解析文档，下载外部资源，但是不会修改DOM，网页还是处于阻塞状态。&lt;/p&gt;

&lt;p&gt;解析和执行CSS，也会产生阻塞。Firefox会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本执行，等到样式表下载并解析完，再恢复执行。&lt;/p&gt;

&lt;p&gt;此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般最多同时下载六个（IE11允许同时下载13个）。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。&lt;/p&gt;

&lt;h2 id=&#34;defer属性:38c4027fdf723250a63396550bf8d069&#34;&gt;defer属性&lt;/h2&gt;

&lt;p&gt;为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入defer属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;1.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;2.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;属性的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器开始解析HTML网页&lt;/li&gt;
&lt;li&gt;解析过程中，发现带有&lt;code&gt;defer&lt;/code&gt;属性的script标签&lt;/li&gt;
&lt;li&gt;浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本&lt;/li&gt;
&lt;li&gt;浏览器完成解析HTML网页，此时再执行下载的脚本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了&lt;code&gt;defer&lt;/code&gt;属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件触发前执行（即刚刚读取完&lt;code&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;标签），而且可以保证执行顺序就是它们在页面上出现的顺序。&lt;/p&gt;

&lt;p&gt;对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，&lt;code&gt;defer&lt;/code&gt;属性不起作用。&lt;/p&gt;

&lt;h2 id=&#34;async属性:38c4027fdf723250a63396550bf8d069&#34;&gt;async属性&lt;/h2&gt;

&lt;p&gt;解决“阻塞效应”的另一个方法是加入&lt;code&gt;async&lt;/code&gt;属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;1.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;2.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;async&lt;/code&gt;属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器开始解析HTML网页&lt;/li&gt;
&lt;li&gt;解析过程中，发现带有&lt;code&gt;async&lt;/code&gt;属性的&lt;code&gt;script&lt;/code&gt;标签&lt;/li&gt;
&lt;li&gt;浏览器继续往下解析HTML网页，同时并行下载&lt;code&gt;script&lt;/code&gt;标签中的外部脚本&lt;/li&gt;
&lt;li&gt;脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本&lt;/li&gt;
&lt;li&gt;脚本执行完毕，浏览器恢复解析HTML网页&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;async&lt;/code&gt;属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用&lt;code&gt;async&lt;/code&gt;属性的脚本文件中，不应该使用&lt;code&gt;document.write&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;defer&lt;/code&gt;属性和&lt;code&gt;async&lt;/code&gt;属性到底应该使用哪一个？&lt;/p&gt;

&lt;p&gt;一般来说，如果脚本之间没有依赖关系，就使用&lt;code&gt;async&lt;/code&gt;属性，如果脚本之间有依赖关系，就使用&lt;code&gt;defer&lt;/code&gt;属性。如果同时使用&lt;code&gt;async&lt;/code&gt;和&lt;code&gt;defer&lt;/code&gt;属性，后者不起作用，浏览器行为由&lt;code&gt;async&lt;/code&gt;属性决定。&lt;/p&gt;

&lt;h2 id=&#34;重流和重绘:38c4027fdf723250a63396550bf8d069&#34;&gt;重流和重绘&lt;/h2&gt;

&lt;p&gt;渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。&lt;/p&gt;

&lt;p&gt;页面生成以后，脚本操作和样式表操作，都会触发重流（reflow）和重绘（repaint）。用户的互动，也会触发，比如设置了鼠标悬停（&lt;code&gt;a:hover&lt;/code&gt;）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。&lt;/p&gt;

&lt;p&gt;重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。&lt;/p&gt;

&lt;p&gt;大多数情况下，浏览器会智能判断，将“重流”和“重绘”只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。&lt;/p&gt;

&lt;p&gt;作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的DOM元素，而以底层DOM元素的变动代替；再比如，重绘table布局和flex布局，开销都会比较大。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = document.getElementById(‘foobar’);

foo.style.color = ‘blue’;
foo.style.marginTop = ‘30px’;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码只会导致一次重绘，因为浏览器会累积DOM变动，然后一次性执行。&lt;/p&gt;

&lt;p&gt;下面的代码则会导致两次重绘。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = document.getElementById(‘foobar’);

foo.style.color = ‘blue’;
var margin = parseInt(foo.style.marginTop);
foo.style.marginTop = (margin + 10) + ‘px’;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一些优化技巧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;读取DOM或者写入DOM，尽量写在一起，不要混杂&lt;/li&gt;
&lt;li&gt;缓存DOM信息&lt;/li&gt;
&lt;li&gt;不要一项一项地改变样式，而是使用CSS class一次性改变样式&lt;/li&gt;
&lt;li&gt;使用document fragment操作DOM&lt;/li&gt;
&lt;li&gt;动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响&lt;/li&gt;
&lt;li&gt;只在必要时才显示元素&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流&lt;/li&gt;
&lt;li&gt;使用虚拟DOM（virtual DOM）库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是一个&lt;code&gt;window.requestAnimationFrame()&lt;/code&gt;对比效果的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 重绘代价高
function doubleHeight(element) {
  var currentHeight = element.clientHeight;
  element.style.height = (currentHeight * 2) + ‘px’;
}

all_my_elements.forEach(doubleHeight);

// 重绘代价低
function doubleHeight(element) {
  var currentHeight = element.clientHeight;

  window.requestAnimationFrame(function () {
    element.style.height = (currentHeight * 2) + ‘px’;
  });
}

all_my_elements.forEach(doubleHeight);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;脚本的动态嵌入:38c4027fdf723250a63396550bf8d069&#34;&gt;脚本的动态嵌入&lt;/h2&gt;

&lt;p&gt;除了用静态的&lt;code&gt;script&lt;/code&gt;标签，还可以动态嵌入&lt;code&gt;script&lt;/code&gt;标签。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;1.js&#39;, &#39;2.js&#39;].forEach(function(src) {
  var script = document.createElement(&#39;script&#39;);
  script.src = src;
  document.head.appendChild(script);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法的好处是，动态生成的&lt;code&gt;script&lt;/code&gt;标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。&lt;/p&gt;

&lt;p&gt;如果想避免这个问题，可以设置async属性为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;1.js&#39;, &#39;2.js&#39;].forEach(function(src) {
  var script = document.createElement(&#39;script&#39;);
  script.src = src;
  script.async = false;
  document.head.appendChild(script);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码依然不会阻塞页面渲染，而且可以保证&lt;code&gt;2.js&lt;/code&gt;在&lt;code&gt;1.js&lt;/code&gt;后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待&lt;code&gt;2.js&lt;/code&gt;执行完成后再执行。&lt;/p&gt;

&lt;p&gt;我们可以把上面的写法，封装成一个函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function() {
  var scripts = document.getElementsByTagName(&#39;script&#39;)[0];
  function load(url) {
    var script = document.createElement(&#39;script&#39;);
    script.async = true;
    script.src = url;
    scripts.parentNode.insertBefore(script, scripts);
  }
  load(&#39;//apis.google.com/js/plusone.js&#39;);
  load(&#39;//platform.twitter.com/widgets.js&#39;);
  load(&#39;//s.thirdpartywidget.com/widget.js&#39;);
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;async&lt;/code&gt;属性设为&lt;code&gt;true&lt;/code&gt;，是因为加载的脚本没有互相依赖关系。而且，这样就不会造成堵塞。&lt;/p&gt;

&lt;p&gt;此外，动态嵌入还有一个地方需要注意。动态嵌入必须等待CSS文件加载完成后，才会去下载外部脚本文件。静态加载就不存在这个问题，&lt;code&gt;script&lt;/code&gt;标签指定的外部脚本文件，都是与CSS文件同时并发下载的。&lt;/p&gt;

&lt;h2 id=&#34;加载使用的协议:38c4027fdf723250a63396550bf8d069&#34;&gt;加载使用的协议&lt;/h2&gt;

&lt;p&gt;如果不指定协议，浏览器默认采用HTTP协议下载。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的&lt;code&gt;example.js&lt;/code&gt;默认就是采用HTTP协议下载，如果要采用HTTPs协议下载，必需写明（假定服务器支持）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;https://example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;//example.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;javascript虚拟机:38c4027fdf723250a63396550bf8d069&#34;&gt;JavaScript虚拟机&lt;/h2&gt;

&lt;p&gt;JavaScript是一种解释型语言，也就是说，它不需要编译，可以由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。为了提高运行速度，目前的浏览器都将JavaScript进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。&lt;/p&gt;

&lt;p&gt;早期，浏览器内部对JavaScript的处理过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。&lt;/li&gt;
&lt;li&gt;对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。&lt;/li&gt;
&lt;li&gt;使用“翻译器”（translator），将代码转为字节码（bytecode）。&lt;/li&gt;
&lt;li&gt;使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。&lt;/p&gt;

&lt;p&gt;不同的浏览器有不同的编译策略。有的浏览器只编译最经常用到的部分，比如循环的部分；有的浏览器索性省略了字节码的翻译步骤，直接编译成机器码，比如chrome浏览器的V8引擎。&lt;/p&gt;

&lt;p&gt;字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为JavaScript引擎。因为JavaScript运行时未必有字节码，所以JavaScript虚拟机并不完全基于字节码，而是部分基于源码，即只要有可能，就通过JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些JavaScript虚拟机：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Chakra_(JScript_engine)&#34;&gt;Chakra&lt;/a&gt;(Microsoft Internet Explorer)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/WebKit#JavaScriptCore&#34;&gt;Nitro/JavaScript Core&lt;/a&gt; (Safari)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dev.opera.com/articles/view/labs-carakan/&#34;&gt;Carakan&lt;/a&gt; (Opera)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/SpiderMonkey&#34;&gt;SpiderMonkey&lt;/a&gt; (Firefox)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/V8_(JavaScript_engine)&#34;&gt;V8&lt;/a&gt; (Chrome, Chromium)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;单线程模型:38c4027fdf723250a63396550bf8d069&#34;&gt;单线程模型&lt;/h2&gt;

&lt;h3 id=&#34;含义:38c4027fdf723250a63396550bf8d069&#34;&gt;含义&lt;/h3&gt;

&lt;p&gt;首先，明确一个观念：JavaScript只在一个线程上运行，不代表JavaScript引擎只有一个线程。事实上，JavaScript引擎有多个线程，其中单个脚本只能在一个线程上运行，其他线程都是在后台配合。JavaScript脚本在一个线程里运行。这意味着，一次只能运行一个任务，其他任务都必须在后面排队等待。&lt;/p&gt;

&lt;p&gt;JavaScript之所以采用单线程，而不是多线程，跟历史有关系。JavaScript从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。&lt;/p&gt;

&lt;p&gt;为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。&lt;/p&gt;

&lt;p&gt;单线程模型带来了一些问题，主要是新的任务被加在队列的尾部，只有前面的所有任务运行结束，才会轮到它执行。如果有一个任务特别耗时，后面的任务都会停在那里等待，造成浏览器失去响应，又称“假死”。为了避免“假死”，当某个操作在一定时间后仍无法结束，浏览器就会跳出提示框，询问用户是否要强行停止脚本运行。&lt;/p&gt;

&lt;p&gt;如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript语言的设计者意识到，这时CPU完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是JavaScript内部采用的Event Loop。&lt;/p&gt;

&lt;h3 id=&#34;消息队列:38c4027fdf723250a63396550bf8d069&#34;&gt;消息队列&lt;/h3&gt;

&lt;p&gt;JavaScript运行时，除了一根运行线程，系统还提供一个消息队列（message queue），里面是各种需要当前程序处理的消息。新的消息进入队列的时候，会自动排在队列的尾端。&lt;/p&gt;

&lt;p&gt;运行线程只要发现消息队列不为空，就会取出排在第一位的那个消息，执行它对应的回调函数。等到执行完，再取出排在第二位的消息，不断循环，直到消息队列变空为止。&lt;/p&gt;

&lt;p&gt;每条消息与一个回调函数相联系，也就是说，程序只要收到这条消息，就会执行对应的函数。另一方面，进入消息队列的消息，必须有对应的回调函数。否则这个消息就会遗失，不会进入消息队列。举例来说，鼠标点击就会产生一条消息，报告&lt;code&gt;click&lt;/code&gt;事件发生了。如果没有回调函数，这个消息就遗失了。如果有回调函数，这个消息进入消息队列。等到程序收到这个消息，就会执行click事件的回调函数。&lt;/p&gt;

&lt;p&gt;另一种情况是&lt;code&gt;setTimeout&lt;/code&gt;会在指定时间向消息队列添加一条消息。如果消息队列之中，此时没有其他消息，这条消息会立即得到处理；否则，这条消息会不得不等到其他消息处理完，才会得到处理。因此，&lt;code&gt;setTimeout&lt;/code&gt;指定的执行时间，只是一个最早可能发生的时间，并不能保证一定会在那个时间发生。&lt;/p&gt;

&lt;p&gt;一旦当前执行栈空了，消息队列就会取出排在第一位的那条消息，传入程序。程序开始执行对应的回调函数，等到执行完，再处理下一条消息。&lt;/p&gt;

&lt;h3 id=&#34;event-loop:38c4027fdf723250a63396550bf8d069&#34;&gt;Event Loop&lt;/h3&gt;

&lt;p&gt;所谓Event Loop，指的是一种内部循环，用来一轮又一轮地处理消息队列之中的消息，即执行对应的回调函数。&lt;a href=&#34;http://en.wikipedia.org/wiki/Event_loop&#34;&gt;Wikipedia&lt;/a&gt;的定义是：“&lt;strong&gt;Event Loop是一个程序结构，用于等待和发送消息和事件&lt;/strong&gt;（a programming construct that waits for and dispatches events or messages in a program）”。可以就把Event Loop理解成动态更新的消息队列本身。&lt;/p&gt;

&lt;p&gt;下面是一些常见的JavaScript任务。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行JavaScript代码&lt;/li&gt;
&lt;li&gt;对用户的输入（包含鼠标点击、键盘输入等等）做出反应&lt;/li&gt;
&lt;li&gt;处理异步的网络请求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在JavaScript执行进程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入JavaScript执行进程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入JavaScript进程执行。&lt;/p&gt;

&lt;p&gt;以Ajax操作为例，它可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着Ajax操作返回结果，再往下执行；如果是异步任务，该任务直接进入“任务队列”，JavaScript进程跳过Ajax操作，直接往下执行，等到Ajax操作有了结果，JavaScript进程再执行对应的回调函数。&lt;/p&gt;

&lt;p&gt;也就是说，虽然JavaScript只有一根进程用来执行，但是并行的还有其他进程（比如，处理定时器的进程、处理用户输入的进程、处理网络通信的进程等等）。这些进程通过向任务队列添加任务，实现与JavaScript进程通信。&lt;/p&gt;

&lt;p&gt;想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做&amp;rdquo;进程&amp;rdquo;（process），一般情况下，一个进程一次只能执行一个任务。如果有很多任务需要执行，不外乎三种解决方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;排队。&lt;/strong&gt;因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;新建进程。&lt;/strong&gt;使用fork命令，为每个任务新建一个进程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;新建线程。&lt;/strong&gt;因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201310/2013102002.png&#34; alt=&#34;synchronous mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图的绿色部分是程序的运行时间，红色部分是等待时间。可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为&amp;rdquo;同步模式&amp;rdquo;（synchronous I/O）。&lt;/p&gt;

&lt;p&gt;如果采用多线程，同时运行多个任务，那很可能就是下面这样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201310/2013102003.png&#34; alt=&#34;synchronous mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图表明，多线程不仅占用多倍的系统资源，也闲置多倍的资源，这显然不合理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.beekka.com/blog/201310/2013102004.png&#34; alt=&#34;asynchronous mode&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。&lt;/p&gt;

&lt;p&gt;可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为&amp;rdquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Asynchronous_I/O&#34;&gt;异步模式&lt;/a&gt;&amp;ldquo;（asynchronous I/O）。&lt;/p&gt;

&lt;p&gt;这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。&lt;/p&gt;

&lt;p&gt;如果有大量的异步任务（实际情况就是这样），它们会在“消息队列”中产生大量的消息。这些消息排成队，等候进入主线程。本质上，“消息队列”就是一个“先进先出”的数据结构。比如，点击鼠标就产生一系列消息（各种事件），&lt;code&gt;mousedown&lt;/code&gt;事件排在&lt;code&gt;mouseup&lt;/code&gt;事件前面，&lt;code&gt;mouseup&lt;/code&gt;事件又排在&lt;code&gt;click&lt;/code&gt;事件的前面。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:38c4027fdf723250a63396550bf8d069&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;John Dalziel, &lt;a href=&#34;http://creativejs.com/2013/06/the-race-for-speed-part-2-how-javascript-compilers-work/&#34;&gt;The race for speed part 2: How JavaScript compilers work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jake Archibald，&lt;a href=&#34;http://www.html5rocks.com/en/tutorials/speed/script-loading/&#34;&gt;Deep dive into the murky waters of script loading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mozilla Developer Network, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/window.setTimeout&#34;&gt;window.setTimeout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Remy Sharp, &lt;a href=&#34;http://remysharp.com/2010/07/21/throttling-function-calls/&#34;&gt;Throttling function calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ayman Farhat, &lt;a href=&#34;http://www.thecodeship.com/web-development/alternative-to-javascript-evil-setinterval/&#34;&gt;An alternative to Javascript&amp;rsquo;s evil setInterval&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ilya Grigorik, &lt;a href=&#34;https://www.igvita.com/2014/05/20/script-injected-async-scripts-considered-harmful/&#34;&gt;Script-injected &amp;ldquo;async scripts&amp;rdquo; considered harmful&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2014/09/es6-promises-foundations.html&#34;&gt;ECMAScript 6 promises (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;): foundations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Daniel Imms, &lt;a href=&#34;http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html&#34;&gt;async vs defer attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Craig Buckler, &lt;a href=&#34;http://www.sitepoint.com/non-blocking-async-defer/&#34;&gt;Load Non-blocking JavaScript with HTML5 Async and Defer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Domenico De Felice, &lt;a href=&#34;http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html?t=2&#34;&gt;How browsers work&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>7、HTML网页元素</title>
      <link>http://575087694.github.io/post/index8/</link>
      <pubDate>Sat, 25 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index8/</guid>
      <description>

&lt;h2 id=&#34;image元素:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;image元素&lt;/h2&gt;

&lt;h3 id=&#34;alt属性-src属性:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;alt属性，src属性&lt;/h3&gt;

&lt;p&gt;alt属性返回image元素的HTML标签的alt属性值，src属性返回image元素的HTML标签的src属性值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
// 方法一：HTML5构造函数Image
var img1 = new Image(); 
img1.src = &#39;image1.png&#39;;
img1.alt = &#39;alt&#39;;
document.body.appendChild(img1);

// 方法二：DOM HTMLImageElement
var img2 = document.createElement(&#39;img&#39;); 
img2.src = &#39;image2.jpg&#39;;
img2.alt = &#39;alt text&#39;;
document.body.appendChild(img2);

document.images[0].src
// image1.png

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;complete属性:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;complete属性&lt;/h3&gt;

&lt;p&gt;complete属性返回一个布尔值，true表示当前图像属于浏览器支持的图形类型，并且加载完成，解码过程没有出错，否则就返回false。&lt;/p&gt;

&lt;h3 id=&#34;height属性-width属性:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;height属性，width属性&lt;/h3&gt;

&lt;p&gt;这两个属性返回image元素被浏览器渲染后的高度和宽度。&lt;/p&gt;

&lt;h3 id=&#34;naturalwidth属性-naturalheight属性:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;naturalWidth属性，naturalHeight属性&lt;/h3&gt;

&lt;p&gt;这两个属性只读，表示image对象真实的宽度和高度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
myImage.addEventListener(&#39;onload&#39;, function() {
    console.log(&#39;My width is: &#39;, this.naturalWidth);
    console.log(&#39;My height is: &#39;, this.naturalHeight);
});

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;audio元素-video元素:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;audio元素，video元素&lt;/h2&gt;

&lt;p&gt;audio元素和video元素加载音频和视频时，以下事件按次序发生。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;loadstart：开始加载音频和视频。&lt;/li&gt;
&lt;li&gt;durationchange：音频和视频的duration属性（时长）发生变化时触发，即已经知道媒体文件的长度。如果没有指定音频和视频文件，duration属性等于NaN。如果播放流媒体文件，没有明确的结束时间，duration属性等于Inf（Infinity）。&lt;/li&gt;
&lt;li&gt;loadedmetadata：媒体文件的元数据加载完毕时触发，元数据包括duration（时长）、dimensions（大小，视频独有）和文字轨。&lt;/li&gt;
&lt;li&gt;loadeddata：媒体文件的第一帧加载完毕时触发，此时整个文件还没有加载完。&lt;/li&gt;
&lt;li&gt;progress：浏览器正在下载媒体文件，周期性触发。下载信息保存在元素的buffered属性中。&lt;/li&gt;
&lt;li&gt;canplay：浏览器准备好播放，即使只有几帧，readyState属性变为CAN_PLAY。&lt;/li&gt;
&lt;li&gt;canplaythrough：浏览器认为可以不缓冲（buffering）播放时触发，即当前下载速度保持不低于播放速度，readyState属性变为CAN_PLAY_THROUGH。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了上面这些事件，audio元素和video元素还支持以下事件。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;触发条件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;abort&lt;/td&gt;
&lt;td&gt;播放中断&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;emptied&lt;/td&gt;
&lt;td&gt;媒体文件加载后又被清空，比如加载后又调用load方法重新加载。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ended&lt;/td&gt;
&lt;td&gt;播放结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;发生错误。该元素的error属性包含更多信息。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pause&lt;/td&gt;
&lt;td&gt;播放暂停&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;play&lt;/td&gt;
&lt;td&gt;暂停后重新开始播放&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;playing&lt;/td&gt;
&lt;td&gt;开始播放，包括第一次播放、暂停后播放、结束后重新播放。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ratechange&lt;/td&gt;
&lt;td&gt;播放速率改变&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;seeked&lt;/td&gt;
&lt;td&gt;搜索操作结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;seeking&lt;/td&gt;
&lt;td&gt;搜索操作开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;stalled&lt;/td&gt;
&lt;td&gt;浏览器开始尝试读取媒体文件，但是没有如预期那样获取数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;suspend&lt;/td&gt;
&lt;td&gt;加载文件停止，有可能是播放结束，也有可能是其他原因的暂停&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;timeupdate&lt;/td&gt;
&lt;td&gt;网页元素的currentTime属性改变时触发。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;volumechange&lt;/td&gt;
&lt;td&gt;音量改变时触发（包括静音）。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;waiting&lt;/td&gt;
&lt;td&gt;由于另一个操作（比如搜索）还没有结束，导致当前操作（比如播放）不得不等待。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;iframe:82cc1ad2784bf3bfb52f6c6df1080566&#34;&gt;iframe&lt;/h2&gt;

&lt;p&gt;iframe元素用于在网页之中，插入另一张网页。对于JavaScript来说，每一个iframe，构成一个单独的域，不同的域之间的变量是隔离的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var iframe = frames[0];
Array === iframe.Array; // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;frames[0]&lt;/code&gt;表示第一个&lt;code&gt;iframe&lt;/code&gt;框架，它的&lt;code&gt;Array&lt;/code&gt;和父页面的&lt;code&gt;Array&lt;/code&gt;是不一样的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8、开发工具</title>
      <link>http://575087694.github.io/post/index7/</link>
      <pubDate>Fri, 24 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index7/</guid>
      <description>

&lt;p&gt;&lt;code&gt;console&lt;/code&gt;对象是JavaScript的原生对象，它有点像Unix系统的标准输出&lt;code&gt;stdout&lt;/code&gt;和标准错误&lt;code&gt;stderr&lt;/code&gt;，可以输出各种信息用来调试程序，而且还提供了很多额外的方法，供开发者调用。它的常见用途有两个。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;显示网页代码运行时的错误信息。&lt;/li&gt;
&lt;li&gt;提供了一个命令行接口，用来与网页代码互动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;浏览器实现:93028a78a5be4722529cc12afbd69c79&#34;&gt;浏览器实现&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;console&lt;/code&gt;对象的浏览器实现，包含在浏览器自带的开发工具之中。以Chrome浏览器的“开发者工具”（Developer Tools）为例，首先使用下面三种方法的一种打开它。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按F12或者&lt;code&gt;Control + Shift + i&lt;/code&gt;（PC平台）/ &lt;code&gt;Alt + Command + i&lt;/code&gt;（Mac平台）。&lt;/li&gt;
&lt;li&gt;在菜单中选择“工具/开发者工具”。&lt;/li&gt;
&lt;li&gt;在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/chrome-developer-tools/images/image03.png&#34; alt=&#34;开发者工具&#34; /&gt;&lt;/p&gt;

&lt;p&gt;打开“开发者工具”以后，可以看到在顶端有八个面板卡可供选择，分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Elements&lt;/strong&gt;：用来调试网页的HTML源码和CSS代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Resources&lt;/strong&gt;：查看网页加载的各种资源文件（比如代码文件、字体文件、css文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network&lt;/strong&gt;：查看网页的HTTP通信情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sources&lt;/strong&gt;：调试JavaScript代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Timeline&lt;/strong&gt;：查看各种网页行为随时间变化的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Profiles&lt;/strong&gt;：查看网页的性能情况，比如CPU和内存消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Audits&lt;/strong&gt;：提供网页优化的建议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Console&lt;/strong&gt;：用来运行JavaScript命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这八个面板都有各自的用途。以下内容只针对Console面板，又称为控制台。Console面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。&lt;/p&gt;

&lt;h2 id=&#34;console对象的方法:93028a78a5be4722529cc12afbd69c79&#34;&gt;console对象的方法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;console&lt;/code&gt;对象提供的各种方法，用来与控制台窗口互动。&lt;/p&gt;

&lt;h3 id=&#34;log-info-debug:93028a78a5be4722529cc12afbd69c79&#34;&gt;log()，info()，debug()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;console.log&lt;/code&gt;方法用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&amp;quot;Hello World&amp;quot;)
// Hello World

console.log(&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;)
// a b c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;console.log&lt;/code&gt;方法会自动在每次输出的结尾，添加换行符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(1);
console.log(2);
console.log(3);
// 1
// 2
// 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39; %s + %s = %s&#39;, 1, 1, 2)
//  1 + 1 = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;console.log&lt;/code&gt;方法的第一个参数有三个占位符（&lt;code&gt;%s&lt;/code&gt;），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。&lt;code&gt;console.log&lt;/code&gt;方法支持的占位符格式有以下一些，不同格式的数据必须使用对应格式的占位符。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;%s 字符串&lt;/li&gt;
&lt;li&gt;%d 整数&lt;/li&gt;
&lt;li&gt;%i 整数&lt;/li&gt;
&lt;li&gt;%f 浮点数&lt;/li&gt;
&lt;li&gt;%o 对象的链接&lt;/li&gt;
&lt;li&gt;%c CSS格式字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var number = 11 * 9;
var color = &#39;red&#39;;

console.log(&#39;%d %s balloons&#39;, number, color);
// 99 red balloons
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，第二个参数是数值，对应的占位符是&lt;code&gt;%d&lt;/code&gt;，第三个参数是字符串，对应的占位符是&lt;code&gt;%s&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;%c&lt;/code&gt;占位符时，对应的参数必须是CSS语句，用来对输出内容进行CSS渲染。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;%cThis text is styled!&#39;,
  &#39;color: red; background: yellow; font-size: 24px;&#39;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码运行后，输出的内容将显示为蓝底绿字。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;console.log&lt;/code&gt;方法的两种参数格式，可以结合在一起使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39; %s + %s &#39;, 1, 1, &#39;= 2&#39;)
// 1 + 1  = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果参数是一个对象，&lt;code&gt;console.log&lt;/code&gt;会显示该对象的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log({foo: &#39;bar&#39;})
// Object {foo: &amp;quot;bar&amp;quot;}

console.log(Date)
// function Date() { [native code] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码输出&lt;code&gt;Date&lt;/code&gt;对象的值，结果为一个构造函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;console.info()&lt;/code&gt;和&lt;code&gt;console.debug()&lt;/code&gt;都是&lt;code&gt;console.log&lt;/code&gt;方法的别名，用法完全一样。只不过&lt;code&gt;console.info&lt;/code&gt;方法会在输出信息的前面，加上一个蓝色图标。&lt;/p&gt;

&lt;p&gt;console对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义console.log方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[&#39;log&#39;, &#39;info&#39;, &#39;warn&#39;, &#39;error&#39;].forEach(function(method) {
  console[method] = console[method].bind(
    console,
    new Date().toISOString()
  );
});

console.log(&amp;quot;出错了！&amp;quot;);
// 2014-05-18T09:00.000Z 出错了！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，使用自定义的&lt;code&gt;console.log&lt;/code&gt;方法，可以在显示结果添加当前时间。&lt;/p&gt;

&lt;h3 id=&#34;warn-error:93028a78a5be4722529cc12afbd69c79&#34;&gt;warn()，error()&lt;/h3&gt;

&lt;p&gt;warn方法和error方法也是输出信息，它们与log方法的不同之处在于，warn方法输出信息时，在最前面加一个黄色三角，表示警告；error方法输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。其他用法都一样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.error(&amp;quot;Error: %s (%i)&amp;quot;, &amp;quot;Server is not responding&amp;quot;,500)
// Error: Server is not responding (500)

console.warn(&#39;Warning! Too few nodes (%d)&#39;, document.childNodes.length)
// Warning! Too few nodes (1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本质上，log方法是写入标准输出（stdout），warn方法和error方法是写入标准错误（stderr）。&lt;/p&gt;

&lt;h3 id=&#34;table:93028a78a5be4722529cc12afbd69c79&#34;&gt;table()&lt;/h3&gt;

&lt;p&gt;对于某些复合类型的数据，console.table方法可以将其转为表格显示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var languages = [
  { name: &amp;quot;JavaScript&amp;quot;, fileExtension: &amp;quot;.js&amp;quot; },
  { name: &amp;quot;TypeScript&amp;quot;, fileExtension: &amp;quot;.ts&amp;quot; },
  { name: &amp;quot;CoffeeScript&amp;quot;, fileExtension: &amp;quot;.coffee&amp;quot; }
];

console.table(languages);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的language，转为表格显示如下。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;(index)&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;fileExtension&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&amp;ldquo;JavaScript&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&amp;rdquo;.js&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&amp;ldquo;TypeScript&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&amp;rdquo;.ts&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&amp;ldquo;CoffeeScript&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&amp;rdquo;.coffee&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;复合型数据转为表格显示的条件是，必须拥有主键。对于上面的数组来说，主键就是数字键。对于对象来说，主键就是它的最外层键。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var languages = {
  csharp: { name: &amp;quot;C#&amp;quot;, paradigm: &amp;quot;object-oriented&amp;quot; },
  fsharp: { name: &amp;quot;F#&amp;quot;, paradigm: &amp;quot;functional&amp;quot; }
};

console.table(languages);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的language，转为表格显示如下。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;(index)&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;paradigm&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;csharp&lt;/td&gt;
&lt;td&gt;&amp;ldquo;C#&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&amp;ldquo;object-oriented&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;fsharp&lt;/td&gt;
&lt;td&gt;&amp;ldquo;F#&amp;rdquo;&lt;/td&gt;
&lt;td&gt;&amp;ldquo;functional&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;count:93028a78a5be4722529cc12afbd69c79&#34;&gt;count()&lt;/h3&gt;

&lt;p&gt;count方法用于计数，输出它被调用了多少次。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function greet(user) {
  console.count();
  return &amp;quot;hi &amp;quot; + user;
}

greet(&#39;bob&#39;)
//  : 1
// &amp;quot;hi bob&amp;quot;

greet(&#39;alice&#39;)
//  : 2
// &amp;quot;hi alice&amp;quot;

greet(&#39;bob&#39;)
//  : 3
// &amp;quot;hi bob&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码每次调用greet函数，内部的console.count方法就输出执行次数。&lt;/p&gt;

&lt;p&gt;该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
function greet(user) {
  console.count(user);
  return &amp;quot;hi &amp;quot; + user;
}

greet(&#39;bob&#39;)
// bob: 1
// &amp;quot;hi bob&amp;quot;

greet(&#39;alice&#39;)
// alice: 1
// &amp;quot;hi alice&amp;quot;

greet(&#39;bob&#39;)
// bob: 2
// &amp;quot;hi bob&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码根据参数的不同，显示bob执行了两次，alice执行了一次。&lt;/p&gt;

&lt;h3 id=&#34;dir:93028a78a5be4722529cc12afbd69c79&#34;&gt;dir()&lt;/h3&gt;

&lt;p&gt;dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.log({f1: &#39;foo&#39;, f2: &#39;bar&#39;})
// Object {f1: &amp;quot;foo&amp;quot;, f2: &amp;quot;bar&amp;quot;}

console.dir({f1: &#39;foo&#39;, f2: &#39;bar&#39;})
// Object
//   f1: &amp;quot;foo&amp;quot;
//   f2: &amp;quot;bar&amp;quot;
//   __proto__: Object

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码显示dir方法的输出结果，比log方法更易读，信息也更丰富。&lt;/p&gt;

&lt;p&gt;该方法对于输出DOM对象非常有用，因为会显示DOM对象的所有属性。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.dir(document.body)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;assert:93028a78a5be4722529cc12afbd69c79&#34;&gt;assert()&lt;/h3&gt;

&lt;p&gt;assert方法接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// 实例
console.assert(true === false, &amp;ldquo;判断条件不成立&amp;rdquo;)
// Assertion failed: 判断条件不成立&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;下面是另一个例子，判断子节点的个数是否大于等于500。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;console.assert(list.childNodes.length &amp;lt; 500, &amp;ldquo;节点个数大于等于500&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;time-timeend:93028a78a5be4722529cc12afbd69c79&#34;&gt;time()，timeEnd()&lt;/h3&gt;

&lt;p&gt;这两个方法用于计时，可以算出一个操作所花费的准确时间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.time(&amp;quot;Array initialize&amp;quot;);

var array= new Array(1000000);
for (var i = array.length - 1; i &amp;gt;= 0; i--) {
    array[i] = new Object();
};

console.timeEnd(&amp;quot;Array initialize&amp;quot;);

// Array initialize: 1914.481ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。&lt;/p&gt;

&lt;h3 id=&#34;profile-profileend:93028a78a5be4722529cc12afbd69c79&#34;&gt;profile()，profileEnd()&lt;/h3&gt;

&lt;p&gt;console.profile方法用来新建一个性能测试器（profile），它的参数是性能测试器的名字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.profile(&#39;p&#39;)
// Profile &#39;p&#39; started.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console.profileEnd方法用来结束正在运行的性能测试器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.profileEnd()
// Profile &#39;p&#39; finished.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开浏览器的开发者工具，在profile面板中，可以看到这个性能调试器的运行结果。&lt;/p&gt;

&lt;h3 id=&#34;group-groupend-groupcollapsed:93028a78a5be4722529cc12afbd69c79&#34;&gt;group()，groupend()，groupCollapsed()&lt;/h3&gt;

&lt;p&gt;console.group和console.groupend这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.group(&#39;Group One&#39;);
console.group(&#39;Group Two&#39;);

// some code

console.groupEnd(); // Group Two 结束
console.groupEnd(); // Group One 结束

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console.groupCollapsed方法与console.group方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
console.groupCollapsed(&#39;Fetching Data&#39;);

console.log(&#39;Request Sent&#39;);
console.error(&#39;Error: Server not responding (500)&#39;);

console.groupEnd();

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。&lt;/p&gt;

&lt;h3 id=&#34;trace-clear:93028a78a5be4722529cc12afbd69c79&#34;&gt;trace()，clear()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;console.trace&lt;/code&gt;方法显示当前执行的代码在堆栈中的调用路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.trace()
// console.trace()
//   (anonymous function)
//   InjectedScript._evaluateOn
//   InjectedScript._evaluateAndWrap
//   InjectedScript.evaluate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。&lt;/p&gt;

&lt;h2 id=&#34;命令行api:93028a78a5be4722529cc12afbd69c79&#34;&gt;命令行API&lt;/h2&gt;

&lt;p&gt;在控制台中，除了使用console对象，还可以使用一些控制台自带的命令行方法。&lt;/p&gt;

&lt;p&gt;（1）$_&lt;/p&gt;

&lt;p&gt;$_属性返回上一个表达式的值。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;2+2
// 4
$_
// 4&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;（2）$0 - $4&lt;/p&gt;

&lt;p&gt;控制台保存了最近5个在Elements面板选中的DOM元素，$0代表倒数第一个，$1代表倒数第二个，以此类推直到$4。&lt;/p&gt;

&lt;p&gt;（3）$(selector)&lt;/p&gt;

&lt;p&gt;$(selector)返回一个数组，包括特定的CSS选择器匹配的所有DOM元素。该方法实际上是document.querySelectorAll方法的别名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var images = $(&#39;img&#39;);
for (each in images) {
    console.log(images[each].src);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码打印出网页中所有img元素的src属性。&lt;/p&gt;

&lt;p&gt;（4）$$(selector)&lt;/p&gt;

&lt;p&gt;$$(selector)返回一个选中的DOM对象，等同于document.querySelectorAll。&lt;/p&gt;

&lt;p&gt;（5）$x(path)&lt;/p&gt;

&lt;p&gt;$x(path)方法返回一个数组，包含匹配特定XPath表达式的所有DOM元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$x(&amp;quot;//p[a]&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码返回所有包含a元素的p元素。&lt;/p&gt;

&lt;p&gt;（6）inspect(object)&lt;/p&gt;

&lt;p&gt;inspect(object)方法打开相关面板，并选中相应的元素：DOM元素在Elements面板中显示，JavaScript对象在Profiles中显示。&lt;/p&gt;

&lt;p&gt;（7）getEventListeners(object)&lt;/p&gt;

&lt;p&gt;getEventListeners(object)方法返回一个对象，该对象的成员为登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。&lt;/p&gt;

&lt;p&gt;（8）keys(object)，values(object)&lt;/p&gt;

&lt;p&gt;keys(object)方法返回一个数组，包含特定对象的所有键名。&lt;/p&gt;

&lt;p&gt;values(object)方法返回一个数组，包含特定对象的所有键值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var o = {&#39;p1&#39;: &#39;a&#39;, &#39;p2&#39;: &#39;b&#39;};

keys(o)
// [&amp;quot;p1&amp;quot;, &amp;quot;p2&amp;quot;]
values(o)
// [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（9）&lt;code&gt;monitorEvents(object[, events]) ，unmonitorEvents(object[, events])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;monitorEvents(object[, events])&lt;/code&gt;方法监听特定对象上发生的特定事件。当这种情况发生时，会返回一个Event对象，包含该事件的相关信息。unmonitorEvents方法用于停止监听。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;monitorEvents(window, &amp;quot;resize&amp;quot;);

monitorEvents(window, [&amp;quot;resize&amp;quot;, &amp;quot;scroll&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码分别表示单个事件和多个事件的监听方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;monitorEvents($0, &amp;ldquo;mouse&amp;rdquo;);
unmonitorEvents($0, &amp;ldquo;mousemove&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示如何停止监听。&lt;/p&gt;

&lt;p&gt;monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mouse：&amp;rdquo;mousedown&amp;rdquo;, &amp;ldquo;mouseup&amp;rdquo;, &amp;ldquo;click&amp;rdquo;, &amp;ldquo;dblclick&amp;rdquo;, &amp;ldquo;mousemove&amp;rdquo;, &amp;ldquo;mouseover&amp;rdquo;, &amp;ldquo;mouseout&amp;rdquo;, &amp;ldquo;mousewheel&amp;rdquo;&lt;/li&gt;
&lt;li&gt;key：&amp;rdquo;keydown&amp;rdquo;, &amp;ldquo;keyup&amp;rdquo;, &amp;ldquo;keypress&amp;rdquo;, &amp;ldquo;textInput&amp;rdquo;&lt;/li&gt;
&lt;li&gt;touch：&amp;rdquo;touchstart&amp;rdquo;, &amp;ldquo;touchmove&amp;rdquo;, &amp;ldquo;touchend&amp;rdquo;, &amp;ldquo;touchcancel&amp;rdquo;&lt;/li&gt;
&lt;li&gt;control：&amp;rdquo;resize&amp;rdquo;, &amp;ldquo;scroll&amp;rdquo;, &amp;ldquo;zoom&amp;rdquo;, &amp;ldquo;focus&amp;rdquo;, &amp;ldquo;blur&amp;rdquo;, &amp;ldquo;select&amp;rdquo;, &amp;ldquo;change&amp;rdquo;, &amp;ldquo;submit&amp;rdquo;, &amp;ldquo;reset&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;monitorEvents($(&amp;ldquo;#msg&amp;rdquo;), &amp;ldquo;key&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示监听所有key大类的事件。&lt;/p&gt;

&lt;p&gt;（10）&lt;code&gt;profile([name])&lt;/code&gt;，profileEnd()&lt;/p&gt;

&lt;p&gt;profile方法用于启动一个特定名称的CPU性能测试，profileEnd方法用于结束该性能测试。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;profile(&amp;ldquo;My profile&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;profileEnd(&amp;ldquo;My profile&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;（11）其他方法&lt;/p&gt;

&lt;p&gt;命令行API还提供以下方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;clear()方法清除控制台的历史。&lt;/li&gt;
&lt;li&gt;copy(object)方法复制特定DOM元素到剪贴板。&lt;/li&gt;
&lt;li&gt;dir(object)方法显示特定对象的所有属性，是console.dir方法的别名。&lt;/li&gt;
&lt;li&gt;dirxml(object)方法显示特定对象的XML形式，是console.dirxml方法的别名。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;debugger语句:93028a78a5be4722529cc12afbd69c79&#34;&gt;debugger语句&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;debugger&lt;/code&gt;语句必须与除错工具配合使用，如果没有除错工具，debugger语句不会产生任何结果。&lt;/p&gt;

&lt;p&gt;在Chrome浏览器中，当代码运行到debugger指定的行时，就会暂停运行，自动打开控制台界面。它的作用类似于设置断点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;for(var i = 0;i &amp;lt; 5;i++){
  console.log(i);
  if (i === 2) debugger;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码打印出0，1，2以后，就会暂停，自动打开console窗口，等待进一步处理。&lt;/p&gt;

&lt;h2 id=&#34;移动端开发:93028a78a5be4722529cc12afbd69c79&#34;&gt;移动端开发&lt;/h2&gt;

&lt;p&gt;（本节暂存此处）&lt;/p&gt;

&lt;h3 id=&#34;模拟手机视口-viewport:93028a78a5be4722529cc12afbd69c79&#34;&gt;模拟手机视口（viewport）&lt;/h3&gt;

&lt;p&gt;chrome浏览器的开发者工具，提供一个选项，可以模拟手机屏幕的显示效果。&lt;/p&gt;

&lt;p&gt;打开“设置”的Overrides面板，选择相应的User Agent和Device Metrics选项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/chrome-developer-tools/docs/mobile-emulation/image_3.png&#34; alt=&#34;选择User Agent&#34; /&gt;&lt;/p&gt;

&lt;p&gt;User Agent可以使得当前浏览器发出手机浏览器的Agent字符串，Device Metrics则使得当前浏览器的视口变为手机的视口大小。这两个选项可以独立选择，不一定同时选中。&lt;/p&gt;

&lt;h3 id=&#34;模拟touch事件:93028a78a5be4722529cc12afbd69c79&#34;&gt;模拟touch事件&lt;/h3&gt;

&lt;p&gt;我们可以在PC端模拟JavaScript的touch事件。&lt;/p&gt;

&lt;p&gt;首先，打开chrome浏览器的开发者工具，选择“设置”中的Overrides面板，勾选“Enable touch events”选项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/chrome-developer-tools/docs/mobile-emulation/image_0.png&#34; alt=&#34;Enable touch events的图片&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后，鼠标就会触发touchstart、touchmove和touchend事件。（此时，鼠标本身的事件依然有效。）&lt;/p&gt;

&lt;p&gt;至于多点触摸，必须要有支持这个功能的设备才能模拟，具体可以参考&lt;a href=&#34;http://www.html5rocks.com/en/mobile/touch/&#34;&gt;Multi-touch web development&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;模拟经纬度:93028a78a5be4722529cc12afbd69c79&#34;&gt;模拟经纬度&lt;/h3&gt;

&lt;p&gt;chrome浏览器的开发者工具，还可以模拟当前的经纬度数据。打开“设置”的Overrides面板，选中Override Geolocation选项，并填入相应经度和纬度数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://developers.google.com/chrome-developer-tools/docs/mobile-emulation/image_11.png&#34; alt=&#34;模拟经纬度&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;远程除错:93028a78a5be4722529cc12afbd69c79&#34;&gt;远程除错&lt;/h3&gt;

&lt;p&gt;(1) Chrome for Android&lt;/p&gt;

&lt;p&gt;Android设备上的Chrome浏览器支持USB除错。PC端需要安装Android SDK和Chrome浏览器，然后用usb线将手机和PC连起来，可参考&lt;a href=&#34;https://developers.google.com/chrome-developer-tools/docs/remote-debugging&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;(2) Opera&lt;/p&gt;

&lt;p&gt;Opera浏览器的除错环境Dragonfly支持远程除错（&lt;a href=&#34;http://www.codegeek.net/blog/2012/mobile-debugging-with-opera-dragonfly/&#34;&gt;教程&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;(3) Firefox for Android&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&#34;https://hacks.mozilla.org/2012/08/remote-debugging-on-firefox-for-android/&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;(4) Safari on iOS6&lt;/p&gt;

&lt;p&gt;你可以使用Mac桌面电脑的Safari 6浏览器，进行远程除错（&lt;a href=&#34;http://www.mobilexweb.com/blog/iphone-5-ios-6-html5-developers&#34;&gt;教程&lt;/a&gt;）。&lt;/p&gt;

&lt;h2 id=&#34;google-closure:93028a78a5be4722529cc12afbd69c79&#34;&gt;Google Closure&lt;/h2&gt;

&lt;p&gt;（本节暂存此处）&lt;/p&gt;

&lt;p&gt;Google Closure是Google提供的一个JavaScript源码处理工具，主要用于压缩和合并多个JavaScript脚本文件。&lt;/p&gt;

&lt;p&gt;Google Closure使用Java语言开发，使用之前必须先安装Java。然后，前往&lt;a href=&#34;https://developers.google.com/closure/&#34;&gt;官方网站&lt;/a&gt;进行下载，这里我们主要使用其中的编译器（compiler）。&lt;/p&gt;

&lt;p&gt;首先，查看使用帮助。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;p&gt;java -jar /path/to/closure/compiler.jar &amp;ndash;help&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;直接在脚本命令后面跟上要合并的脚本，就能完成合并。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;p&gt;java -jar /path/to/closure/compiler.jar *.js&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;使用&amp;ndash;js参数，可以确保按照参数的先后次序合并文件。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;p&gt;java -jar /path/to/closure/compiler.jar &amp;ndash;js script1.js &amp;ndash;js script2.js &amp;ndash;js script3.js&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;但是，这样的运行结果是将合并后的文件全部输出到屏幕（标准输出），因此需要使用&amp;ndash;js_output_file参数，指定合并后的文件名。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;p&gt;java -jar /path/to/closure/compiler.jar &amp;ndash;js script1.js &amp;ndash;js script2.js &amp;ndash;js script3.js &amp;ndash;js_output_file scripts-compiled.js&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h2 id=&#34;javascript-性能测试:93028a78a5be4722529cc12afbd69c79&#34;&gt;Javascript 性能测试&lt;/h2&gt;

&lt;p&gt;(本节暂存此处)&lt;/p&gt;

&lt;h3 id=&#34;第一种做法:93028a78a5be4722529cc12afbd69c79&#34;&gt;第一种做法&lt;/h3&gt;

&lt;p&gt;最常见的测试性能的做法，就是同一操作重复n次，然后计算每次操作的平均时间。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var totalTime,
    start = new Date,
    iterations = 6;&lt;/p&gt;

&lt;p&gt;while (iterations&amp;ndash;) {
  // Code snippet goes here
}&lt;/p&gt;

&lt;p&gt;// totalTime → the number of milliseconds it took to execute
// the code snippet 6 times
totalTime = new Date - start;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码的问题在于，由于计算机的性能不断提高，如果只重复6次，很可能得到0毫秒的结果，即不到1毫秒，Javascript引擎无法测量。&lt;/p&gt;

&lt;h3 id=&#34;第二种做法:93028a78a5be4722529cc12afbd69c79&#34;&gt;第二种做法&lt;/h3&gt;

&lt;p&gt;另一种思路是，测试单位时间内完成了多少次操作。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var hz,
    period,
    startTime = new Date,
    runs = 0;&lt;/p&gt;

&lt;p&gt;do {
  // Code snippet goes here
  runs++;
  totalTime = new Date - startTime;
} while (totalTime &amp;lt; 1000);&lt;/p&gt;

&lt;p&gt;// convert ms to seconds
totalTime /= 1000;&lt;/p&gt;

&lt;p&gt;// period → how long per operation
period = totalTime / runs;&lt;/p&gt;

&lt;p&gt;// hz → the number of operations per second
hz = 1 / period;&lt;/p&gt;

&lt;p&gt;// can be shortened to
// hz = (runs * 1000) / totalTime;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;这种做法的注意之处在于，测试结构受外界环境影响很大，为了得到正确结构，必须重复多次。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:93028a78a5be4722529cc12afbd69c79&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Chrome Developer Tools, &lt;a href=&#34;https://developers.google.com/chrome-developer-tools/docs/console&#34;&gt;Using the Console&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Matt West, &lt;a href=&#34;http://blog.teamtreehouse.com/mastering-developer-tools-console&#34;&gt;Mastering The Developer Tools Console&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Firebug Wiki, &lt;a href=&#34;https://getfirebug.com/wiki/index.php/Console_API&#34;&gt;Console API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2013/10/console-api.html&#34;&gt;The JavaScript console API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Marius Schulz, &lt;a href=&#34;http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable&#34;&gt;Advanced JavaScript Debugging with console.table()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google Developer, &lt;a href=&#34;https://developers.google.com/chrome-developer-tools/docs/commandline-api&#34;&gt;Command Line API Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>9、JavaScript高级语法</title>
      <link>http://575087694.github.io/post/index9/</link>
      <pubDate>Thu, 23 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index9/</guid>
      <description>

&lt;p&gt;Promise是JavaScript异步操作解决方案。介绍Promise之前，先对异步操作做一个详细介绍。&lt;/p&gt;

&lt;h2 id=&#34;javascript的异步执行:a09c98b809056522e6a5fbf4c0281725&#34;&gt;JavaScript的异步执行&lt;/h2&gt;

&lt;h3 id=&#34;概述:a09c98b809056522e6a5fbf4c0281725&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;Javascript语言的执行环境是&amp;rdquo;单线程&amp;rdquo;（single thread）。所谓&amp;rdquo;单线程&amp;rdquo;，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。&lt;/p&gt;

&lt;p&gt;这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。&lt;/p&gt;

&lt;p&gt;JavaScript语言本身并不慢，慢的是读写外部数据，比如等待Ajax请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。&lt;/p&gt;

&lt;p&gt;为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。&amp;rdquo;同步模式&amp;rdquo;就是传统做法，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。这往往用于一些简单的、快速的、不涉及读写的操作。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;异步模式&amp;rdquo;则完全不同，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。&lt;/p&gt;

&lt;p&gt;以下总结了&amp;rdquo;异步模式&amp;rdquo;编程的几种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的JavaScript程序。&lt;/p&gt;

&lt;h3 id=&#34;回调函数:a09c98b809056522e6a5fbf4c0281725&#34;&gt;回调函数&lt;/h3&gt;

&lt;p&gt;回调函数是异步编程最基本的方法。&lt;/p&gt;

&lt;p&gt;假定有两个函数f1和f2，后者等待前者的执行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;f1();
f2();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;f1&lt;/code&gt;是一个很耗时的任务，可以考虑改写&lt;code&gt;f1&lt;/code&gt;，把&lt;code&gt;f2&lt;/code&gt;写成&lt;code&gt;f1&lt;/code&gt;的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f1(callback){
  setTimeout(function () {
    // f1的任务代码
    callback();
  }, 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行代码就变成下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;f1(f2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。&lt;/p&gt;

&lt;p&gt;回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度&lt;a href=&#34;http://en.wikipedia.org/wiki/Coupling_(computer_programming&#34;&gt;耦合&lt;/a&gt;)（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。&lt;/p&gt;

&lt;h3 id=&#34;事件监听:a09c98b809056522e6a5fbf4c0281725&#34;&gt;事件监听&lt;/h3&gt;

&lt;p&gt;另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。&lt;/p&gt;

&lt;p&gt;还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的&lt;a href=&#34;http://api.jquery.com/on/&#34;&gt;写法&lt;/a&gt;）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;f1.on(&#39;done&#39;, f2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function f1(){
  setTimeout(function () {
    // f1的任务代码
    f1.trigger(&#39;done&#39;);
  }, 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;f1.trigger(&#39;done&#39;)&lt;/code&gt;表示，执行完成后，立即触发&lt;code&gt;done&lt;/code&gt;事件，从而开始执行&lt;code&gt;f2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以&amp;rdquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Decoupling&#34;&gt;去耦合&lt;/a&gt;&amp;ldquo;（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。&lt;/p&gt;

&lt;h3 id=&#34;发布-订阅:a09c98b809056522e6a5fbf4c0281725&#34;&gt;发布/订阅&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;事件&amp;rdquo;完全可以理解成&amp;rdquo;信号&amp;rdquo;，如果存在一个&amp;rdquo;信号中心&amp;rdquo;，某个任务执行完成，就向信号中心&amp;rdquo;发布&amp;rdquo;（publish）一个信号，其他任务可以向信号中心&amp;rdquo;订阅&amp;rdquo;（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做&amp;rdquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Publish-subscribe_pattern&#34;&gt;发布/订阅模式&lt;/a&gt;&amp;ldquo;（publish-subscribe pattern），又称&amp;rdquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;观察者模式&lt;/a&gt;&amp;ldquo;（observer pattern）。&lt;/p&gt;

&lt;p&gt;这个模式有多种&lt;a href=&#34;http://msdn.microsoft.com/en-us/magazine/hh201955.aspx&#34;&gt;实现&lt;/a&gt;，下面采用的是Ben Alman的&lt;a href=&#34;https://gist.github.com/661855&#34;&gt;Tiny Pub/Sub&lt;/a&gt;，这是jQuery的一个插件。&lt;/p&gt;

&lt;p&gt;首先，f2向&amp;rdquo;信号中心&amp;rdquo;jQuery订阅&amp;rdquo;done&amp;rdquo;信号。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;jQuery.subscribe(&amp;ldquo;done&amp;rdquo;, f2);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;然后，f1进行如下改写：&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;function f1(){
    setTimeout(function () {
        // f1的任务代码
        jQuery.publish(&amp;ldquo;done&amp;rdquo;);
    }, 1000);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;jQuery.publish(&amp;ldquo;done&amp;rdquo;)的意思是，f1执行完成后，向&amp;rdquo;信号中心&amp;rdquo;jQuery发布&amp;rdquo;done&amp;rdquo;信号，从而引发f2的执行。&lt;/p&gt;

&lt;p&gt;f2完成执行后，也可以取消订阅（unsubscribe）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;jQuery.unsubscribe(&amp;ldquo;done&amp;rdquo;, f2);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;这种方法的性质与&amp;rdquo;事件监听&amp;rdquo;类似，但是明显优于后者。因为我们可以通过查看&amp;rdquo;消息中心&amp;rdquo;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。&lt;/p&gt;

&lt;h2 id=&#34;异步操作的流程控制:a09c98b809056522e6a5fbf4c0281725&#34;&gt;异步操作的流程控制&lt;/h2&gt;

&lt;p&gt;如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以后如何保证遵守这种顺序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function async(arg, callback) {
  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);
  setTimeout(function() { callback(arg * 2); }, 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。&lt;/p&gt;

&lt;p&gt;如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function final(value) {
  console.log(&#39;完成: &#39;, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请问应该如何安排操作流程？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;async(1, function(value){
  async(value, function(value){
    async(value, function(value){
      async(value, function(value){
        async(value, function(value){
          async(value, final);
        });
      });
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码采用6个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。&lt;/p&gt;

&lt;h3 id=&#34;串行执行:a09c98b809056522e6a5fbf4c0281725&#34;&gt;串行执行&lt;/h3&gt;

&lt;p&gt;我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
function series(item) {
  if(item) {
    async( item, function(result) {
      results.push(result);
      return series(items.shift());
    });
  } else {
    return final(results);
  }
}
series(items.shift());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。&lt;/p&gt;

&lt;h3 id=&#34;并行执行:a09c98b809056522e6a5fbf4c0281725&#34;&gt;并行执行&lt;/h3&gt;

&lt;p&gt;流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];

items.forEach(function(item) {
  async(item, function(result){
    results.push(result);
    if(results.length == items.length) {
      final(results);
    }
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。&lt;/p&gt;

&lt;p&gt;并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。&lt;/p&gt;

&lt;h3 id=&#34;并行与串行的结合:a09c98b809056522e6a5fbf4c0281725&#34;&gt;并行与串行的结合&lt;/h3&gt;

&lt;p&gt;所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
var running = 0;
var limit = 2;

function launcher() {
  while(running &amp;lt; limit &amp;amp;&amp;amp; items.length &amp;gt; 0) {
    var item = items.shift();
    async(item, function(result) {
      results.push(result);
      running--;
      if(items.length &amp;gt; 0) {
        launcher();
      } else if(running == 0) {
        final();
      }
    });
    running++;
  }
}

launcher();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，最多只能同时运行两个异步任务。变量running记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于0，就表示所有任务都执行完了，这时就执行final函数。&lt;/p&gt;

&lt;h2 id=&#34;promise对象:a09c98b809056522e6a5fbf4c0281725&#34;&gt;Promise对象&lt;/h2&gt;

&lt;h3 id=&#34;简介:a09c98b809056522e6a5fbf4c0281725&#34;&gt;简介&lt;/h3&gt;

&lt;p&gt;Promise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供&lt;a href=&#34;http://wiki.commonjs.org/wiki/Promises/A&#34;&gt;统一接口&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;那么，什么是Promises？&lt;/p&gt;

&lt;p&gt;首先，它是一个对象，也就是说与其他JavaScript对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。&lt;/p&gt;

&lt;p&gt;简单说，它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以采用同步操作的流程。这个Promises对象有一个then方法，允许指定回调函数，在异步任务完成后调用。&lt;/p&gt;

&lt;p&gt;比如，异步操作&lt;code&gt;f1&lt;/code&gt;返回一个Promise对象，它的回调函数&lt;code&gt;f2&lt;/code&gt;写法如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(new Promise(f1)).then(f2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种写法对于多层嵌套的回调函数尤其方便。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 传统写法
step1(function (value1) {
  step2(value1, function(value2) {
    step3(value2, function(value3) {
      step4(value3, function(value4) {
        // ...
      });
    });
  });
});

// Promises的写法
(new Promise(step1))
  .then(step2)
  .then(step3)
  .then(step4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面代码可以看到，采用Promises接口以后，程序流程变得非常清楚，十分易读。&lt;/p&gt;

&lt;p&gt;注意，为了便于理解，上面代码的Promise对象的生成格式，做了简化，真正的语法请参照下文。&lt;/p&gt;

&lt;p&gt;总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promises规范就是为了解决这个问题而提出的，目标是使用正常的程序流程（同步），来处理异步操作。它先返回一个Promise对象，后面的操作以同步的方式，寄存在这个对象上面。等到异步操作有了结果，再执行前期寄放在它上面的其他操作。&lt;/p&gt;

&lt;p&gt;Promises原本只是社区提出的一个构想，一些外部函数库率先实现了这个功能。ECMAScript 6将其写入语言标准，因此目前JavaScript语言原生支持Promise对象。&lt;/p&gt;

&lt;h3 id=&#34;promise接口:a09c98b809056522e6a5fbf4c0281725&#34;&gt;Promise接口&lt;/h3&gt;

&lt;p&gt;前面说过，Promise接口的基本思想是，异步任务返回一个Promise对象。&lt;/p&gt;

&lt;p&gt;Promise对象只有三种状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;异步操作“未完成”（pending）&lt;/li&gt;
&lt;li&gt;异步操作“已完成”（resolved，又称fulfilled）&lt;/li&gt;
&lt;li&gt;异步操作“失败”（rejected）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三种的状态的变化途径只有两种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;异步操作从“未完成”到“已完成”&lt;/li&gt;
&lt;li&gt;异步操作从“未完成”到“失败”。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种变化只能发生一次，一旦当前状态变为“已完成”或“失败”，就意味着不会再有新的状态变化了。因此，Promise对象的最终结果只有两种。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;异步操作成功，Promise对象传回一个值，状态变为&lt;code&gt;resolved&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;异步操作失败，Promise对象抛出一个错误，状态变为&lt;code&gt;rejected&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Promise对象使用&lt;code&gt;then&lt;/code&gt;方法添加回调函数。&lt;code&gt;then&lt;/code&gt;方法可以接受两个回调函数，第一个是异步操作成功时（变为&lt;code&gt;resolved&lt;/code&gt;状态）时的回调函数，第二个是异步操作失败（变为&lt;code&gt;rejected&lt;/code&gt;）时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// po是一个Promise对象
po.then(
  console.log,
  console.error
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，Promise对象&lt;code&gt;po&lt;/code&gt;使用&lt;code&gt;then&lt;/code&gt;方法绑定两个回调函数：操作成功时的回调函数&lt;code&gt;console.log&lt;/code&gt;，操作失败时的回调函数&lt;code&gt;console.error&lt;/code&gt;（可以省略）。这两个函数都接受异步操作传回的值作为参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;then&lt;/code&gt;方法可以链式使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;po
  .then(step1)
  .then(step2)
  .then(step3)
  .then(
    console.log,
    console.error
  );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，&lt;code&gt;po&lt;/code&gt;的状态一旦变为&lt;code&gt;resolved&lt;/code&gt;，就依次调用后面每一个&lt;code&gt;then&lt;/code&gt;指定的回调函数，每一步都必须等到前一步完成，才会执行。最后一个&lt;code&gt;then&lt;/code&gt;方法的回调函数&lt;code&gt;console.log&lt;/code&gt;和&lt;code&gt;console.error&lt;/code&gt;，用法上有一点重要的区别。&lt;code&gt;console.log&lt;/code&gt;只显示回调函数&lt;code&gt;step3&lt;/code&gt;的返回值，而&lt;code&gt;console.error&lt;/code&gt;可以显示&lt;code&gt;step1&lt;/code&gt;、&lt;code&gt;step2&lt;/code&gt;、&lt;code&gt;step3&lt;/code&gt;之中任意一个发生的错误。也就是说，假定&lt;code&gt;step1&lt;/code&gt;操作失败，抛出一个错误，这时&lt;code&gt;step2&lt;/code&gt;和&lt;code&gt;step3&lt;/code&gt;都不会再执行了（因为它们是操作成功的回调函数，而不是操作失败的回调函数）。Promises对象开始寻找，接下来第一个操作失败时的回调函数，在上面代码中是&lt;code&gt;console.error&lt;/code&gt;。这就是说，Promises对象的错误有传递性。&lt;/p&gt;

&lt;p&gt;从同步的角度看，上面的代码大致等同于下面的形式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {
  var v1 = step1(po);
  var v2 = step2(v1);
  var v3 = step3(v2);
  console.log(v3);
} catch (error) {
  console.error(error);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;promise对象的生成:a09c98b809056522e6a5fbf4c0281725&#34;&gt;Promise对象的生成&lt;/h3&gt;

&lt;p&gt;ES6提供了原生的Promise构造函数，用来生成Promise实例。&lt;/p&gt;

&lt;p&gt;下面代码创造了一个Promise实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  // 异步操作的代码

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Promise构造函数接受一个函数作为参数，该函数的两个参数分别是&lt;code&gt;resolve&lt;/code&gt;和&lt;code&gt;reject&lt;/code&gt;。它们是两个函数，由JavaScript引擎提供，不用自己部署。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;resolve&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Resolved&lt;/code&gt;），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；&lt;code&gt;reject&lt;/code&gt;函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Rejected&lt;/code&gt;），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。&lt;/p&gt;

&lt;p&gt;Promise实例生成以后，可以用&lt;code&gt;then&lt;/code&gt;方法分别指定&lt;code&gt;Resolved&lt;/code&gt;状态和&lt;code&gt;Reject&lt;/code&gt;状态的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;po.then(function(value) {
  // success
}, function(value) {
  // failure
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用法辨析:a09c98b809056522e6a5fbf4c0281725&#34;&gt;用法辨析&lt;/h3&gt;

&lt;p&gt;Promise的用法，简单说就是一句话：使用&lt;code&gt;then&lt;/code&gt;方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 写法一
doSomething().then(function () {
  return doSomethingElse();
});

// 写法二
doSomething().then(function () {
  doSomethingElse();
});

// 写法三
doSomething().then(doSomethingElse());

// 写法四
doSomething().then(doSomethingElse);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了便于讲解，这四种写法都再用&lt;code&gt;then&lt;/code&gt;方法接一个回调函数&lt;code&gt;finalHandler&lt;/code&gt;。写法一的&lt;code&gt;finalHandler&lt;/code&gt;回调函数的参数，是&lt;code&gt;doSomethingElse&lt;/code&gt;函数的运行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;doSomething().then(function () {
  return doSomethingElse();
}).then(finalHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写法二的&lt;code&gt;finalHandler&lt;/code&gt;回调函数的参数是&lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;doSomething().then(function () {
  doSomethingElse();
  return;
}).then(finalHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写法三的&lt;code&gt;finalHandler&lt;/code&gt;回调函数的参数，是&lt;code&gt;doSomethingElse&lt;/code&gt;函数返回的回调函数的运行结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;doSomething().then(doSomethingElse())
  .then(finalHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写法四与写法一只有一个差别，那就是&lt;code&gt;doSomethingElse&lt;/code&gt;会接收到&lt;code&gt;doSomething()&lt;/code&gt;返回的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;doSomething().then(doSomethingElse)
  .then(finalHandler);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;promise的应用:a09c98b809056522e6a5fbf4c0281725&#34;&gt;Promise的应用&lt;/h2&gt;

&lt;h3 id=&#34;加载图片:a09c98b809056522e6a5fbf4c0281725&#34;&gt;加载图片&lt;/h3&gt;

&lt;p&gt;我们可以把图片的加载写成一个&lt;code&gt;Promise&lt;/code&gt;对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var preloadImage = function (path) {
  return new Promise(function (resolve, reject) {
    var image = new Image();
    image.onload  = resolve;
    image.onerror = reject;
    image.src = path;
  });
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ajax操作:a09c98b809056522e6a5fbf4c0281725&#34;&gt;Ajax操作&lt;/h3&gt;

&lt;p&gt;Ajax操作是典型的异步操作，传统上往往写成下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function search(term, onload, onerror) {
  var xhr, results, url;
  url = &#39;http://example.com/search?q=&#39; + term;

  xhr = new XMLHttpRequest();
  xhr.open(&#39;GET&#39;, url, true);

  xhr.onload = function (e) {
    if (this.status === 200) {
      results = JSON.parse(this.responseText);
      onload(results);
    }
  };
  xhr.onerror = function (e) {
    onerror(e);
  };

  xhr.send();
}

search(&amp;quot;Hello World&amp;quot;, console.log, console.error);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用Promise对象，就可以写成下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function search(term) {
  var url = &#39;http://example.com/search?q=&#39; + term;
  var xhr = new XMLHttpRequest();
  var result;

  var p = new Promise(function (resolve, reject) {
    xhr.open(&#39;GET&#39;, url, true);
    xhr.onload = function (e) {
      if (this.status === 200) {
        result = JSON.parse(this.responseText);
        resolve(result);
      }
    };
    xhr.onerror = function (e) {
      reject(e);
    };
    xhr.send();
  });

  return p;
}

search(&amp;quot;Hello World&amp;quot;).then(console.log, console.error);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加载图片的例子，也可以用Ajax操作完成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function imgLoad(url) {
  return new Promise(function(resolve, reject) {
    var request = new XMLHttpRequest();
    request.open(&#39;GET&#39;, url);
    request.responseType = &#39;blob&#39;;
    request.onload = function() {
      if (request.status === 200) {
        resolve(request.response);
      } else {
        reject(new Error(&#39;图片加载失败：&#39; + request.statusText));
      }
    };
    request.onerror = function() {
      reject(new Error(&#39;发生网络错误&#39;));
    };
    request.send();
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;小结:a09c98b809056522e6a5fbf4c0281725&#34;&gt;小结&lt;/h3&gt;

&lt;p&gt;Promise对象的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它的一整套接口，可以实现许多强大的功能，比如为多个异步操作部署一个回调函数、为多个回调函数中抛出的错误统一指定处理方法等等。&lt;/p&gt;

&lt;p&gt;而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是，编写和理解都相对比较难。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:a09c98b809056522e6a5fbf4c0281725&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Sebastian Porto, &lt;a href=&#34;http://sporto.github.com/blog/2012/12/09/callbacks-listeners-promises/&#34;&gt;Asynchronous JS: Callbacks, Listeners, Control Flow Libs and Promises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rhys Brett-Bowen, &lt;a href=&#34;http://modernjavascript.blogspot.com/2013/08/promisesa-understanding-by-doing.html&#34;&gt;Promises/A+ - understanding the spec through implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Matt Podwysocki, Amanda Silver, &lt;a href=&#34;http://blogs.msdn.com/b/ie/archive/2011/09/11/asynchronous-programming-in-javascript-with-promises.aspx&#34;&gt;Asynchronous Programming in JavaScript with “Promises”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Marc Harter, &lt;a href=&#34;https://gist.github.com//wavded/5692344&#34;&gt;Promise A+ Implementation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bryan Klimt, &lt;a href=&#34;http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/&#34;&gt;What’s so great about JavaScript Promises?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jake Archibald, &lt;a href=&#34;http://www.html5rocks.com/en/tutorials/es6/promises/&#34;&gt;JavaScript Promises There and back again&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mikito Takada, &lt;a href=&#34;http://book.mixu.net/node/ch7.html&#34;&gt;7. Control flow, Mixu&amp;rsquo;s Node book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>10、jQuery</title>
      <link>http://575087694.github.io/post/index11/</link>
      <pubDate>Wed, 22 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index11/</guid>
      <description>

&lt;p&gt;jQuery是目前使用最广泛的JavaScript函数库。据&lt;a href=&#34;http://w3techs.com/technologies/details/js-jquery/all/all&#34;&gt;统计&lt;/a&gt;，全世界57.5%的网站使用jQuery，在使用JavaScript函数库的网站中，93.0%使用jQuery。它已经成了开发者必须学会的技能。&lt;/p&gt;

&lt;p&gt;jQuery的最大优势有两个。首先，它基本是一个DOM操作工具，可以使操作DOM对象变得异常容易。其次，它统一了不同浏览器的API接口，使得代码在所有现代浏览器均能运行，开发者不用担心浏览器之间的差异。&lt;/p&gt;

&lt;h2 id=&#34;jquery的加载:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery的加载&lt;/h2&gt;

&lt;p&gt;一般采用下面的写法，在网页中加载jQuery。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;
  src=&amp;quot;//code.jquery.com/jquery-1.11.0.min.js&amp;quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
window.jQuery ||
  document.write(
    &#39;&amp;lt;script src=&amp;quot;js/jquery-1.11.0.min.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;\/script&amp;gt;&#39;
  );
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码有两点需要注意。一是采用&lt;a href=&#34;http://jquery.com/download/#using-jquery-with-a-cdn&#34;&gt;CDN&lt;/a&gt;加载。如果CDN加载失败，则退回到本地加载。二是采用协议无关的加载网址（使用双斜线表示），同时支持http协议和https协议。&lt;/p&gt;

&lt;p&gt;目前常用的jQuery CDN有以下这些。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/speed/libraries/devguide#jquery&#34;&gt;Google CDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.asp.net/ajax/cdn#jQuery_Releases_on_the_CDN_0&#34;&gt;Microsoft CDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jquery.com/download/#jquery-39-s-cdn-provided-by-maxcdn&#34;&gt;jQuery CDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cdnjs.com/libraries/jquery/&#34;&gt;CDNJS CDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jsdelivr.com/#!jquery&#34;&gt;jsDelivr CDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这段代码最好放到网页尾部。如果需要支持IE 6/7/8，就使用jQuery 1.x版，否则使用最新版。&lt;/p&gt;

&lt;h2 id=&#34;jquery基础:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery基础&lt;/h2&gt;

&lt;h3 id=&#34;jquery对象:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery对象&lt;/h3&gt;

&lt;p&gt;jQuery最重要的概念，就是&lt;code&gt;jQuery&lt;/code&gt;对象。它是一个全局对象，可以简写为美元符号&lt;code&gt;$&lt;/code&gt;。也就是说，&lt;code&gt;jQuery&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;两者是等价的。&lt;/p&gt;

&lt;p&gt;在网页中加载jQuery函数库以后，就可以使用jQuery对象了。jQuery的全部方法，都定义在这个对象上面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var listItems = jQuery(&#39;li&#39;);
// or
var listItems = $(&#39;li&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面两行代码是等价的，表示选中网页中所有的&lt;code&gt;li&lt;/code&gt;元素。&lt;/p&gt;

&lt;h3 id=&#34;jquery构造函数:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery构造函数&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;jQuery&lt;/code&gt;对象本质上是一个构造函数，主要作用是返回&lt;code&gt;jQuery&lt;/code&gt;对象的实例。比如，上面代码表面上是选中&lt;code&gt;li&lt;/code&gt;元素，实际上是返回对应于&lt;code&gt;li&lt;/code&gt;元素的&lt;code&gt;jQuery&lt;/code&gt;实例。因为只有这样，才能在DOM对象上使用jQuery提供的各种方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;body&#39;).nodeType
// undefined

$(&#39;body&#39;) instanceof jQuery
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，由于jQuery返回的不是DOM对象，所以没有DOM属性&lt;code&gt;nodeType&lt;/code&gt;。它返回的是jQuery对象的实例。&lt;/p&gt;

&lt;p&gt;jQuery构造函数可以多种参数，返回不同的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）CSS选择器作为参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery构造函数的参数，主要是CSS选择器，就像上面的那个例子。下面是另外一些CSS选择器的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;*&amp;quot;)
$(&amp;quot;#lastname&amp;quot;)
$(&amp;quot;.intro&amp;quot;)
$(&amp;quot;h1,div,p&amp;quot;)
$(&amp;quot;p:last&amp;quot;)
$(&amp;quot;tr:even&amp;quot;)
$(&amp;quot;p:first-child&amp;quot;)
$(&amp;quot;p:nth-of-type(2)&amp;quot;)
$(&amp;quot;div + p&amp;quot;)
$(&amp;quot;div:has(p)&amp;quot;)
$(&amp;quot;:empty&amp;quot;)
$(&amp;quot;[title^=&#39;Tom&#39;]&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本书不讲解CSS选择器，请读者参考有关书籍和jQuery文档。&lt;/p&gt;

&lt;p&gt;除了CSS选择器，jQuery还定义了一些自有的选择器，比如&lt;code&gt;contains&lt;/code&gt;选择器用来选择包含特定文本的元素。下面是一个例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var search = $(&#39;#search&#39;).val();
$(&#39;div:not(:contains(&amp;quot;&#39; + search + &#39;&amp;quot;))&#39;).hide();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码用来选中包含搜索框输入文本的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）DOM对象作为参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery构造函数的参数，还可以是DOM对象。它也会被转为jQuery对象的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document.body) instanceof jQuery
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，jQuery的参数不是CSS选择器，而是一个DOM对象，返回的依然是jQuery对象的实例。&lt;/p&gt;

&lt;p&gt;如果有多个DOM元素要转为jQuery对象的实例，可以把DOM元素放在一个数组里，输入jQuery构造函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$([document.body, document.head])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（3）HTML字符串作为参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果直接在jQuery构造函数中输入HTML字符串，返回的也是jQuery实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;&amp;lt;li class=&amp;quot;greet&amp;quot;&amp;gt;test&amp;lt;/li&amp;gt;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码从HTML代码生成了一个jQuery实例，它与从CSS选择器生成的jQuery实例完全一样。唯一的区别就是，它对应的DOM结构不属于当前文档。&lt;/p&gt;

&lt;p&gt;上面代码也可以写成下面这样。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$( &#39;&amp;lt;li&amp;gt;&#39;, {
  html: &#39;test&#39;,
  &#39;class&#39;: &#39;greet&#39;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，由于&lt;code&gt;class&lt;/code&gt;是javaScript的保留字，所以只能放在引号中。&lt;/p&gt;

&lt;p&gt;通常来说，上面第二种写法是更好的写法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;&amp;lt;input class=&amp;quot;form-control&amp;quot; type=&amp;quot;hidden&amp;quot; name=&amp;quot;foo&amp;quot; value=&amp;quot;bar&amp;quot; /&amp;gt;&#39;)

// 相当于
$(&#39;&amp;lt;input/&amp;gt;&#39;, {
  &#39;class&#39;: &#39;form-control&#39;,
  type: &#39;hidden&#39;,
  name: &#39;foo&#39;,
  value: &#39;bar&#39;
})

// 或者
$(&#39;&amp;lt;input/&amp;gt;&#39;)
.addClass(&#39;form-control&#39;)
.attr(&#39;type&#39;, &#39;hidden&#39;)
.attr(&#39;name&#39;, &#39;foo&#39;)
.val(&#39;bar&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于新增的DOM节点不属于当前文档，所以可以用这种写法预加载图片。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$.preloadImages = function () {
  for (var i = 0; i &amp;lt; arguments.length; i++) {
    $(&#39;&amp;lt;img&amp;gt;&#39;).attr(&#39;src&#39;, arguments[i]);
  }
};

$.preloadImages(&#39;img/hover-on.png&#39;, &#39;img/hover-off.png&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（4）第二个参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，jQuery将文档的根元素（&lt;code&gt;html&lt;/code&gt;）作为寻找匹配对象的起点。如果要指定某个网页元素（比如某个&lt;code&gt;div&lt;/code&gt;元素）作为寻找的起点，可以将它放在jQuery函数的第二个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;, someElement);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，只寻找属于someElement对象下属的li元素。someElement可以是jQuery对象的实例，也可以是DOM对象。&lt;/p&gt;

&lt;h3 id=&#34;jquery构造函数返回的结果集:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery构造函数返回的结果集&lt;/h3&gt;

&lt;p&gt;jQuery的核心思想是“先选中某些网页元素，然后对其进行某种处理”（find something, do something），也就是说，先选择后处理，这是jQuery的基本操作模式。所以，绝大多数jQuery操作都是从选择器开始的，返回一个选中的结果集。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）length属性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery对象返回的结果集是一个类似数组的对象，包含了所有被选中的网页元素。查看该对象的length属性，可以知道到底选中了多少个结果。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;if ( $(&amp;lsquo;li&amp;rsquo;).length === 0 ) {
    console.log(&amp;lsquo;不含li元素&amp;rsquo;);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，如果网页没有li元素，则返回对象的length属性等于0。这就是测试有没有选中的标准方法。&lt;/p&gt;

&lt;p&gt;所以，如果想知道jQuery有没有选中相应的元素，不能写成下面这样。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;if ($(&amp;lsquo;div.foo&amp;rsquo;)) { &amp;hellip; }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;因为不管有没有选中，jQuery构造函数总是返回一个实例对象，而对象的布尔值永远是true。使用length属性才是判断有没有选中的正确方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;if ($(&amp;lsquo;div.foo&amp;rsquo;).length) { &amp;hellip; }&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）下标运算符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery选择器返回的是一个类似数组的对象。但是，使用下标运算符取出的单个对象，并不是jQuery对象的实例，而是一个DOM对象。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;)[0] instanceof jQuery // false
$(&amp;lsquo;li&amp;rsquo;)[0] instanceof Element // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，下标运算符取出的是Element节点的实例。所以，通常使用下标运算符将jQuery实例转回DOM对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）is方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;is方法返回一个布尔值，表示选中的结果是否符合某个条件。这个用来验证的条件，可以是CSS选择器，也可以是一个函数，或者DOM元素和jQuery实例。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).is(&amp;lsquo;li&amp;rsquo;) // true&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).is($(&amp;lsquo;.item&amp;rsquo;))&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).is(document.querySelector(&amp;lsquo;li&amp;rsquo;))&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).is(function() {
      return $(&amp;ldquo;strong&amp;rdquo;, this).length === 0;
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）get方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery实例的get方法是下标运算符的另一种写法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).get(0) instanceof Element // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）eq方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想要在结果集取出一个jQuery对象的实例，不需要取出DOM对象，则使用eq方法，它的参数是实例在结果集中的位置（从0开始）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).eq(0) instanceof jQuery // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;由于eq方法返回的是jQuery的实例，所以可以在返回结果上使用jQuery实例对象的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）each方法，map方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个方法用于遍历结果集，对每一个成员进行某种操作。&lt;/p&gt;

&lt;p&gt;each方法接受一个函数作为参数，依次处理集合中的每一个元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).each(function( index, element) {
  $(element).prepend( &amp;lsquo;&lt;em&gt;&amp;rsquo; + index + &amp;lsquo;: &lt;/em&gt;&amp;rsquo; );
});&lt;/p&gt;

&lt;p&gt;// &lt;li&gt;Hello&lt;/li&gt;
// &lt;li&gt;World&lt;/li&gt;
// 变为
// &lt;li&gt;&lt;em&gt;0: &lt;/em&gt;Hello&lt;/li&gt;
// &lt;li&gt;&lt;em&gt;1: &lt;/em&gt;World&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;从上面代码可以看出，作为each方法参数的函数，本身有两个参数，第一个是当前元素在集合中的位置，第二个是当前元素对应的DOM对象。&lt;/p&gt;

&lt;p&gt;map方法的用法与each方法完全一样，区别在于each方法没有返回值，只是对每一个元素执行某种操作，而map方法返回一个新的jQuery对象。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;input&amp;rdquo;).map(function (index, element){
    return $(this).val();
})
.get()
.join(&amp;ldquo;, &amp;ldquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，将所有input元素依次取出值，然后通过get方法得到一个包含这些值的数组，最后通过数组的join方法返回一个逗号分割的字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（8）内置循环&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery默认对当前结果集进行循环处理，所以如果直接使用jQuery内置的某种方法，each和map方法是不必要的。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;.class&amp;rdquo;).addClass(&amp;ldquo;highlight&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码会执行一个内部循环，对每一个选中的元素进行addClass操作。由于这个原因，对上面操作加上each方法是不必要的。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;.class&amp;rdquo;).each(function(index,element){
     $(element).addClass(&amp;ldquo;highlight&amp;rdquo;);
});&lt;/p&gt;

&lt;p&gt;// 或者&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;.class&amp;rdquo;).each(function(){
    $(this).addClass(&amp;ldquo;highlight&amp;rdquo;);
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码的each方法，都是没必要使用的。&lt;/p&gt;

&lt;p&gt;由于内置循环的存在，从性能考虑，应该尽量减少不必要的操作步骤。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;.class&amp;rdquo;).css(&amp;ldquo;color&amp;rdquo;, &amp;ldquo;green&amp;rdquo;).css(&amp;ldquo;font-size&amp;rdquo;, &amp;ldquo;16px&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;// 应该写成&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;.class&amp;rdquo;).css({
  &amp;ldquo;color&amp;rdquo;: &amp;ldquo;green&amp;rdquo;,
  &amp;ldquo;font-size&amp;rdquo;: &amp;ldquo;16px&amp;rdquo;
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;链式操作:99a497817131bf421a863230ef787bd1&#34;&gt;链式操作&lt;/h3&gt;

&lt;p&gt;jQuery最方便的一点就是，它的大部分方法返回的都是jQuery对象，因此可以链式操作。也就是说，后一个方法可以紧跟着写在前一个方法后面。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).click(function (){
    $(this).addClass(&amp;lsquo;clicked&amp;rsquo;);
})
.find(&amp;lsquo;span&amp;rsquo;)
.attr( &amp;lsquo;title&amp;rsquo;, &amp;lsquo;Hover over me&amp;rsquo; );&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;document-ready:99a497817131bf421a863230ef787bd1&#34;&gt;$(document).ready()&lt;/h3&gt;

&lt;p&gt;$(document).ready方法接受一个函数作为参数，将该参数作为document对象的DOMContentLoaded事件的回调函数。也就是说，当页面解析完成（即下载完&amp;lt;/html&amp;gt;标签）以后，在所有外部资源（图片、脚本等）完成加载之前，该函数就会立刻运行。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$( document ).ready(function() {
  console.log( &amp;lsquo;ready!&amp;rsquo; );
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，一旦页面完成解析，就会运行ready方法指定的函数，在控制台显示“ready!”。&lt;/p&gt;

&lt;p&gt;该方法通常作为网页初始化手段使用，jQuery提供了一种简写法，就是直接把回调函数放在jQuery对象中。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(function() {
  console.log( &amp;lsquo;ready!&amp;rsquo; );
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码与前一段代码是等价的。&lt;/p&gt;

&lt;h3 id=&#34;noconflict方法:99a497817131bf421a863230ef787bd1&#34;&gt;$.noConflict方法&lt;/h3&gt;

&lt;p&gt;jQuery使用美元符号（$）指代jQuery对象。某些情况下，其他函数库也会用到美元符号，为了避免冲突，$.noConflict方法允许将美元符号与jQuery脱钩。&lt;/p&gt;

&lt;p&gt;{% highlight html %}&lt;/p&gt;

&lt;script src=&#34;other_lib.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;jquery.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;$.noConflict();&lt;/script&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码就是$.noConflict方法的一般用法。在加载jQuery之后，立即调用该方法，会使得美元符号还给前面一个函数库。这意味着，其后再调用jQuery，只能写成jQuery.methond的形式，而不能用$.method了。&lt;/p&gt;

&lt;p&gt;为了避免冲突，可以考虑从一开始就只使用jQuery代替美元符号。&lt;/p&gt;

&lt;h2 id=&#34;jquery实例对象的方法:99a497817131bf421a863230ef787bd1&#34;&gt;jQuery实例对象的方法&lt;/h2&gt;

&lt;p&gt;除了上一节提到的is、get、eq方法，jQuery实例还有许多其他方法。&lt;/p&gt;

&lt;h3 id=&#34;结果集的过滤方法:99a497817131bf421a863230ef787bd1&#34;&gt;结果集的过滤方法&lt;/h3&gt;

&lt;p&gt;选择器选出一组符合条件的网页元素以后，jQuery提供了许多方法，可以过滤结果集，返回更准确的目标。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）first方法，last方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;first方法返回结果集的第一个成员，last方法返回结果集的最后一个成员。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;li&amp;rdquo;).first()&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;li&amp;rdquo;).last()&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）next方法，prev方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;next方法返回紧邻的下一个同级元素，prev方法返回紧邻的上一个同级元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;li&amp;quot;).first().next()
$(&amp;quot;li&amp;quot;).last().prev()

$(&amp;quot;li&amp;quot;).first().next(&#39;.item&#39;)
$(&amp;quot;li&amp;quot;).last().prev(&#39;.item&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果&lt;code&gt;next&lt;/code&gt;方法和&lt;code&gt;prev&lt;/code&gt;方法带有参数，表示选择符合该参数的同级元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）parent方法，parents方法，children方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;parent方法返回当前元素的父元素，parents方法返回当前元素的所有上级元素（直到html元素）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;p&amp;quot;).parent()
$(&amp;quot;p&amp;quot;).parent(&amp;quot;.selected&amp;quot;)

$(&amp;quot;p&amp;quot;).parents()
$(&amp;quot;p&amp;quot;).parents(&amp;quot;div&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;children方法返回选中元素的所有子元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;div&amp;quot;).children()
$(&amp;quot;div&amp;quot;).children(&amp;quot;.selected&amp;quot;)

// 下面的写法结果相同，但是效率较低

$(&#39;div &amp;gt; *&#39;)
$(&#39;div &amp;gt; .selected&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这三个方法都接受一个选择器作为参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）siblings方法，nextAll方法，prevAll方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;siblings方法返回当前元素的所有同级元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;).first().siblings()
$(&#39;li&#39;).first().siblings(&#39;.item&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nextAll方法返回当前元素其后的所有同级元素，prevAll方法返回当前元素前面的所有同级元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;).first().nextAll()
$(&#39;li&#39;).last().prevAll()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（5）closest方法，find方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;closest方法返回当前元素，以及当前元素的所有上级元素之中，第一个符合条件的元素。find方法返回当前元素的所有符合条件的下级元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;).closest(&#39;div&#39;)
$(&#39;div&#39;).find(&#39;li&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中的find方法，选中所有div元素下面的li元素，等同于$(&amp;lsquo;li&amp;rsquo;, &amp;lsquo;div&amp;rsquo;)。由于这样写缩小了搜索范围，所以要优于$(&amp;lsquo;div li&amp;rsquo;)的写法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）find方法，add方法，addBack方法，end方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;add方法用于为结果集添加元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).add(&amp;lsquo;p&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;addBack方法将当前元素加回原始的结果集。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).parent().addBack()&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;end方法用于返回原始的结果集。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).first().end()&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（7）filter方法，not方法，has方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;filter方法用于过滤结果集，它可以接受多种类型的参数，只返回与参数一致的结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 返回符合CSS选择器的结果
$(&#39;li&#39;).filter(&#39;.item&#39;)

// 返回函数返回值为true的结果
$(&amp;quot;li&amp;quot;).filter(function(index) {
    return index % 2 === 1;
})

// 返回符合特定DOM对象的结果
$(&amp;quot;li&amp;quot;).filter(document.getElementById(&amp;quot;unique&amp;quot;))

// 返回符合特定jQuery实例的结果
$(&amp;quot;li&amp;quot;).filter($(&amp;quot;#unique&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;not&lt;/code&gt;方法的用法与&lt;code&gt;filter&lt;/code&gt;方法完全一致，但是返回相反的结果，即过滤掉匹配项。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;).not(&#39;.item&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has方法与filter方法作用相同，但是只过滤出子元素符合条件的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;li&amp;quot;).has(&amp;quot;ul&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码返回具有ul子元素的li元素。&lt;/p&gt;

&lt;h3 id=&#34;dom相关方法:99a497817131bf421a863230ef787bd1&#34;&gt;DOM相关方法&lt;/h3&gt;

&lt;p&gt;许多方法可以对DOM元素进行处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）html方法和text方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html方法返回该元素包含的HTML代码，text方法返回该元素包含的文本。&lt;/p&gt;

&lt;p&gt;假定网页只含有一个p元素。&lt;/p&gt;

&lt;p&gt;{% highlight html %}&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hello World!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;html方法和text方法的返回结果分别如下。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).html()
// &lt;em&gt;Hello World!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).text()
// Hello World!&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;jQuery的许多方法都是取值器（getter）与赋值器（setter）的合一，即取值和赋值都是同一个方法，不使用参数的时候为取值器，使用参数的时候为赋值器。&lt;/p&gt;

&lt;p&gt;上面代码的html方法和text方法都没有参数，就会当作取值器使用，取回结果集的第一个元素所包含的内容。如果对这两个方法提供参数，就是当作赋值器使用，修改结果集所有成员的内容，并返回原来的结果集，以便进行链式操作。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).html(&amp;rsquo;&lt;strong&gt;你好&lt;/strong&gt;&amp;rsquo;)
// 网页代码变为&lt;p&gt;&lt;strong&gt;你好&lt;/strong&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).text(&amp;lsquo;你好&amp;rsquo;)
// 网页代码变为&lt;p&gt;你好&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;下面要讲到的jQuery其他许多方法，都采用这种同一个方法既是取值器又是赋值器的模式。&lt;/p&gt;

&lt;p&gt;html方法和text方法还可以接受一个函数作为参数，函数的返回值就是网页元素所要包含的新的代码和文本。这个函数接受两个参数，第一个是网页元素在集合中的位置，第二个参数是网页元素原来的代码或文本。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).html(function (i, v){
    return (i + &amp;lsquo;: &amp;lsquo; + v);&lt;br /&gt;
})&lt;/p&gt;

&lt;p&gt;// &lt;li&gt;Hello&lt;/li&gt;
// &lt;li&gt;World&lt;/li&gt;
// 变为
// &lt;li&gt;0: Hello&lt;/li&gt;
// &lt;li&gt;1: World&lt;/li&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）addClass方法，removeClass方法，toggleClass方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;addClass方法用于添加一个类，removeClass方法用于移除一个类，toggleClass方法用于折叠一个类（如果无就添加，如果有就移除）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).addClass(&amp;lsquo;special&amp;rsquo;)
$(&amp;lsquo;li&amp;rsquo;).removeClass(&amp;lsquo;special&amp;rsquo;)
$(&amp;lsquo;li&amp;rsquo;).toggleClass(&amp;lsquo;special&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）css方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css方法用于改变CSS设置。&lt;/p&gt;

&lt;p&gt;该方法可以作为取值器使用。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;h1&amp;rsquo;).css(&amp;lsquo;fontSize&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;css方法的参数是css属性名。这里需要注意，CSS属性名的CSS写法和DOM写法，两者都可以接受，比如font-size和fontSize都行。&lt;/p&gt;

&lt;p&gt;css方法也可以作为赋值器使用。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).css(&amp;lsquo;padding-left&amp;rsquo;, &amp;lsquo;20px&amp;rsquo;)
// 或者
$(&amp;lsquo;li&amp;rsquo;).css({
  &amp;lsquo;padding-left&amp;rsquo;: &amp;lsquo;20px&amp;rsquo;
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面两种形式都可以用于赋值，jQuery赋值器基本上都是如此。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）val方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;val方法返回结果集第一个元素的值，或者设置当前结果集所有元素的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;input[type=&amp;quot;text&amp;quot;]&#39;).val()
$(&#39;input[type=&amp;quot;text&amp;quot;]&#39;).val(&#39;new value&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（5）prop方法，attr方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，这里要区分两种属性。&lt;/p&gt;

&lt;p&gt;一种是网页元素的属性，比如&lt;code&gt;a&lt;/code&gt;元素的&lt;code&gt;href&lt;/code&gt;属性、&lt;code&gt;img&lt;/code&gt;元素的&lt;code&gt;src&lt;/code&gt;属性。这要使用&lt;code&gt;attr&lt;/code&gt;方法读写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 读取属性值
$(&#39;textarea&#39;).attr(name)

//写入属性值
$(&#39;textarea&#39;).attr(name, val)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是通过设置&lt;code&gt;a&lt;/code&gt;元素的&lt;code&gt;target&lt;/code&gt;属性，使得网页上的外部链接在新窗口打开的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;a[href^=&amp;quot;http&amp;quot;]&#39;).attr(&#39;target&#39;, &#39;_blank&#39;);
$(&#39;a[href^=&amp;quot;//&amp;quot;]&#39;).attr(&#39;target&#39;, &#39;_blank&#39;);
$(&#39;a[href^=&amp;quot;&#39; + window.location.origin + &#39;&amp;quot;]&#39;).attr(&#39;target&#39;, &#39;_self&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种是DOM元素的属性，比如&lt;code&gt;tagName&lt;/code&gt;、&lt;code&gt;nodeName&lt;/code&gt;、&lt;code&gt;nodeType&lt;/code&gt;等等。这要使用&lt;code&gt;prop&lt;/code&gt;方法读写。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 读取属性值
$(&#39;textarea&#39;).prop(name)

// 写入属性值
$(&#39;textarea&#39;).prop(name, val)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，&lt;code&gt;attr&lt;/code&gt;方法和&lt;code&gt;prop&lt;/code&gt;方法针对的是不同的属性。在英语中，&lt;code&gt;attr&lt;/code&gt;是attribute的缩写，&lt;code&gt;prop&lt;/code&gt;是property的缩写，中文很难表达出这种差异。有时，&lt;code&gt;attr&lt;/code&gt;方法和&lt;code&gt;prop&lt;/code&gt;方法对同一个属性会读到不一样的值。比如，网页上有一个单选框。&lt;/p&gt;

&lt;p&gt;{% highlight html %}&lt;/p&gt;

&lt;p&gt;&lt;input type=&#34;checkbox&#34; checked=&#34;checked&#34; /&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;对于checked属性，attr方法读到的是checked，prop方法读到的是true。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(input[type=checkbox]).attr(&amp;ldquo;checked&amp;rdquo;) // &amp;ldquo;checked&amp;rdquo;&lt;/p&gt;

&lt;p&gt;$(input[type=checkbox]).prop(&amp;ldquo;checked&amp;rdquo;) // true&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;可以看到，attr方法读取的是网页上该属性的值，而prop方法读取的是DOM元素的该属性的值，根据规范，element.checked应该返回一个布尔值。所以，判断单选框是否选中，要使用prop方法。事实上，不管这个单选框是否选中，attr(&amp;ldquo;checked&amp;rdquo;)的返回值都是checked。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;if ($(elem).prop(&amp;ldquo;checked&amp;rdquo;)) { /*&amp;hellip; */ };&lt;/p&gt;

&lt;p&gt;// 下面两种方法亦可&lt;/p&gt;

&lt;p&gt;if ( elem.checked ) { /&lt;em&gt;&amp;hellip;&lt;/em&gt;/ };
if ( $(elem).is(&amp;rdquo;:checked&amp;rdquo;) ) { /&lt;em&gt;&amp;hellip;&lt;/em&gt;/ };&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）removeProp方法，removeAttr方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;removeProp方法移除某个DOM属性，removeAttr方法移除某个HTML属性。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;a&amp;rdquo;).prop(&amp;ldquo;oldValue&amp;rdquo;,1234).removeProp(&amp;lsquo;oldValue&amp;rsquo;)
$(&amp;lsquo;a&amp;rsquo;).removeAttr(&amp;ldquo;title&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（7）data方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;data方法用于在一个DOM对象上储存数据。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// 储存数据
$(&amp;ldquo;body&amp;rdquo;).data(&amp;ldquo;foo&amp;rdquo;, 52);&lt;/p&gt;

&lt;p&gt;// 读取数据
$(&amp;ldquo;body&amp;rdquo;).data(&amp;ldquo;foo&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;该方法可以在DOM节点上储存各种类型的数据。&lt;/p&gt;

&lt;h3 id=&#34;添加-复制和移动网页元素的方法:99a497817131bf421a863230ef787bd1&#34;&gt;添加、复制和移动网页元素的方法&lt;/h3&gt;

&lt;p&gt;jQuery方法提供一系列方法，可以改变元素在文档中的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）append方法，appendTo方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;append方法将参数中的元素插入当前元素的尾部。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;div&amp;rdquo;).append(&amp;rdquo;&lt;p&gt;World&lt;/p&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;div&gt;Hello &lt;/div&gt;
// 变为
// &lt;div&gt;Hello &lt;p&gt;World&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;appendTo方法将当前元素插入参数中的元素尾部。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;rdquo;&lt;p&gt;World&lt;/p&gt;&amp;rdquo;).appendTo(&amp;ldquo;div&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码返回与前一个例子一样的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）prepend方法，prependTo方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;prepend方法将参数中的元素，变为当前元素的第一个子元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).prepend(&amp;ldquo;Hello &amp;ldquo;)&lt;/p&gt;

&lt;p&gt;// &lt;p&gt;World&lt;/p&gt;
// 变为
// &lt;p&gt;Hello World&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;如果prepend方法的参数不是新生成的元素，而是当前页面已存在的元素，则会产生移动元素的效果。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).prepend(&amp;ldquo;strong&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;strong&gt;Hello &lt;/strong&gt;&lt;p&gt;World&lt;/p&gt;
// 变为
// &lt;p&gt;&lt;strong&gt;Hello &lt;/strong&gt;World&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码运行后，strong元素的位置将发生移动，而不是克隆一个新的strong元素。不过，如果当前结果集包含多个元素，则除了第一个以后，后面的p元素都将插入一个克隆的strong子元素。&lt;/p&gt;

&lt;p&gt;prependTo方法将当前元素变为参数中的元素的第一个子元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;rdquo;&lt;p&gt;&lt;/p&gt;&amp;rdquo;).prependTo(&amp;ldquo;div&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;div&gt;&lt;/div&gt;
// 变为
// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）after方法，insertAfter方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;after方法将参数中的元素插在当前元素后面。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;div&amp;rdquo;).after(&amp;rdquo;&lt;p&gt;&lt;/p&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;div&gt;&lt;/div&gt;
// 变为
// &lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;insertAfter方法将当前元素插在参数中的元素后面。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;rdquo;&lt;p&gt;&lt;/p&gt;&amp;rdquo;).insertAfter(&amp;ldquo;div&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码返回与前一个例子一样的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）before方法，insertBefore方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;before方法将参数中的元素插在当前元素的前面。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;div&amp;rdquo;).before(&amp;rdquo;&lt;p&gt;&lt;/p&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;div&gt;&lt;/div&gt;
// 变为
// &lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;insertBefore方法将当前元素插在参数中的元素的前面。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;rdquo;&lt;p&gt;&lt;/p&gt;&amp;rdquo;).insertBefore(&amp;ldquo;div&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码返回与前一个例子一样的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5）wrap方法，wrapAll方法，unwrap方法，wrapInner方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;wrap方法将参数中的元素变成当前元素的父元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).wrap(&amp;rdquo;&lt;div&gt;&lt;/div&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;p&gt;&lt;/p&gt;
// 变为
// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;wrap方法的参数还可以是一个函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).wrap(function() {
  return &amp;ldquo;&lt;div&gt;&lt;/div&gt;&amp;rdquo;;
})&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码返回与前一个例子一样的结果。&lt;/p&gt;

&lt;p&gt;wrapAll方法为结果集的所有元素，添加一个共同的父元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).wrapAll(&amp;rdquo;&lt;div&gt;&lt;/div&gt;&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;// &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
// 变为
// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;unwrap方法移除当前元素的父元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).unwrap()&lt;/p&gt;

&lt;p&gt;// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;
// 变为
// &lt;p&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;wrapInner方法为当前元素的所有子元素，添加一个父元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;p&amp;rdquo;).wrapInner(&amp;rsquo;&lt;strong&gt;&lt;/strong&gt;&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;// &lt;p&gt;Hello&lt;/p&gt;
// 变为
// &lt;p&gt;&lt;strong&gt;Hello&lt;/strong&gt;&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（6）clone方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;clone方法克隆当前元素。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var clones = $(&amp;lsquo;li&amp;rsquo;).clone();&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;对于那些有id属性的节点，clone方法会连id属性一起克隆。所以，要把克隆的节点插入文档的时候，务必要修改或移除id属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（7）remove方法，detach方法，replaceWith方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;remove方法移除并返回一个元素，取消该元素上所有事件的绑定。detach方法也是移除并返回一个元素，但是不取消该元素上所有事件的绑定。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).remove()
$(&amp;lsquo;p&amp;rsquo;).detach()&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;replaceWith方法用参数中的元素，替换并返回当前元素，取消当前元素的所有事件的绑定。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;p&amp;rsquo;).replaceWith(&amp;rsquo;&lt;div&gt;&lt;/div&gt;&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;动画效果方法:99a497817131bf421a863230ef787bd1&#34;&gt;动画效果方法&lt;/h3&gt;

&lt;p&gt;jQuery提供一些方法，可以很容易地显示网页动画效果。但是，总体上来说，它们不如CSS动画强大和节省资源，所以应该优先考虑使用CSS动画。&lt;/p&gt;

&lt;p&gt;如果将jQuery.fx.off设为true，就可以将所有动画效果关闭，使得网页元素的各种变化一步到位，没有中间过渡的动画效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）动画效果的简便方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery提供以下一些动画效果方法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;show：显示当前元素。&lt;/li&gt;
&lt;li&gt;hide：隐藏当前元素。&lt;/li&gt;
&lt;li&gt;toggle：显示或隐藏当前元素。&lt;/li&gt;
&lt;li&gt;fadeIn：将当前元素的不透明度（opacity）逐步提升到100%。&lt;/li&gt;
&lt;li&gt;fadeOut：将当前元素的不透明度逐步降为0%。&lt;/li&gt;
&lt;li&gt;fadeToggle：以逐渐透明或逐渐不透明的方式，折叠显示当前元素。&lt;/li&gt;
&lt;li&gt;slideDown：以从上向下滑入的方式显示当前元素。&lt;/li&gt;
&lt;li&gt;slideUp：以从下向上滑出的方式隐藏当前元素。&lt;/li&gt;
&lt;li&gt;slideToggle：以垂直滑入或滑出的方式，折叠显示当前元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这些方法可以不带参数调用，也可以接受毫秒或预定义的关键字作为参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;.hidden&#39;).show();
$(&#39;.hidden&#39;).show(300);
$(&#39;.hidden&#39;).show(&#39;slow&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面三行代码分别表示，以默认速度、300毫秒、较慢的速度隐藏一个元素。&lt;/p&gt;

&lt;p&gt;jQuery预定义的关键字是在&lt;code&gt;jQuery.fx.speeds&lt;/code&gt;对象上面，可以自行改动这些值，或者创造新的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;jQuery.fx.speeds.fast = 50;
jQuery.fx.speeds.slow = 3000;
jQuery.fx.speeds.normal = 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面三行代码重新定义fast、normal、slow关键字对应的毫秒数。&lt;/p&gt;

&lt;p&gt;你还可以定义自己的关键字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;jQuery.fx.speeds.blazing = 30;

// 调用
$(&#39;.hidden&#39;).show(&#39;blazing&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些方法还可以接受一个函数，作为第二个参数，表示动画结束后的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;p&#39;).fadeOut(300, function() {
  $(this).remove();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，&lt;code&gt;p&lt;/code&gt;元素以300毫秒的速度淡出，然后调用回调函数，将其从DOM中移除。&lt;/p&gt;

&lt;p&gt;使用按钮控制某个元素折叠显示的代码如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Fade
$(&#39;.btn&#39;).click(function () {
  $(&#39;.element&#39;).fadeToggle(&#39;slow&#39;);
});

// Toggle
$(&#39;.btn&#39;).click(function () {
  $(&#39;.element&#39;).slideToggle(&#39;slow&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;（2）animate方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面这些动画效果方法，实际上都是animate方法的简便写法。在幕后，jQuery都是统一使用animate方法生成各种动画效果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;a.top&#39;).click(function (e) {
  e.preventDefault();
  $(&#39;html, body&#39;).animate({scrollTop: 0}, 800);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码是点击链接，回到页面头部的写法。其中，&lt;code&gt;animate&lt;/code&gt;方法接受两个参数，第一个参数是一个对象，表示动画结束时相关CSS属性的值，第二个参数是动画持续的毫秒数。需要注意的是，第一个参数对象的成员名称，必须与CSS属性名称一致，如果CSS属性名称带有连字号，则需要用“骆驼拼写法”改写。&lt;/p&gt;

&lt;p&gt;animate方法还可以接受第三个参数，表示动画结束时的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;div&#39;).animate({
    left: &#39;+=50&#39;, // 增加50
    opacity: 0.25,
    fontSize: &#39;12px&#39;
  },
  300, // 持续时间
  function() { // 回调函数
     console.log(&#39;done!&#39;);
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，动画结束时，在控制台输出“done！”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）stop方法，delay方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;stop方法表示立即停止执行当前的动画。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;#stop&amp;rdquo;).click(function() {
  $(&amp;ldquo;.block&amp;rdquo;).stop();
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，点击按钮后，block元素的动画效果停止。&lt;/p&gt;

&lt;p&gt;delay方法接受一个时间参数，表示暂停多少毫秒后继续执行。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;#foo&amp;rdquo;).slideUp(300).delay(800).fadeIn(400)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，slideUp动画之后，暂停800毫秒，然后继续执行fadeIn动画。&lt;/p&gt;

&lt;h3 id=&#34;其他方法:99a497817131bf421a863230ef787bd1&#34;&gt;其他方法&lt;/h3&gt;

&lt;p&gt;jQuery还提供一些供特定元素使用的方法。&lt;/p&gt;

&lt;p&gt;serialize方法用于将表单元素的值，转为url使用的查询字符串。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$( &amp;ldquo;form&amp;rdquo; ).on( &amp;ldquo;submit&amp;rdquo;, function( event ) {
  event.preventDefault();
  console.log( $( this ).serialize() );
});
// single=Single&amp;amp;multiple=Multiple&amp;amp;check=check2&amp;amp;radio=radio1&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;serializeArray方法用于将表单元素的值转为数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;form&amp;quot;).submit(function (event){
  console.log($(this).serializeArray());
  event.preventDefault();
});
//  [
//      {name : &#39;field1&#39;, value : 123},
//      {name : &#39;field2&#39;, value : &#39;hello world&#39;}
//  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;事件处理:99a497817131bf421a863230ef787bd1&#34;&gt;事件处理&lt;/h2&gt;

&lt;h3 id=&#34;事件绑定的简便方法:99a497817131bf421a863230ef787bd1&#34;&gt;事件绑定的简便方法&lt;/h3&gt;

&lt;p&gt;jQuery提供一系列方法，允许直接为常见事件绑定回调函数。比如，click方法可以为一个元素绑定click事件的回调函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).click(function (e){
  console.log($(this).text());
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码为li元素绑定click事件的回调函数，点击后在控制台显示li元素包含的文本。&lt;/p&gt;

&lt;p&gt;这样绑定事件的简便方法有如下一些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;click&lt;/li&gt;
&lt;li&gt;keydown&lt;/li&gt;
&lt;li&gt;keypress&lt;/li&gt;
&lt;li&gt;keyup&lt;/li&gt;
&lt;li&gt;mouseover&lt;/li&gt;
&lt;li&gt;mouseout&lt;/li&gt;
&lt;li&gt;mouseenter&lt;/li&gt;
&lt;li&gt;mouseleave&lt;/li&gt;
&lt;li&gt;scroll&lt;/li&gt;
&lt;li&gt;focus&lt;/li&gt;
&lt;li&gt;blur&lt;/li&gt;
&lt;li&gt;resize&lt;/li&gt;
&lt;li&gt;hover&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不带参数调用这些方法，就是触发相应的事件，从而引发回调函数的运行。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).click()&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码将触发click事件的回调函数。&lt;/p&gt;

&lt;p&gt;需要注意的是，通过这种方法触发回调函数，将不会引发浏览器对该事件的默认行为。比如，对a元素调用click方法，将只触发事先绑定的回调函数，而不会导致浏览器将页面导向href属性指定的网址。&lt;/p&gt;

&lt;p&gt;下面是一个捕捉用户按下escape键的函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
$(document).keyup(function(e) {
  if (e.keyCode == 27) {
    $(&#39;body&#39;).toggleClass(&#39;show-nav&#39;);
    // $(&#39;body&#39;).removeClass(&#39;show-nav&#39;);
  }
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，用户按下escape键，jQuery就会为body元素添加/去除名为show-nav的class。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hover&lt;/code&gt;方法需要特别说明。它接受两个回调函数作为参数，分别代表&lt;code&gt;mouseenter&lt;/code&gt;和&lt;code&gt;mouseleave&lt;/code&gt;事件的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(selector).hover(handlerIn, handlerOut)
// 等同于
$(selector).mouseenter(handlerIn).mouseleave(handlerOut)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是一个例子，当按钮发生&lt;code&gt;hover&lt;/code&gt;事件，添加一个class样式，当&lt;code&gt;hover&lt;/code&gt;事件结束时，再取消这个class。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;.btn&#39;).hover(function () {
  $(this).addClass(&#39;hover&#39;);
}, function () {
  $(this).removeClass(&#39;hover&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;toggleClass&lt;/code&gt;可以简化上面的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;.btn&#39;).hover(function () {
  $(this).toggleClass(&#39;hover&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;on方法-trigger方法-off方法:99a497817131bf421a863230ef787bd1&#34;&gt;on方法，trigger方法，off方法&lt;/h3&gt;

&lt;p&gt;除了简便方法，jQuery还提供事件处理的通用方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）on方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;on&lt;/code&gt;方法是jQuery事件绑定的统一接口。事件绑定的那些简便方法，其实都是&lt;code&gt;on&lt;/code&gt;方法的简写形式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;on&lt;/code&gt;方法接受两个参数，第一个是事件名称，第二个是回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;li&#39;).on(&#39;click&#39;, function (e){
  console.log($(this).text());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为&lt;code&gt;li&lt;/code&gt;元素绑定&lt;code&gt;click&lt;/code&gt;事件的回调函数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，在回调函数内部，&lt;code&gt;this&lt;/code&gt;关键字指的是发生该事件的DOM对象。为了使用jQuery提供的方法，必须将DOM对象转为jQuery对象，因此写成&lt;code&gt;$(this)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;on&lt;/code&gt;方法允许一次为多个事件指定同样的回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;input[type=&amp;quot;text&amp;quot;]&#39;).on(&#39;focus blur&#39;, function (){
  console.log(&#39;focus or blur&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为文本框的&lt;code&gt;focus&lt;/code&gt;和&lt;code&gt;blur&lt;/code&gt;事件绑定同一个回调函数。&lt;/p&gt;

&lt;p&gt;下面是一个例子，当图片加载失败，使用&lt;code&gt;error&lt;/code&gt;事件，替换另一张图片。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;img&#39;).on(&#39;error&#39;, function () {
  if(!$(this).hasClass(&#39;broken-image&#39;)) {
    $(this).prop(&#39;src&#39;, &#39;img/broken.png&#39;).addClass(&#39;broken-image&#39;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是检查用户是否切换浏览器tab的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).on(&#39;visibilitychange&#39;, function (e) {
  if (e.target.visibilityState === &amp;quot;visible&amp;quot;) {
    console.log(&#39;Tab is now in view!&#39;);
  } else if (e.target.visibilityState === &amp;quot;hidden&amp;quot;) {
    console.log(&#39;Tab is now hidden!&#39;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;on&lt;/code&gt;方法还可以为当前元素的某一个子元素，添加回调函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;ul&#39;).on(&#39;click&#39;, &#39;li&#39;, function (e){
  console.log(this);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码为&lt;code&gt;ul&lt;/code&gt;的子元素&lt;code&gt;li&lt;/code&gt;绑定click事件的回调函数。采用这种写法时，on方法接受三个参数，子元素选择器作为第二个参数，夹在事件名称和回调函数之间。&lt;/p&gt;

&lt;p&gt;这种写法有两个好处。首先，click事件还是在ul元素上触发回调函数，但是会检查event对象的target属性是否为li子元素，如果为true，再调用回调函数。这样就比为li元素一一绑定回调函数，节省了内存空间。其次，这种绑定的回调函数，对于在绑定后生成的li元素依然有效。&lt;/p&gt;

&lt;p&gt;on方法还允许向回调函数传入数据。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&amp;quot;ul&amp;quot; ).on(&amp;quot;click&amp;quot;, {name: &amp;quot;张三&amp;quot;}, function (event){
    console.log(event.data.name);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码在发生click事件之后，会通过event对象的data属性，在控制台打印出所传入的数据（即“张三”）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）trigger方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;trigger方法用于触发回调函数，它的参数就是事件的名称。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).trigger(&amp;lsquo;click&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码触发li元素的click事件回调函数。与那些简便方法一样，trigger方法只触发回调函数，而不会引发浏览器的默认行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）off方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;off方法用于移除事件的回调函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).off(&amp;lsquo;click&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码移除li元素所有的click事件回调函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）事件的名称空间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同一个事件有时绑定了多个回调函数，这时如果想移除其中的一个回调函数，可以采用“名称空间”的方式，即为每一个回调函数指定一个二级事件名，然后再用off方法移除这个二级事件的回调函数。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).on(&amp;lsquo;click.logging&amp;rsquo;, function (){
  console.log(&amp;lsquo;click.logging callback removed&amp;rsquo;);
});&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).off(&amp;lsquo;click.logging&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码为li元素定义了二级事件click.logging的回调函数，click.logging属于click名称空间，当发生click事件时会触发该回调函数。将click.logging作为off方法的参数，就会移除这个回调函数，但是对其他click事件的回调函数没有影响。&lt;/p&gt;

&lt;p&gt;trigger方法也适用带名称空间的事件。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;li&amp;rsquo;).trigger(&amp;lsquo;click.logging&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;event对象:99a497817131bf421a863230ef787bd1&#34;&gt;event对象&lt;/h3&gt;

&lt;p&gt;当回调函数被触发后，它们的参数通常是一个事件对象event。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(document).on(&amp;lsquo;click&amp;rsquo;, function (e){
    // &amp;hellip;
});&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码的回调函数的参数e，就代表事件对象event。&lt;/p&gt;

&lt;p&gt;event对象有以下属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type：事件类型，比如click。&lt;/li&gt;
&lt;li&gt;which：触发该事件的鼠标按钮或键盘的键。&lt;/li&gt;
&lt;li&gt;target：事件发生的初始对象。&lt;/li&gt;
&lt;li&gt;data：传入事件对象的数据。&lt;/li&gt;
&lt;li&gt;pageX：事件发生时，鼠标位置的水平坐标（相对于页面左上角）。&lt;/li&gt;
&lt;li&gt;pageY：事件发生时，鼠标位置的垂直坐标（相对于页面左上角）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;event对象有以下方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;preventDefault：取消浏览器默认行为。&lt;/li&gt;
&lt;li&gt;stopPropagation：阻止事件向上层元素传播。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一次性事件:99a497817131bf421a863230ef787bd1&#34;&gt;一次性事件&lt;/h3&gt;

&lt;p&gt;one方法指定一次性的回调函数，即这个函数只能运行一次。这对提交表单很有用。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;$(&amp;ldquo;#button&amp;rdquo;).one( &amp;ldquo;click&amp;rdquo;, function() { return false; } );&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;one方法本质上是回调函数运行一次，即解除对事件的监听。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;document.getElementById(&amp;ldquo;#button&amp;rdquo;).addEventListener(&amp;ldquo;click&amp;rdquo;, handler);&lt;/p&gt;

&lt;p&gt;function handler(e) {
    e.target.removeEventListener(e.type, arguments.callee);
    return false;
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面的代码在点击一次以后，取消了对click事件的监听。如果有特殊需要，可以设定点击2次或3次之后取消监听，这都是可以的。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:99a497817131bf421a863230ef787bd1&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Elijah Manor, &lt;a href=&#34;http://www.elijahmanor.com/2013/01/yo-dawg-i-herd-you-like-loops-so-jquery.html&#34;&gt;Do You Know When You Are Looping in jQuery?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Craig Buckler, &lt;a href=&#34;http://www.sitepoint.com/create-one-time-events-javascript/&#34;&gt;How to Create One-Time Events in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;jQuery Fundamentals, &lt;a href=&#34;http://jqfundamentals.com/chapter/jquery-basics&#34;&gt;jQuery Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;jQuery Fundamentals, &lt;a href=&#34;http://jqfundamentals.com/chapter/effects&#34;&gt;Animating Your Pages with jQuery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>11、Node.js</title>
      <link>http://575087694.github.io/post/index10/</link>
      <pubDate>Tue, 21 Jan 2014 05:04:40 +0000</pubDate>
      
      <guid>http://575087694.github.io/post/index10/</guid>
      <description>

&lt;h2 id=&#34;简介:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Node是JavaScript语言的服务器运行环境。&lt;/p&gt;

&lt;p&gt;所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。&lt;/p&gt;

&lt;p&gt;Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。&lt;/p&gt;

&lt;h3 id=&#34;安装与更新:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;安装与更新&lt;/h3&gt;

&lt;p&gt;访问官方网站&lt;a href=&#34;http://nodejs.org&#34;&gt;nodejs.org&lt;/a&gt;或者&lt;a href=&#34;https://github.com/nodesource/distributions&#34;&gt;github.com/nodesource/distributions&lt;/a&gt;，查看Node的最新版本和安装方法。&lt;/p&gt;

&lt;p&gt;官方网站提供编译好的二进制包，可以把它们解压到&lt;code&gt;/usr/local&lt;/code&gt;目录下面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ tar -xf node-someversion.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，建立符号链接，把它们加到$PATH变量里面的路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ln -s /usr/local/node/bin/node /usr/local/bin/node
$ ln -s /usr/local/node/bin/npm /usr/local/bin/npm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是Ubuntu和Debian下面安装Deb软件包的安装方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -
$ sudo apt-get install -y nodejs

$ apt-get install nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成以后，运行下面的命令，查看是否能正常运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node --version
# 或者
$ node -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新node.js版本，可以通过node.js的&lt;code&gt;n&lt;/code&gt;模块完成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo npm install n -g
$ sudo n stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码通过&lt;code&gt;n&lt;/code&gt;模块，将node.js更新为最新发布的稳定版。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;n&lt;/code&gt;模块也可以指定安装特定版本的node。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo n 0.10.21
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;版本管理工具nvm:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;版本管理工具nvm&lt;/h3&gt;

&lt;p&gt;如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://github.com/creationix/nvm.git ~/.nvm
$ source ~/.nvm/nvm.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 安装最新版本
$ nvm install node

# 安装指定版本
$ nvm install 0.12.1

# 使用已安装的最新版本
$ nvm use node

# 使用指定版本的node
$ nvm use 0.12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nvm也允许进入指定版本的REPL环境。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ nvm run 0.12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，就只输入&lt;code&gt;nvm use&lt;/code&gt;命令即可，不再需要附加版本号。&lt;/p&gt;

&lt;p&gt;下面是其他经常用到的命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 查看本地安装的所有版本
$ nvm ls

# 查看服务器上所有可供安装的版本。
$ nvm ls-remote

# 退出已经激活的nvm，使用deactivate命令。
$ nvm deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基本用法:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;基本用法&lt;/h3&gt;

&lt;p&gt;安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。&lt;/p&gt;

&lt;p&gt;当前目录的&lt;code&gt;demo.js&lt;/code&gt;脚本文件，可以这样执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node demo
# 或者
$ node demo.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;-e&lt;/code&gt;参数，可以执行代码字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node -e &#39;console.log(&amp;quot;Hello World&amp;quot;)&#39;
Hello World
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;repl环境:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;REPL环境&lt;/h3&gt;

&lt;p&gt;在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，&amp;rdquo;读取-求值-输出&amp;rdquo;循环），可以直接运行各种JavaScript命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node
&amp;gt; 1+1
2
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用参数 &amp;ndash;use_strict，则REPL将在严格模式下运行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node --use_strict
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。&lt;/p&gt;

&lt;p&gt;特殊变量下划线（_）表示上一个命令的返回结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; 1 + 1
2
&amp;gt; _ + 1
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在REPL中，如果运行一个表达式，会直接在命令行返回结果。如果运行一条语句，就不会有任何输出，因为语句没有返回值。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;x = 1
1
var x = 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。&lt;/p&gt;

&lt;h3 id=&#34;异步操作:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;异步操作&lt;/h3&gt;

&lt;p&gt;Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。&lt;/p&gt;

&lt;p&gt;由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var isTrue = function(value, callback) {
  if (value === true) {
    callback(null, &amp;ldquo;Value was true.&amp;rdquo;);
  }
  else {
    callback(new Error(&amp;ldquo;Value is not true!&amp;rdquo;));
  }
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码就把进一步的处理，交给回调函数callback。&lt;/p&gt;

&lt;p&gt;Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var callback = function (error, value) {
  if (error) {
    return console.log(error);
  }
  console.log(value);
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try&amp;hellip;catch对于异步操作行不通，所以只能把错误交给回调函数处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {
  db.User.get(userId, function(err, user) {
    if(err) {
      throw err
    }
    // ...
  })
} catch(e) {
  console.log(‘Oh no!’);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try&amp;hellip;catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。&lt;/p&gt;

&lt;p&gt;如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if(err) {
  // 除了放过No Permission错误意外，其他错误传给下一个回调函数
  if(!err.noPermission) {
    return next(err);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;全局对象和全局变量:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;全局对象和全局变量&lt;/h3&gt;

&lt;p&gt;Node提供以下几个全局对象，它们是所有模块都可以调用的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;global&lt;/strong&gt;：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如&lt;code&gt;var x = 1&lt;/code&gt;等同于设置&lt;code&gt;window.x = 1&lt;/code&gt;，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明&lt;code&gt;var x = 1&lt;/code&gt;，该变量不是&lt;code&gt;global&lt;/code&gt;对象的属性，&lt;code&gt;global.x&lt;/code&gt;等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;process&lt;/strong&gt;：该对象表示Node所处的当前进程，允许开发者与该进程互动。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;console&lt;/strong&gt;：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Node还提供一些全局函数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;setTimeout()&lt;/strong&gt;：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clearTimeout()&lt;/strong&gt;：用于终止一个setTimeout方法新建的定时器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;setInterval()&lt;/strong&gt;：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clearInterval()&lt;/strong&gt;：终止一个用setInterval方法新建的定时器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;require()&lt;/strong&gt;：用于加载模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Buffer()&lt;/strong&gt;：用于操作二进制数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Node提供两个全局变量，都以两个下划线开头。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__filename&lt;/code&gt;：指向当前运行的脚本文件名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__dirname&lt;/code&gt;：指向当前运行的脚本所在的目录。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。&lt;/p&gt;

&lt;h2 id=&#34;模块化结构:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;模块化结构&lt;/h2&gt;

&lt;h3 id=&#34;概述:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;概述&lt;/h3&gt;

&lt;p&gt;Node.js采用模块化结构，按照&lt;a href=&#34;http://wiki.commonjs.org/wiki/CommonJS&#34;&gt;CommonJS规范&lt;/a&gt;定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。&lt;/p&gt;

&lt;p&gt;require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var circle = require(&amp;lsquo;./circle.js&amp;rsquo;);
// 或者
var circle = require(&amp;lsquo;./circle&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;var bar = require(&amp;lsquo;bar&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;{
  &amp;ldquo;name&amp;rdquo; : &amp;ldquo;bar&amp;rdquo;,
  &amp;ldquo;main&amp;rdquo; : &amp;ldquo;./lib/bar.js&amp;rdquo;
}&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码中，模块的启动文件为lib子目录下的bar.js。当使用&lt;code&gt;require(&#39;bar&#39;)&lt;/code&gt;命令加载该模块时，实际上加载的是&lt;code&gt;./node_modules/bar/lib/bar.js&lt;/code&gt;文件。下面写法会起到同样效果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
var bar = require(&#39;bar/lib/bar.js&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。&lt;/p&gt;

&lt;p&gt;模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。&lt;/p&gt;

&lt;h3 id=&#34;核心模块:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;核心模块&lt;/h3&gt;

&lt;p&gt;如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;http&lt;/strong&gt;：提供HTTP服务器功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;url&lt;/strong&gt;：解析URL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fs&lt;/strong&gt;：与文件系统交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;querystring&lt;/strong&gt;：解析URL的查询字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;child_process&lt;/strong&gt;：新建子进程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;util&lt;/strong&gt;：提供一系列实用小工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path&lt;/strong&gt;：处理文件路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;crypto&lt;/strong&gt;：提供加密和解密功能，基本上是对OpenSSL的包装。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。&lt;/p&gt;

&lt;p&gt;核心模块总是最优先加载的。如果你自己写了一个HTTP模块，&lt;code&gt;require(&#39;http&#39;)&lt;/code&gt;加载的还是核心模块。&lt;/p&gt;

&lt;h3 id=&#34;自定义模块:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;自定义模块&lt;/h3&gt;

&lt;p&gt;Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。&lt;/p&gt;

&lt;p&gt;下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// foo.js&lt;/p&gt;

&lt;p&gt;module.exports = function(x) {
    console.log(x);
};&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。&lt;/p&gt;

&lt;p&gt;这个模块的使用方法如下。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// index.js&lt;/p&gt;

&lt;p&gt;var m = require(&amp;lsquo;./foo&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;m(&amp;ldquo;这是自定义模块&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;p&gt;$ node index
这是自定义模块&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// foo.js&lt;/p&gt;

&lt;p&gt;var out = new Object();&lt;/p&gt;

&lt;p&gt;function p(string) {
  console.log(string);
}&lt;/p&gt;

&lt;p&gt;out.print = p;&lt;/p&gt;

&lt;p&gt;module.exports = out;&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。&lt;/p&gt;

&lt;p&gt;{% highlight javascript %}&lt;/p&gt;

&lt;p&gt;// index.js&lt;/p&gt;

&lt;p&gt;var m = require(&amp;lsquo;./foo&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;m.print(&amp;ldquo;这是自定义模块&amp;rdquo;);&lt;/p&gt;

&lt;p&gt;{% endhighlight %}&lt;/p&gt;

&lt;p&gt;上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。&lt;/p&gt;

&lt;h2 id=&#34;异常处理:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;异常处理&lt;/h2&gt;

&lt;p&gt;Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。&lt;/p&gt;

&lt;p&gt;一般来说，Node有三种方法，传播一个错误。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用throw语句抛出一个错误对象，即抛出异常。&lt;/li&gt;
&lt;li&gt;将错误对象传递给回调函数，由回调函数负责发出错误。&lt;/li&gt;
&lt;li&gt;通过EventEmitter接口，发出一个error事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;try-catch结构:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;try&amp;hellip;catch结构&lt;/h3&gt;

&lt;p&gt;最常用的捕获异常的方式，就是使用try&amp;hellip;catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;try {
  process.nextTick(function () {
    throw new Error(&amp;quot;error&amp;quot;);
  });
} catch (err) {
  //can not catch it
  console.log(err);
}

try {
  setTimeout(function(){
    throw new Error(&amp;quot;error&amp;quot;);
  },1)
} catch (err) {
  //can not catch it
  console.log(err);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码分别用process.nextTick和setTimeout方法，在下一轮事件循环抛出两个异常，代表异步操作抛出的错误。它们都无法被catch代码块捕获，因此catch代码块所在的那部分已经运行结束了。&lt;/p&gt;

&lt;p&gt;一种解决方法是将错误捕获代码，也放到异步执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function async(cb, err) {
  setTimeout(function() {
    try {
      if (true)
        throw new Error(&amp;quot;woops!&amp;quot;);
      else
        cb(&amp;quot;done&amp;quot;);
    } catch(e) {
      err(e);
    }
  }, 2000)
}

async(function(res) {
  console.log(&amp;quot;received:&amp;quot;, res);
}, function(err) {
  console.log(&amp;quot;Error: async threw an exception:&amp;quot;, err);
});
// Error: async threw an exception: Error: woops!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，async函数异步抛出的错误，可以同样部署在异步的catch代码块捕获。&lt;/p&gt;

&lt;p&gt;这两种处理方法都不太理想。一般来说，Node只在很少场合才用try/catch语句，比如使用&lt;code&gt;JSON.parse&lt;/code&gt;解析JSON文本。&lt;/p&gt;

&lt;h3 id=&#34;回调函数:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;回调函数&lt;/h3&gt;

&lt;p&gt;Node采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;fs.readFile(&#39;/foo.txt&#39;, function(err, data) {
  if (err !== null) throw err;
  console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码表示，读取文件&lt;code&gt;foo.txt&lt;/code&gt;是一个异步操作，它的回调函数有两个参数，第一个是错误对象，第二个是读取到的文件数据。如果第一个参数不是null，就意味着发生错误，后面代码也就不再执行了。&lt;/p&gt;

&lt;p&gt;下面是一个完整的例子。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function async2(continuation) {
  setTimeout(function() {
    try {
      var res = 42;
      if (true)
        throw new Error(&amp;quot;woops!&amp;quot;);
      else
        continuation(null, res); // pass &#39;null&#39; for error
    } catch(e) {
      continuation(e, null);
    }
  }, 2000);
}

async2(function(err, res) {
  if (err)
    console.log(&amp;quot;Error: (cps) failed:&amp;quot;, err);
  else
    console.log(&amp;quot;(cps) received:&amp;quot;, res);
});
// Error: (cps) failed: woops!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，async2函数的回调函数的第一个参数就是一个错误对象，这是为了处理异步操作抛出的错误。&lt;/p&gt;

&lt;h3 id=&#34;eventemitter接口的error事件:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;EventEmitter接口的error事件&lt;/h3&gt;

&lt;p&gt;发生错误的时候，也可以用EventEmitter接口抛出error事件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var EventEmitter = require(&#39;events&#39;).EventEmitter;
var emitter = new EventEmitter();

emitter.emit(&#39;error&#39;, new Error(&#39;something bad happened&#39;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用上面的代码必须小心，因为如果没有对error事件部署监听函数，会导致整个应用程序崩溃。所以，一般总是必须同时部署下面的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;emitter.on(&#39;error&#39;, function(err) {
  console.error(&#39;出错：&#39; + err.message);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;uncaughtexception事件:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;uncaughtException事件&lt;/h3&gt;

&lt;p&gt;当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.on(&#39;uncaughtException&#39;, function(err) {
  console.error(&#39;Error caught in uncaughtException event:&#39;, err);
});

try {
  setTimeout(function(){
    throw new Error(&amp;quot;error&amp;quot;);
  },1)
} catch (err) {
  //can not catch it
  console.log(err);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.on(&#39;uncaughtException&#39;, function(err) {
  logger(err);
  process.exit(1);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unhandledrejection事件:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;unhandledRejection事件&lt;/h3&gt;

&lt;p&gt;iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var promise = new Promise(function(resolve, reject) {
  reject(new Error(&amp;quot;Broken.&amp;quot;));
});

promise.then(function(result) {
  console.log(result);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码中，promise的状态变为rejected，并且抛出一个错误。但是，不会有任何反应，因为没有设置任何处理函数。&lt;/p&gt;

&lt;p&gt;只要监听unhandledRejection事件，就能解决这个问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;process.on(&#39;unhandledRejection&#39;, function (err, p) {
  console.error(err.stack);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是产生错误的promise对象。这可以提供很多有用的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var http = require(&#39;http&#39;);

http.createServer(function (req, res) {
  var promise = new Promise(function(resolve, reject) {
    reject(new Error(&amp;quot;Broken.&amp;quot;))
  })

  p.info = {url: req.url}
}).listen(8080)

process.on(&#39;unhandledRejection&#39;, function (err, p) {
  if (p.info &amp;amp;&amp;amp; p.info.url) {
    console.log(&#39;Error in URL&#39;, p.info.url)
  }
  console.error(err.stack)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码会在出错时，输出用户请求的网址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Error in URL /testurl
Error: Broken.
  at /Users/mikeal/tmp/test.js:9:14
  at Server.&amp;lt;anonymous&amp;gt; (/Users/mikeal/tmp/test.js:4:17)
  at emitTwo (events.js:87:13)
  at Server.emit (events.js:169:7)
  at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:471:12)
  at HTTPParser.parserOnHeadersComplete (_http_common.js:88:23)
  at Socket.socketOnData (_http_server.js:322:22)
  at emitOne (events.js:77:13)
  at Socket.emit (events.js:166:7)
  at readableAddChunk (_stream_readable.js:145:16)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;命令行脚本:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;命令行脚本&lt;/h2&gt;

&lt;p&gt;node脚本可以作为命令行脚本使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ node foo.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码执行了foo.js脚本文件。&lt;/p&gt;

&lt;p&gt;foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/usr/bin/env node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用前，需更改文件的执行权限。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod u+x myscript.js
$ ./foo.js arg1 arg2 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为命令行脚本时，&lt;code&gt;console.log&lt;/code&gt;用于输出内容到标准输出，&lt;code&gt;process.stdin&lt;/code&gt;用于读取标准输入，&lt;code&gt;child_process.exec()&lt;/code&gt;用于执行一个shell命令。&lt;/p&gt;

&lt;h2 id=&#34;参考链接:ee79a3983aad1cc820034ceeebd97ad6&#34;&gt;参考链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Cody Lindley, &lt;a href=&#34;http://tech.pro/tutorial/1190/package-managers-an-introductory-guide-for-the-uninitiated-front-end-developer&#34;&gt;Package Managers: An Introductory Guide For The Uninitiated Front-End Developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Stack Overflow, &lt;a href=&#34;http://stackoverflow.com/questions/1884724/what-is-node-js&#34;&gt;What is Node.js?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Andrew Burgess, &lt;a href=&#34;http://dev.tutsplus.com/tutorials/using-nodes-event-module--net-35941&#34;&gt;Using Node&amp;rsquo;s Event Module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;James Halliday, &lt;a href=&#34;http://substack.net/task_automation_with_npm_run&#34;&gt;task automation with npm run&lt;/a&gt;- Romain Prieto, &lt;a href=&#34;http://www.asyncdev.net/2013/12/working-on-related-node-modules-locally/&#34;&gt;Working on related Node.js modules locally&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Alon Salant, &lt;a href=&#34;http://bites.goodeggs.com/posts/export-this/&#34;&gt;Export This: Interface Design Patterns for Node.js Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Node.js Manual &amp;amp; Documentation, &lt;a href=&#34;http://nodejs.org/api/modules.html&#34;&gt;Modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Brent Ertz, &lt;a href=&#34;http://quickleft.com/blog/creating-and-publishing-a-node-js-module&#34;&gt;Creating and publishing a node.js module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Fred K Schott, &lt;a href=&#34;http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/&#34;&gt;&amp;ldquo;npm install &amp;ndash;save&amp;rdquo; No Longer Using Tildes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Satans17, &lt;a href=&#34;http://satans17.github.io/2014/05/04/node%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E7%A0%94%E7%A9%B6%E5%BF%83%E5%BE%97/&#34;&gt;Node稳定性的研究心得&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Axel Rauschmayer, &lt;a href=&#34;http://www.2ality.com/2011/12/nodejs-shell-scripting.html&#34;&gt;Write your shell scripts in JavaScript, via Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>